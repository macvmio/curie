// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2020 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// To regenerate api.pb.go run `hack/update-codegen.sh protobindings`

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum Runtime_V1_Protocol: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case tcp // = 0
    case udp // = 1
    case sctp // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .tcp
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .tcp
        case 1: self = .udp
        case 2: self = .sctp
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .tcp: return 0
        case .udp: return 1
        case .sctp: return 2
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_Protocol: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_Protocol] = [
            .tcp,
            .udp,
            .sctp,
        ]
    }

#endif // swift(>=4.2)

enum Runtime_V1_MountPropagation: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// No mount propagation ("rprivate" in Linux terminology).
    case propagationPrivate // = 0

    /// Mounts get propagated from the host to the container ("rslave" in Linux).
    case propagationHostToContainer // = 1

    /// Mounts get propagated from the host to the container and from the
    /// container to the host ("rshared" in Linux).
    case propagationBidirectional // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .propagationPrivate
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .propagationPrivate
        case 1: self = .propagationHostToContainer
        case 2: self = .propagationBidirectional
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .propagationPrivate: return 0
        case .propagationHostToContainer: return 1
        case .propagationBidirectional: return 2
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_MountPropagation: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_MountPropagation] = [
            .propagationPrivate,
            .propagationHostToContainer,
            .propagationBidirectional,
        ]
    }

#endif // swift(>=4.2)

/// A NamespaceMode describes the intended namespace configuration for each
/// of the namespaces (Network, PID, IPC) in NamespaceOption. Runtimes should
/// map these modes as appropriate for the technology underlying the runtime.
enum Runtime_V1_NamespaceMode: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// A POD namespace is common to all containers in a pod.
    /// For example, a container with a PID namespace of POD expects to view
    /// all of the processes in all of the containers in the pod.
    case pod // = 0

    /// A CONTAINER namespace is restricted to a single container.
    /// For example, a container with a PID namespace of CONTAINER expects to
    /// view only the processes in that container.
    case container // = 1

    /// A NODE namespace is the namespace of the Kubernetes node.
    /// For example, a container with a PID namespace of NODE expects to view
    /// all of the processes on the host running the kubelet.
    case node // = 2

    /// TARGET targets the namespace of another container. When this is specified,
    /// a target_id must be specified in NamespaceOption and refer to a container
    /// previously created with NamespaceMode CONTAINER. This containers namespace
    /// will be made to match that of container target_id.
    /// For example, a container with a PID namespace of TARGET expects to view
    /// all of the processes that container target_id can view.
    case target // = 3
    case UNRECOGNIZED(Int)

    init() {
        self = .pod
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .pod
        case 1: self = .container
        case 2: self = .node
        case 3: self = .target
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .pod: return 0
        case .container: return 1
        case .node: return 2
        case .target: return 3
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_NamespaceMode: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_NamespaceMode] = [
            .pod,
            .container,
            .node,
            .target,
        ]
    }

#endif // swift(>=4.2)

/// SupplementalGroupsPolicy defines how supplemental groups
/// of the first container processes are calculated.
enum Runtime_V1_SupplementalGroupsPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Merge means that the container's provided SupplementalGroups
    /// and FsGroup (specified in SecurityContext) will be merged with
    /// the primary user's groups as defined in the container image
    /// (in /etc/group).
    case merge // = 0

    /// Strict means that the container's provided SupplementalGroups
    /// and FsGroup (specified in SecurityContext) will be used instead of
    /// any groups defined in the container image.
    case strict // = 1
    case UNRECOGNIZED(Int)

    init() {
        self = .merge
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .merge
        case 1: self = .strict
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .merge: return 0
        case .strict: return 1
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_SupplementalGroupsPolicy: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_SupplementalGroupsPolicy] = [
            .merge,
            .strict,
        ]
    }

#endif // swift(>=4.2)

enum Runtime_V1_PodSandboxState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case sandboxReady // = 0
    case sandboxNotready // = 1
    case UNRECOGNIZED(Int)

    init() {
        self = .sandboxReady
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .sandboxReady
        case 1: self = .sandboxNotready
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .sandboxReady: return 0
        case .sandboxNotready: return 1
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_PodSandboxState: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_PodSandboxState] = [
            .sandboxReady,
            .sandboxNotready,
        ]
    }

#endif // swift(>=4.2)

enum Runtime_V1_ContainerState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case containerCreated // = 0
    case containerRunning // = 1
    case containerExited // = 2
    case containerUnknown // = 3
    case UNRECOGNIZED(Int)

    init() {
        self = .containerCreated
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .containerCreated
        case 1: self = .containerRunning
        case 2: self = .containerExited
        case 3: self = .containerUnknown
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .containerCreated: return 0
        case .containerRunning: return 1
        case .containerExited: return 2
        case .containerUnknown: return 3
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_ContainerState: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_ContainerState] = [
            .containerCreated,
            .containerRunning,
            .containerExited,
            .containerUnknown,
        ]
    }

#endif // swift(>=4.2)

enum Runtime_V1_ContainerEventType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Container created
    case containerCreatedEvent // = 0

    /// Container started
    case containerStartedEvent // = 1

    /// Container stopped
    case containerStoppedEvent // = 2

    /// Container deleted
    case containerDeletedEvent // = 3
    case UNRECOGNIZED(Int)

    init() {
        self = .containerCreatedEvent
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .containerCreatedEvent
        case 1: self = .containerStartedEvent
        case 2: self = .containerStoppedEvent
        case 3: self = .containerDeletedEvent
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .containerCreatedEvent: return 0
        case .containerStartedEvent: return 1
        case .containerStoppedEvent: return 2
        case .containerDeletedEvent: return 3
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_ContainerEventType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_ContainerEventType] = [
            .containerCreatedEvent,
            .containerStartedEvent,
            .containerStoppedEvent,
            .containerDeletedEvent,
        ]
    }

#endif // swift(>=4.2)

enum Runtime_V1_MetricType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case counter // = 0
    case gauge // = 1
    case UNRECOGNIZED(Int)

    init() {
        self = .counter
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .counter
        case 1: self = .gauge
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .counter: return 0
        case .gauge: return 1
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_MetricType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_MetricType] = [
            .counter,
            .gauge,
        ]
    }

#endif // swift(>=4.2)

enum Runtime_V1_CgroupDriver: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case systemd // = 0
    case cgroupfs // = 1
    case UNRECOGNIZED(Int)

    init() {
        self = .systemd
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .systemd
        case 1: self = .cgroupfs
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .systemd: return 0
        case .cgroupfs: return 1
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Runtime_V1_CgroupDriver: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_CgroupDriver] = [
            .systemd,
            .cgroupfs,
        ]
    }

#endif // swift(>=4.2)

struct Runtime_V1_VersionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Version of the kubelet runtime API.
    var version: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_VersionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Version of the kubelet runtime API.
    var version: String = .init()

    /// Name of the container runtime.
    var runtimeName: String = .init()

    /// Version of the container runtime. The string must be
    /// semver-compatible.
    var runtimeVersion: String = .init()

    /// API version of the container runtime. The string must be
    /// semver-compatible.
    var runtimeApiVersion: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// DNSConfig specifies the DNS servers and search domains of a sandbox.
struct Runtime_V1_DNSConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of DNS servers of the cluster.
    var servers: [String] = []

    /// List of DNS search domains of the cluster.
    var searches: [String] = []

    /// List of DNS options. See https://linux.die.net/man/5/resolv.conf
    /// for all available options.
    var options: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// PortMapping specifies the port mapping configurations of a sandbox.
struct Runtime_V1_PortMapping {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Protocol of the port mapping.
    var `protocol`: Runtime_V1_Protocol = .tcp

    /// Port number within the container. Default: 0 (not specified).
    var containerPort: Int32 = 0

    /// Port number on the host. Default: 0 (not specified).
    var hostPort: Int32 = 0

    /// Host IP.
    var hostIp: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Mount specifies a host volume to mount into a container.
struct Runtime_V1_Mount {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Path of the mount within the container.
    var containerPath: String = .init()

    /// Path of the mount on the host. If the hostPath doesn't exist, then runtimes
    /// should report error. If the hostpath is a symbolic link, runtimes should
    /// follow the symlink and mount the real destination to container.
    var hostPath: String = .init()

    /// If set, the mount is read-only.
    var readonly: Bool = false

    /// If set, the mount needs SELinux relabeling.
    var selinuxRelabel: Bool = false

    /// Requested propagation mode.
    var propagation: Runtime_V1_MountPropagation = .propagationPrivate

    /// UidMappings specifies the runtime UID mappings for the mount.
    var uidMappings: [Runtime_V1_IDMapping] = []

    /// GidMappings specifies the runtime GID mappings for the mount.
    var gidMappings: [Runtime_V1_IDMapping] = []

    /// If set to true, the mount is made recursive read-only.
    /// In this CRI API, recursive_read_only is a plain true/false boolean, although its equivalent
    /// in the Kubernetes core API is a quaternary that can be nil, "Enabled", "IfPossible", or "Disabled".
    /// kubelet translates that quaternary value in the core API into a boolean in this CRI API.
    /// Remarks:
    /// - nil is just treated as false
    /// - when set to true, readonly must be explicitly set to true, and propagation must be PRIVATE (0).
    /// - (readonly == false && recursive_read_only == false) does not make the mount read-only.
    var recursiveReadOnly: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// IDMapping describes host to container ID mappings for a pod sandbox.
struct Runtime_V1_IDMapping {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// HostId is the id on the host.
    var hostID: UInt32 = 0

    /// ContainerId is the id in the container.
    var containerID: UInt32 = 0

    /// Length is the size of the range to map.
    var length: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// UserNamespace describes the intended user namespace configuration for a pod sandbox.
struct Runtime_V1_UserNamespace {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Mode is the NamespaceMode for this UserNamespace.
    /// Note: NamespaceMode for UserNamespace currently supports only POD and NODE, not CONTAINER OR TARGET.
    var mode: Runtime_V1_NamespaceMode = .pod

    /// Uids specifies the UID mappings for the user namespace.
    var uids: [Runtime_V1_IDMapping] = []

    /// Gids specifies the GID mappings for the user namespace.
    var gids: [Runtime_V1_IDMapping] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// NamespaceOption provides options for Linux namespaces.
struct Runtime_V1_NamespaceOption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Network namespace for this container/sandbox.
    /// Note: There is currently no way to set CONTAINER scoped network in the Kubernetes API.
    /// Namespaces currently set by the kubelet: POD, NODE
    var network: Runtime_V1_NamespaceMode = .pod

    /// PID namespace for this container/sandbox.
    /// Note: The CRI default is POD, but the v1.PodSpec default is CONTAINER.
    /// The kubelet's runtime manager will set this to CONTAINER explicitly for v1 pods.
    /// Namespaces currently set by the kubelet: POD, CONTAINER, NODE, TARGET
    var pid: Runtime_V1_NamespaceMode = .pod

    /// IPC namespace for this container/sandbox.
    /// Note: There is currently no way to set CONTAINER scoped IPC in the Kubernetes API.
    /// Namespaces currently set by the kubelet: POD, NODE
    var ipc: Runtime_V1_NamespaceMode = .pod

    /// Target Container ID for NamespaceMode of TARGET. This container must have been
    /// previously created in the same pod. It is not possible to specify different targets
    /// for each namespace.
    var targetID: String = .init()

    /// UsernsOptions for this pod sandbox.
    /// The Kubelet picks the user namespace configuration to use for the pod sandbox.  The mappings
    /// are specified as part of the UserNamespace struct.  If the struct is nil, then the POD mode
    /// must be assumed.  This is done for backward compatibility with older Kubelet versions that
    /// do not set a user namespace.
    var usernsOptions: Runtime_V1_UserNamespace {
        get { _usernsOptions ?? Runtime_V1_UserNamespace() }
        set { _usernsOptions = newValue }
    }

    /// Returns true if `usernsOptions` has been explicitly set.
    var hasUsernsOptions: Bool { _usernsOptions != nil }
    /// Clears the value of `usernsOptions`. Subsequent reads from it will return its default value.
    mutating func clearUsernsOptions() { _usernsOptions = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _usernsOptions: Runtime_V1_UserNamespace?
}

/// Int64Value is the wrapper of int64.
struct Runtime_V1_Int64Value {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The value.
    var value: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// LinuxSandboxSecurityContext holds linux security configuration that will be
/// applied to a sandbox. Note that:
/// 1) It does not apply to containers in the pods.
/// 2) It may not be applicable to a PodSandbox which does not contain any running
///    process.
struct Runtime_V1_LinuxSandboxSecurityContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Configurations for the sandbox's namespaces.
    /// This will be used only if the PodSandbox uses namespace for isolation.
    var namespaceOptions: Runtime_V1_NamespaceOption {
        get { _storage._namespaceOptions ?? Runtime_V1_NamespaceOption() }
        set { _uniqueStorage()._namespaceOptions = newValue }
    }

    /// Returns true if `namespaceOptions` has been explicitly set.
    var hasNamespaceOptions: Bool { _storage._namespaceOptions != nil }
    /// Clears the value of `namespaceOptions`. Subsequent reads from it will return its default value.
    mutating func clearNamespaceOptions() { _uniqueStorage()._namespaceOptions = nil }

    /// Optional SELinux context to be applied.
    var selinuxOptions: Runtime_V1_SELinuxOption {
        get { _storage._selinuxOptions ?? Runtime_V1_SELinuxOption() }
        set { _uniqueStorage()._selinuxOptions = newValue }
    }

    /// Returns true if `selinuxOptions` has been explicitly set.
    var hasSelinuxOptions: Bool { _storage._selinuxOptions != nil }
    /// Clears the value of `selinuxOptions`. Subsequent reads from it will return its default value.
    mutating func clearSelinuxOptions() { _uniqueStorage()._selinuxOptions = nil }

    /// UID to run sandbox processes as, when applicable.
    var runAsUser: Runtime_V1_Int64Value {
        get { _storage._runAsUser ?? Runtime_V1_Int64Value() }
        set { _uniqueStorage()._runAsUser = newValue }
    }

    /// Returns true if `runAsUser` has been explicitly set.
    var hasRunAsUser: Bool { _storage._runAsUser != nil }
    /// Clears the value of `runAsUser`. Subsequent reads from it will return its default value.
    mutating func clearRunAsUser() { _uniqueStorage()._runAsUser = nil }

    /// GID to run sandbox processes as, when applicable. run_as_group should only
    /// be specified when run_as_user is specified; otherwise, the runtime MUST error.
    var runAsGroup: Runtime_V1_Int64Value {
        get { _storage._runAsGroup ?? Runtime_V1_Int64Value() }
        set { _uniqueStorage()._runAsGroup = newValue }
    }

    /// Returns true if `runAsGroup` has been explicitly set.
    var hasRunAsGroup: Bool { _storage._runAsGroup != nil }
    /// Clears the value of `runAsGroup`. Subsequent reads from it will return its default value.
    mutating func clearRunAsGroup() { _uniqueStorage()._runAsGroup = nil }

    /// If set, the root filesystem of the sandbox is read-only.
    var readonlyRootfs: Bool {
        get { _storage._readonlyRootfs }
        set { _uniqueStorage()._readonlyRootfs = newValue }
    }

    /// List of groups applied to the first process run in each container.
    /// supplemental_groups_policy can control how groups will be calculated.
    var supplementalGroups: [Int64] {
        get { _storage._supplementalGroups }
        set { _uniqueStorage()._supplementalGroups = newValue }
    }

    /// supplemental_groups_policy defines how supplemental groups of the first
    /// container processes are calculated.
    /// Valid values are "Merge" and "Strict".
    /// If not specified, "Merge" is used.
    var supplementalGroupsPolicy: Runtime_V1_SupplementalGroupsPolicy {
        get { _storage._supplementalGroupsPolicy }
        set { _uniqueStorage()._supplementalGroupsPolicy = newValue }
    }

    /// Indicates whether the sandbox will be asked to run a privileged
    /// container. If a privileged container is to be executed within it, this
    /// MUST be true.
    /// This allows a sandbox to take additional security precautions if no
    /// privileged containers are expected to be run.
    var privileged: Bool {
        get { _storage._privileged }
        set { _uniqueStorage()._privileged = newValue }
    }

    /// Seccomp profile for the sandbox.
    var seccomp: Runtime_V1_SecurityProfile {
        get { _storage._seccomp ?? Runtime_V1_SecurityProfile() }
        set { _uniqueStorage()._seccomp = newValue }
    }

    /// Returns true if `seccomp` has been explicitly set.
    var hasSeccomp: Bool { _storage._seccomp != nil }
    /// Clears the value of `seccomp`. Subsequent reads from it will return its default value.
    mutating func clearSeccomp() { _uniqueStorage()._seccomp = nil }

    /// AppArmor profile for the sandbox.
    var apparmor: Runtime_V1_SecurityProfile {
        get { _storage._apparmor ?? Runtime_V1_SecurityProfile() }
        set { _uniqueStorage()._apparmor = newValue }
    }

    /// Returns true if `apparmor` has been explicitly set.
    var hasApparmor: Bool { _storage._apparmor != nil }
    /// Clears the value of `apparmor`. Subsequent reads from it will return its default value.
    mutating func clearApparmor() { _uniqueStorage()._apparmor = nil }

    /// Seccomp profile for the sandbox, candidate values are:
    /// * runtime/default: the default profile for the container runtime
    /// * unconfined: unconfined profile, ie, no seccomp sandboxing
    /// * localhost/<full-path-to-profile>: the profile installed on the node.
    ///   <full-path-to-profile> is the full path of the profile.
    /// Default: "", which is identical with unconfined.
    var seccompProfilePath: String {
        get { _storage._seccompProfilePath }
        set { _uniqueStorage()._seccompProfilePath = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// A security profile which can be used for sandboxes and containers.
struct Runtime_V1_SecurityProfile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Indicator which `ProfileType` should be applied.
    var profileType: Runtime_V1_SecurityProfile.ProfileType = .runtimeDefault

    /// Indicates that a pre-defined profile on the node should be used.
    /// Must only be set if `ProfileType` is `Localhost`.
    /// For seccomp, it must be an absolute path to the seccomp profile.
    /// For AppArmor, this field is the AppArmor `<profile name>/`
    var localhostRef: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Available profile types.
    enum ProfileType: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// The container runtime default profile should be used.
        case runtimeDefault // = 0

        /// Disable the feature for the sandbox or the container.
        case unconfined // = 1

        /// A pre-defined profile on the node should be used.
        case localhost // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .runtimeDefault
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .runtimeDefault
            case 1: self = .unconfined
            case 2: self = .localhost
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .runtimeDefault: return 0
            case .unconfined: return 1
            case .localhost: return 2
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    init() {}
}

#if swift(>=4.2)

    extension Runtime_V1_SecurityProfile.ProfileType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Runtime_V1_SecurityProfile.ProfileType] = [
            .runtimeDefault,
            .unconfined,
            .localhost,
        ]
    }

#endif // swift(>=4.2)

/// LinuxPodSandboxConfig holds platform-specific configurations for Linux
/// host platforms and Linux-based containers.
struct Runtime_V1_LinuxPodSandboxConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent cgroup of the PodSandbox.
    /// The cgroupfs style syntax will be used, but the container runtime can
    /// convert it to systemd semantics if needed.
    var cgroupParent: String {
        get { _storage._cgroupParent }
        set { _uniqueStorage()._cgroupParent = newValue }
    }

    /// LinuxSandboxSecurityContext holds sandbox security attributes.
    var securityContext: Runtime_V1_LinuxSandboxSecurityContext {
        get { _storage._securityContext ?? Runtime_V1_LinuxSandboxSecurityContext() }
        set { _uniqueStorage()._securityContext = newValue }
    }

    /// Returns true if `securityContext` has been explicitly set.
    var hasSecurityContext: Bool { _storage._securityContext != nil }
    /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
    mutating func clearSecurityContext() { _uniqueStorage()._securityContext = nil }

    /// Sysctls holds linux sysctls config for the sandbox.
    var sysctls: [String: String] {
        get { _storage._sysctls }
        set { _uniqueStorage()._sysctls = newValue }
    }

    /// Optional overhead represents the overheads associated with this sandbox
    var overhead: Runtime_V1_LinuxContainerResources {
        get { _storage._overhead ?? Runtime_V1_LinuxContainerResources() }
        set { _uniqueStorage()._overhead = newValue }
    }

    /// Returns true if `overhead` has been explicitly set.
    var hasOverhead: Bool { _storage._overhead != nil }
    /// Clears the value of `overhead`. Subsequent reads from it will return its default value.
    mutating func clearOverhead() { _uniqueStorage()._overhead = nil }

    /// Optional resources represents the sum of container resources for this sandbox
    var resources: Runtime_V1_LinuxContainerResources {
        get { _storage._resources ?? Runtime_V1_LinuxContainerResources() }
        set { _uniqueStorage()._resources = newValue }
    }

    /// Returns true if `resources` has been explicitly set.
    var hasResources: Bool { _storage._resources != nil }
    /// Clears the value of `resources`. Subsequent reads from it will return its default value.
    mutating func clearResources() { _uniqueStorage()._resources = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodSandboxMetadata holds all necessary information for building the sandbox name.
/// The container runtime is encouraged to expose the metadata associated with the
/// PodSandbox in its user interface for better user experience. For example,
/// the runtime can construct a unique PodSandboxName based on the metadata.
struct Runtime_V1_PodSandboxMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Pod name of the sandbox. Same as the pod name in the Pod ObjectMeta.
    var name: String = .init()

    /// Pod UID of the sandbox. Same as the pod UID in the Pod ObjectMeta.
    var uid: String = .init()

    /// Pod namespace of the sandbox. Same as the pod namespace in the Pod ObjectMeta.
    var namespace: String = .init()

    /// Attempt number of creating the sandbox. Default: 0.
    var attempt: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// PodSandboxConfig holds all the required and optional fields for creating a
/// sandbox.
struct Runtime_V1_PodSandboxConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Metadata of the sandbox. This information will uniquely identify the
    /// sandbox, and the runtime should leverage this to ensure correct
    /// operation. The runtime may also use this information to improve UX, such
    /// as by constructing a readable name.
    var metadata: Runtime_V1_PodSandboxMetadata {
        get { _storage._metadata ?? Runtime_V1_PodSandboxMetadata() }
        set { _uniqueStorage()._metadata = newValue }
    }

    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool { _storage._metadata != nil }
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() { _uniqueStorage()._metadata = nil }

    /// Hostname of the sandbox. Hostname could only be empty when the pod
    /// network namespace is NODE.
    var hostname: String {
        get { _storage._hostname }
        set { _uniqueStorage()._hostname = newValue }
    }

    /// Path to the directory on the host in which container log files are
    /// stored.
    /// By default the log of a container going into the LogDirectory will be
    /// hooked up to STDOUT and STDERR. However, the LogDirectory may contain
    /// binary log files with structured logging data from the individual
    /// containers. For example, the files might be newline separated JSON
    /// structured logs, systemd-journald journal files, gRPC trace files, etc.
    /// E.g.,
    ///     PodSandboxConfig.LogDirectory = `/var/log/pods/<NAMESPACE>_<NAME>_<UID>/`
    ///     ContainerConfig.LogPath = `containerName/Instance#.log`
    var logDirectory: String {
        get { _storage._logDirectory }
        set { _uniqueStorage()._logDirectory = newValue }
    }

    /// DNS config for the sandbox.
    var dnsConfig: Runtime_V1_DNSConfig {
        get { _storage._dnsConfig ?? Runtime_V1_DNSConfig() }
        set { _uniqueStorage()._dnsConfig = newValue }
    }

    /// Returns true if `dnsConfig` has been explicitly set.
    var hasDnsConfig: Bool { _storage._dnsConfig != nil }
    /// Clears the value of `dnsConfig`. Subsequent reads from it will return its default value.
    mutating func clearDnsConfig() { _uniqueStorage()._dnsConfig = nil }

    /// Port mappings for the sandbox.
    var portMappings: [Runtime_V1_PortMapping] {
        get { _storage._portMappings }
        set { _uniqueStorage()._portMappings = newValue }
    }

    /// Key-value pairs that may be used to scope and select individual resources.
    var labels: [String: String] {
        get { _storage._labels }
        set { _uniqueStorage()._labels = newValue }
    }

    /// Unstructured key-value map that may be set by the kubelet to store and
    /// retrieve arbitrary metadata. This will include any annotations set on a
    /// pod through the Kubernetes API.
    ///
    /// Annotations MUST NOT be altered by the runtime; the annotations stored
    /// here MUST be returned in the PodSandboxStatus associated with the pod
    /// this PodSandboxConfig creates.
    ///
    /// In general, in order to preserve a well-defined interface between the
    /// kubelet and the container runtime, annotations SHOULD NOT influence
    /// runtime behaviour.
    ///
    /// Annotations can also be useful for runtime authors to experiment with
    /// new features that are opaque to the Kubernetes APIs (both user-facing
    /// and the CRI). Whenever possible, however, runtime authors SHOULD
    /// consider proposing new typed fields for any new features instead.
    var annotations: [String: String] {
        get { _storage._annotations }
        set { _uniqueStorage()._annotations = newValue }
    }

    /// Optional configurations specific to Linux hosts.
    var linux: Runtime_V1_LinuxPodSandboxConfig {
        get { _storage._linux ?? Runtime_V1_LinuxPodSandboxConfig() }
        set { _uniqueStorage()._linux = newValue }
    }

    /// Returns true if `linux` has been explicitly set.
    var hasLinux: Bool { _storage._linux != nil }
    /// Clears the value of `linux`. Subsequent reads from it will return its default value.
    mutating func clearLinux() { _uniqueStorage()._linux = nil }

    /// Optional configurations specific to Windows hosts.
    var windows: Runtime_V1_WindowsPodSandboxConfig {
        get { _storage._windows ?? Runtime_V1_WindowsPodSandboxConfig() }
        set { _uniqueStorage()._windows = newValue }
    }

    /// Returns true if `windows` has been explicitly set.
    var hasWindows: Bool { _storage._windows != nil }
    /// Clears the value of `windows`. Subsequent reads from it will return its default value.
    mutating func clearWindows() { _uniqueStorage()._windows = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_RunPodSandboxRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Configuration for creating a PodSandbox.
    var config: Runtime_V1_PodSandboxConfig {
        get { _config ?? Runtime_V1_PodSandboxConfig() }
        set { _config = newValue }
    }

    /// Returns true if `config` has been explicitly set.
    var hasConfig: Bool { _config != nil }
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    mutating func clearConfig() { _config = nil }

    /// Named runtime configuration to use for this PodSandbox.
    /// If the runtime handler is unknown, this request should be rejected.  An
    /// empty string should select the default handler, equivalent to the
    /// behavior before this feature was added.
    /// See https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
    var runtimeHandler: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _config: Runtime_V1_PodSandboxConfig?
}

struct Runtime_V1_RunPodSandboxResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the PodSandbox to run.
    var podSandboxID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_StopPodSandboxRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the PodSandbox to stop.
    var podSandboxID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_StopPodSandboxResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RemovePodSandboxRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the PodSandbox to remove.
    var podSandboxID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RemovePodSandboxResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_PodSandboxStatusRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the PodSandbox for which to retrieve status.
    var podSandboxID: String = .init()

    /// Verbose indicates whether to return extra information about the pod sandbox.
    var verbose: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// PodIP represents an ip of a Pod
struct Runtime_V1_PodIP {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// an ip is a string representation of an IPv4 or an IPv6
    var ip: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// PodSandboxNetworkStatus is the status of the network for a PodSandbox.
/// Currently ignored for pods sharing the host networking namespace.
struct Runtime_V1_PodSandboxNetworkStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// IP address of the PodSandbox.
    var ip: String = .init()

    /// list of additional ips (not inclusive of PodSandboxNetworkStatus.Ip) of the PodSandBoxNetworkStatus
    var additionalIps: [Runtime_V1_PodIP] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Namespace contains paths to the namespaces.
struct Runtime_V1_Namespace {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace options for Linux namespaces.
    var options: Runtime_V1_NamespaceOption {
        get { _options ?? Runtime_V1_NamespaceOption() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    mutating func clearOptions() { _options = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _options: Runtime_V1_NamespaceOption?
}

/// LinuxSandboxStatus contains status specific to Linux sandboxes.
struct Runtime_V1_LinuxPodSandboxStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Paths to the sandbox's namespaces.
    var namespaces: Runtime_V1_Namespace {
        get { _namespaces ?? Runtime_V1_Namespace() }
        set { _namespaces = newValue }
    }

    /// Returns true if `namespaces` has been explicitly set.
    var hasNamespaces: Bool { _namespaces != nil }
    /// Clears the value of `namespaces`. Subsequent reads from it will return its default value.
    mutating func clearNamespaces() { _namespaces = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _namespaces: Runtime_V1_Namespace?
}

/// PodSandboxStatus contains the status of the PodSandbox.
struct Runtime_V1_PodSandboxStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the sandbox.
    var id: String {
        get { _storage._id }
        set { _uniqueStorage()._id = newValue }
    }

    /// Metadata of the sandbox.
    var metadata: Runtime_V1_PodSandboxMetadata {
        get { _storage._metadata ?? Runtime_V1_PodSandboxMetadata() }
        set { _uniqueStorage()._metadata = newValue }
    }

    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool { _storage._metadata != nil }
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() { _uniqueStorage()._metadata = nil }

    /// State of the sandbox.
    var state: Runtime_V1_PodSandboxState {
        get { _storage._state }
        set { _uniqueStorage()._state = newValue }
    }

    /// Creation timestamp of the sandbox in nanoseconds. Must be > 0.
    var createdAt: Int64 {
        get { _storage._createdAt }
        set { _uniqueStorage()._createdAt = newValue }
    }

    /// Network contains network status if network is handled by the runtime.
    var network: Runtime_V1_PodSandboxNetworkStatus {
        get { _storage._network ?? Runtime_V1_PodSandboxNetworkStatus() }
        set { _uniqueStorage()._network = newValue }
    }

    /// Returns true if `network` has been explicitly set.
    var hasNetwork: Bool { _storage._network != nil }
    /// Clears the value of `network`. Subsequent reads from it will return its default value.
    mutating func clearNetwork() { _uniqueStorage()._network = nil }

    /// Linux-specific status to a pod sandbox.
    var linux: Runtime_V1_LinuxPodSandboxStatus {
        get { _storage._linux ?? Runtime_V1_LinuxPodSandboxStatus() }
        set { _uniqueStorage()._linux = newValue }
    }

    /// Returns true if `linux` has been explicitly set.
    var hasLinux: Bool { _storage._linux != nil }
    /// Clears the value of `linux`. Subsequent reads from it will return its default value.
    mutating func clearLinux() { _uniqueStorage()._linux = nil }

    /// Labels are key-value pairs that may be used to scope and select individual resources.
    var labels: [String: String] {
        get { _storage._labels }
        set { _uniqueStorage()._labels = newValue }
    }

    /// Unstructured key-value map holding arbitrary metadata.
    /// Annotations MUST NOT be altered by the runtime; the value of this field
    /// MUST be identical to that of the corresponding PodSandboxConfig used to
    /// instantiate the pod sandbox this status represents.
    var annotations: [String: String] {
        get { _storage._annotations }
        set { _uniqueStorage()._annotations = newValue }
    }

    /// runtime configuration used for this PodSandbox.
    var runtimeHandler: String {
        get { _storage._runtimeHandler }
        set { _uniqueStorage()._runtimeHandler = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_PodSandboxStatusResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Status of the PodSandbox.
    var status: Runtime_V1_PodSandboxStatus {
        get { _status ?? Runtime_V1_PodSandboxStatus() }
        set { _status = newValue }
    }

    /// Returns true if `status` has been explicitly set.
    var hasStatus: Bool { _status != nil }
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    mutating func clearStatus() { _status = nil }

    /// Info is extra information of the PodSandbox. The key could be arbitrary string, and
    /// value should be in json format. The information could include anything useful for
    /// debug, e.g. network namespace for linux container based container runtime.
    /// It should only be returned non-empty when Verbose is true.
    var info: [String: String] = [:]

    /// Container statuses
    var containersStatuses: [Runtime_V1_ContainerStatus] = []

    /// Timestamp at which container and pod statuses were recorded
    var timestamp: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _status: Runtime_V1_PodSandboxStatus?
}

/// PodSandboxStateValue is the wrapper of PodSandboxState.
struct Runtime_V1_PodSandboxStateValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// State of the sandbox.
    var state: Runtime_V1_PodSandboxState = .sandboxReady

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// PodSandboxFilter is used to filter a list of PodSandboxes.
/// All those fields are combined with 'AND'
struct Runtime_V1_PodSandboxFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the sandbox.
    var id: String = .init()

    /// State of the sandbox.
    var state: Runtime_V1_PodSandboxStateValue {
        get { _state ?? Runtime_V1_PodSandboxStateValue() }
        set { _state = newValue }
    }

    /// Returns true if `state` has been explicitly set.
    var hasState: Bool { _state != nil }
    /// Clears the value of `state`. Subsequent reads from it will return its default value.
    mutating func clearState() { _state = nil }

    /// LabelSelector to select matches.
    /// Only api.MatchLabels is supported for now and the requirements
    /// are ANDed. MatchExpressions is not supported yet.
    var labelSelector: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _state: Runtime_V1_PodSandboxStateValue?
}

struct Runtime_V1_ListPodSandboxRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// PodSandboxFilter to filter a list of PodSandboxes.
    var filter: Runtime_V1_PodSandboxFilter {
        get { _filter ?? Runtime_V1_PodSandboxFilter() }
        set { _filter = newValue }
    }

    /// Returns true if `filter` has been explicitly set.
    var hasFilter: Bool { _filter != nil }
    /// Clears the value of `filter`. Subsequent reads from it will return its default value.
    mutating func clearFilter() { _filter = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _filter: Runtime_V1_PodSandboxFilter?
}

/// PodSandbox contains minimal information about a sandbox.
struct Runtime_V1_PodSandbox {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the PodSandbox.
    var id: String = .init()

    /// Metadata of the PodSandbox.
    var metadata: Runtime_V1_PodSandboxMetadata {
        get { _metadata ?? Runtime_V1_PodSandboxMetadata() }
        set { _metadata = newValue }
    }

    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool { _metadata != nil }
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() { _metadata = nil }

    /// State of the PodSandbox.
    var state: Runtime_V1_PodSandboxState = .sandboxReady

    /// Creation timestamps of the PodSandbox in nanoseconds. Must be > 0.
    var createdAt: Int64 = 0

    /// Labels of the PodSandbox.
    var labels: [String: String] = [:]

    /// Unstructured key-value map holding arbitrary metadata.
    /// Annotations MUST NOT be altered by the runtime; the value of this field
    /// MUST be identical to that of the corresponding PodSandboxConfig used to
    /// instantiate this PodSandbox.
    var annotations: [String: String] = [:]

    /// runtime configuration used for this PodSandbox.
    var runtimeHandler: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _metadata: Runtime_V1_PodSandboxMetadata?
}

struct Runtime_V1_ListPodSandboxResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of PodSandboxes.
    var items: [Runtime_V1_PodSandbox] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_PodSandboxStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the pod sandbox for which to retrieve stats.
    var podSandboxID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_PodSandboxStatsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stats: Runtime_V1_PodSandboxStats {
        get { _stats ?? Runtime_V1_PodSandboxStats() }
        set { _stats = newValue }
    }

    /// Returns true if `stats` has been explicitly set.
    var hasStats: Bool { _stats != nil }
    /// Clears the value of `stats`. Subsequent reads from it will return its default value.
    mutating func clearStats() { _stats = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _stats: Runtime_V1_PodSandboxStats?
}

/// PodSandboxStatsFilter is used to filter the list of pod sandboxes to retrieve stats for.
/// All those fields are combined with 'AND'.
struct Runtime_V1_PodSandboxStatsFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the pod sandbox.
    var id: String = .init()

    /// LabelSelector to select matches.
    /// Only api.MatchLabels is supported for now and the requirements
    /// are ANDed. MatchExpressions is not supported yet.
    var labelSelector: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ListPodSandboxStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Filter for the list request.
    var filter: Runtime_V1_PodSandboxStatsFilter {
        get { _filter ?? Runtime_V1_PodSandboxStatsFilter() }
        set { _filter = newValue }
    }

    /// Returns true if `filter` has been explicitly set.
    var hasFilter: Bool { _filter != nil }
    /// Clears the value of `filter`. Subsequent reads from it will return its default value.
    mutating func clearFilter() { _filter = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _filter: Runtime_V1_PodSandboxStatsFilter?
}

struct Runtime_V1_ListPodSandboxStatsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Stats of the pod sandbox.
    var stats: [Runtime_V1_PodSandboxStats] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// PodSandboxAttributes provides basic information of the pod sandbox.
struct Runtime_V1_PodSandboxAttributes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the pod sandbox.
    var id: String = .init()

    /// Metadata of the pod sandbox.
    var metadata: Runtime_V1_PodSandboxMetadata {
        get { _metadata ?? Runtime_V1_PodSandboxMetadata() }
        set { _metadata = newValue }
    }

    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool { _metadata != nil }
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() { _metadata = nil }

    /// Key-value pairs that may be used to scope and select individual resources.
    var labels: [String: String] = [:]

    /// Unstructured key-value map holding arbitrary metadata.
    /// Annotations MUST NOT be altered by the runtime; the value of this field
    /// MUST be identical to that of the corresponding PodSandboxStatus used to
    /// instantiate the PodSandbox this status represents.
    var annotations: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _metadata: Runtime_V1_PodSandboxMetadata?
}

/// PodSandboxStats provides the resource usage statistics for a pod.
/// The linux or windows field will be populated depending on the platform.
struct Runtime_V1_PodSandboxStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Information of the pod.
    var attributes: Runtime_V1_PodSandboxAttributes {
        get { _attributes ?? Runtime_V1_PodSandboxAttributes() }
        set { _attributes = newValue }
    }

    /// Returns true if `attributes` has been explicitly set.
    var hasAttributes: Bool { _attributes != nil }
    /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
    mutating func clearAttributes() { _attributes = nil }

    /// Stats from linux.
    var linux: Runtime_V1_LinuxPodSandboxStats {
        get { _linux ?? Runtime_V1_LinuxPodSandboxStats() }
        set { _linux = newValue }
    }

    /// Returns true if `linux` has been explicitly set.
    var hasLinux: Bool { _linux != nil }
    /// Clears the value of `linux`. Subsequent reads from it will return its default value.
    mutating func clearLinux() { _linux = nil }

    /// Stats from windows.
    var windows: Runtime_V1_WindowsPodSandboxStats {
        get { _windows ?? Runtime_V1_WindowsPodSandboxStats() }
        set { _windows = newValue }
    }

    /// Returns true if `windows` has been explicitly set.
    var hasWindows: Bool { _windows != nil }
    /// Clears the value of `windows`. Subsequent reads from it will return its default value.
    mutating func clearWindows() { _windows = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attributes: Runtime_V1_PodSandboxAttributes?
    fileprivate var _linux: Runtime_V1_LinuxPodSandboxStats?
    fileprivate var _windows: Runtime_V1_WindowsPodSandboxStats?
}

/// LinuxPodSandboxStats provides the resource usage statistics for a pod sandbox on linux.
struct Runtime_V1_LinuxPodSandboxStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// CPU usage gathered for the pod sandbox.
    var cpu: Runtime_V1_CpuUsage {
        get { _storage._cpu ?? Runtime_V1_CpuUsage() }
        set { _uniqueStorage()._cpu = newValue }
    }

    /// Returns true if `cpu` has been explicitly set.
    var hasCpu: Bool { _storage._cpu != nil }
    /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
    mutating func clearCpu() { _uniqueStorage()._cpu = nil }

    /// Memory usage gathered for the pod sandbox.
    var memory: Runtime_V1_MemoryUsage {
        get { _storage._memory ?? Runtime_V1_MemoryUsage() }
        set { _uniqueStorage()._memory = newValue }
    }

    /// Returns true if `memory` has been explicitly set.
    var hasMemory: Bool { _storage._memory != nil }
    /// Clears the value of `memory`. Subsequent reads from it will return its default value.
    mutating func clearMemory() { _uniqueStorage()._memory = nil }

    /// Network usage gathered for the pod sandbox
    var network: Runtime_V1_NetworkUsage {
        get { _storage._network ?? Runtime_V1_NetworkUsage() }
        set { _uniqueStorage()._network = newValue }
    }

    /// Returns true if `network` has been explicitly set.
    var hasNetwork: Bool { _storage._network != nil }
    /// Clears the value of `network`. Subsequent reads from it will return its default value.
    mutating func clearNetwork() { _uniqueStorage()._network = nil }

    /// Stats pertaining to processes in the pod sandbox.
    var process: Runtime_V1_ProcessUsage {
        get { _storage._process ?? Runtime_V1_ProcessUsage() }
        set { _uniqueStorage()._process = newValue }
    }

    /// Returns true if `process` has been explicitly set.
    var hasProcess: Bool { _storage._process != nil }
    /// Clears the value of `process`. Subsequent reads from it will return its default value.
    mutating func clearProcess() { _uniqueStorage()._process = nil }

    /// Stats of containers in the measured pod sandbox.
    var containers: [Runtime_V1_ContainerStats] {
        get { _storage._containers }
        set { _uniqueStorage()._containers = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// WindowsPodSandboxStats provides the resource usage statistics for a pod sandbox on windows
struct Runtime_V1_WindowsPodSandboxStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// CPU usage gathered for the pod sandbox.
    var cpu: Runtime_V1_WindowsCpuUsage {
        get { _storage._cpu ?? Runtime_V1_WindowsCpuUsage() }
        set { _uniqueStorage()._cpu = newValue }
    }

    /// Returns true if `cpu` has been explicitly set.
    var hasCpu: Bool { _storage._cpu != nil }
    /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
    mutating func clearCpu() { _uniqueStorage()._cpu = nil }

    /// Memory usage gathered for the pod sandbox.
    var memory: Runtime_V1_WindowsMemoryUsage {
        get { _storage._memory ?? Runtime_V1_WindowsMemoryUsage() }
        set { _uniqueStorage()._memory = newValue }
    }

    /// Returns true if `memory` has been explicitly set.
    var hasMemory: Bool { _storage._memory != nil }
    /// Clears the value of `memory`. Subsequent reads from it will return its default value.
    mutating func clearMemory() { _uniqueStorage()._memory = nil }

    /// Network usage gathered for the pod sandbox
    var network: Runtime_V1_WindowsNetworkUsage {
        get { _storage._network ?? Runtime_V1_WindowsNetworkUsage() }
        set { _uniqueStorage()._network = newValue }
    }

    /// Returns true if `network` has been explicitly set.
    var hasNetwork: Bool { _storage._network != nil }
    /// Clears the value of `network`. Subsequent reads from it will return its default value.
    mutating func clearNetwork() { _uniqueStorage()._network = nil }

    /// Stats pertaining to processes in the pod sandbox.
    var process: Runtime_V1_WindowsProcessUsage {
        get { _storage._process ?? Runtime_V1_WindowsProcessUsage() }
        set { _uniqueStorage()._process = newValue }
    }

    /// Returns true if `process` has been explicitly set.
    var hasProcess: Bool { _storage._process != nil }
    /// Clears the value of `process`. Subsequent reads from it will return its default value.
    mutating func clearProcess() { _uniqueStorage()._process = nil }

    /// Stats of containers in the measured pod sandbox.
    var containers: [Runtime_V1_WindowsContainerStats] {
        get { _storage._containers }
        set { _uniqueStorage()._containers = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// NetworkUsage contains data about network resources.
struct Runtime_V1_NetworkUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// Stats for the default network interface.
    var defaultInterface: Runtime_V1_NetworkInterfaceUsage {
        get { _defaultInterface ?? Runtime_V1_NetworkInterfaceUsage() }
        set { _defaultInterface = newValue }
    }

    /// Returns true if `defaultInterface` has been explicitly set.
    var hasDefaultInterface: Bool { _defaultInterface != nil }
    /// Clears the value of `defaultInterface`. Subsequent reads from it will return its default value.
    mutating func clearDefaultInterface() { _defaultInterface = nil }

    /// Stats for all found network interfaces, excluding the default.
    var interfaces: [Runtime_V1_NetworkInterfaceUsage] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _defaultInterface: Runtime_V1_NetworkInterfaceUsage?
}

/// WindowsNetworkUsage contains data about network resources specific to Windows.
struct Runtime_V1_WindowsNetworkUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// Stats for the default network interface.
    var defaultInterface: Runtime_V1_WindowsNetworkInterfaceUsage {
        get { _defaultInterface ?? Runtime_V1_WindowsNetworkInterfaceUsage() }
        set { _defaultInterface = newValue }
    }

    /// Returns true if `defaultInterface` has been explicitly set.
    var hasDefaultInterface: Bool { _defaultInterface != nil }
    /// Clears the value of `defaultInterface`. Subsequent reads from it will return its default value.
    mutating func clearDefaultInterface() { _defaultInterface = nil }

    /// Stats for all found network interfaces, excluding the default.
    var interfaces: [Runtime_V1_WindowsNetworkInterfaceUsage] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _defaultInterface: Runtime_V1_WindowsNetworkInterfaceUsage?
}

/// NetworkInterfaceUsage contains resource value data about a network interface.
struct Runtime_V1_NetworkInterfaceUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the network interface.
    var name: String = .init()

    /// Cumulative count of bytes received.
    var rxBytes: Runtime_V1_UInt64Value {
        get { _rxBytes ?? Runtime_V1_UInt64Value() }
        set { _rxBytes = newValue }
    }

    /// Returns true if `rxBytes` has been explicitly set.
    var hasRxBytes: Bool { _rxBytes != nil }
    /// Clears the value of `rxBytes`. Subsequent reads from it will return its default value.
    mutating func clearRxBytes() { _rxBytes = nil }

    /// Cumulative count of receive errors encountered.
    var rxErrors: Runtime_V1_UInt64Value {
        get { _rxErrors ?? Runtime_V1_UInt64Value() }
        set { _rxErrors = newValue }
    }

    /// Returns true if `rxErrors` has been explicitly set.
    var hasRxErrors: Bool { _rxErrors != nil }
    /// Clears the value of `rxErrors`. Subsequent reads from it will return its default value.
    mutating func clearRxErrors() { _rxErrors = nil }

    /// Cumulative count of bytes transmitted.
    var txBytes: Runtime_V1_UInt64Value {
        get { _txBytes ?? Runtime_V1_UInt64Value() }
        set { _txBytes = newValue }
    }

    /// Returns true if `txBytes` has been explicitly set.
    var hasTxBytes: Bool { _txBytes != nil }
    /// Clears the value of `txBytes`. Subsequent reads from it will return its default value.
    mutating func clearTxBytes() { _txBytes = nil }

    /// Cumulative count of transmit errors encountered.
    var txErrors: Runtime_V1_UInt64Value {
        get { _txErrors ?? Runtime_V1_UInt64Value() }
        set { _txErrors = newValue }
    }

    /// Returns true if `txErrors` has been explicitly set.
    var hasTxErrors: Bool { _txErrors != nil }
    /// Clears the value of `txErrors`. Subsequent reads from it will return its default value.
    mutating func clearTxErrors() { _txErrors = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rxBytes: Runtime_V1_UInt64Value?
    fileprivate var _rxErrors: Runtime_V1_UInt64Value?
    fileprivate var _txBytes: Runtime_V1_UInt64Value?
    fileprivate var _txErrors: Runtime_V1_UInt64Value?
}

/// WindowsNetworkInterfaceUsage contains resource value data about a network interface specific for Windows.
struct Runtime_V1_WindowsNetworkInterfaceUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the network interface.
    var name: String = .init()

    /// Cumulative count of bytes received.
    var rxBytes: Runtime_V1_UInt64Value {
        get { _rxBytes ?? Runtime_V1_UInt64Value() }
        set { _rxBytes = newValue }
    }

    /// Returns true if `rxBytes` has been explicitly set.
    var hasRxBytes: Bool { _rxBytes != nil }
    /// Clears the value of `rxBytes`. Subsequent reads from it will return its default value.
    mutating func clearRxBytes() { _rxBytes = nil }

    /// Cumulative count of receive errors encountered.
    var rxPacketsDropped: Runtime_V1_UInt64Value {
        get { _rxPacketsDropped ?? Runtime_V1_UInt64Value() }
        set { _rxPacketsDropped = newValue }
    }

    /// Returns true if `rxPacketsDropped` has been explicitly set.
    var hasRxPacketsDropped: Bool { _rxPacketsDropped != nil }
    /// Clears the value of `rxPacketsDropped`. Subsequent reads from it will return its default value.
    mutating func clearRxPacketsDropped() { _rxPacketsDropped = nil }

    /// Cumulative count of bytes transmitted.
    var txBytes: Runtime_V1_UInt64Value {
        get { _txBytes ?? Runtime_V1_UInt64Value() }
        set { _txBytes = newValue }
    }

    /// Returns true if `txBytes` has been explicitly set.
    var hasTxBytes: Bool { _txBytes != nil }
    /// Clears the value of `txBytes`. Subsequent reads from it will return its default value.
    mutating func clearTxBytes() { _txBytes = nil }

    /// Cumulative count of transmit errors encountered.
    var txPacketsDropped: Runtime_V1_UInt64Value {
        get { _txPacketsDropped ?? Runtime_V1_UInt64Value() }
        set { _txPacketsDropped = newValue }
    }

    /// Returns true if `txPacketsDropped` has been explicitly set.
    var hasTxPacketsDropped: Bool { _txPacketsDropped != nil }
    /// Clears the value of `txPacketsDropped`. Subsequent reads from it will return its default value.
    mutating func clearTxPacketsDropped() { _txPacketsDropped = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rxBytes: Runtime_V1_UInt64Value?
    fileprivate var _rxPacketsDropped: Runtime_V1_UInt64Value?
    fileprivate var _txBytes: Runtime_V1_UInt64Value?
    fileprivate var _txPacketsDropped: Runtime_V1_UInt64Value?
}

/// ProcessUsage are stats pertaining to processes.
struct Runtime_V1_ProcessUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// Number of processes.
    var processCount: Runtime_V1_UInt64Value {
        get { _processCount ?? Runtime_V1_UInt64Value() }
        set { _processCount = newValue }
    }

    /// Returns true if `processCount` has been explicitly set.
    var hasProcessCount: Bool { _processCount != nil }
    /// Clears the value of `processCount`. Subsequent reads from it will return its default value.
    mutating func clearProcessCount() { _processCount = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _processCount: Runtime_V1_UInt64Value?
}

/// WindowsProcessUsage are stats pertaining to processes specific to Windows.
struct Runtime_V1_WindowsProcessUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// Number of processes.
    var processCount: Runtime_V1_UInt64Value {
        get { _processCount ?? Runtime_V1_UInt64Value() }
        set { _processCount = newValue }
    }

    /// Returns true if `processCount` has been explicitly set.
    var hasProcessCount: Bool { _processCount != nil }
    /// Clears the value of `processCount`. Subsequent reads from it will return its default value.
    mutating func clearProcessCount() { _processCount = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _processCount: Runtime_V1_UInt64Value?
}

/// ImageSpec is an internal representation of an image.
struct Runtime_V1_ImageSpec {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Container's Image field (e.g. imageID or imageDigest).
    var image: String = .init()

    /// Unstructured key-value map holding arbitrary metadata.
    /// ImageSpec Annotations can be used to help the runtime target specific
    /// images in multi-arch images.
    var annotations: [String: String] = [:]

    /// The container image reference specified by the user (e.g. image[:tag] or digest).
    /// Only set if available within the RPC context.
    var userSpecifiedImage: String = .init()

    /// Runtime handler to use for pulling the image.
    /// If the runtime handler is unknown, the request should be rejected.
    /// An empty string would select the default runtime handler.
    var runtimeHandler: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_KeyValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String = .init()

    var value: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// LinuxContainerResources specifies Linux specific configuration for
/// resources.
struct Runtime_V1_LinuxContainerResources {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// CPU CFS (Completely Fair Scheduler) period. Default: 0 (not specified).
    var cpuPeriod: Int64 = 0

    /// CPU CFS (Completely Fair Scheduler) quota. Default: 0 (not specified).
    var cpuQuota: Int64 = 0

    /// CPU shares (relative weight vs. other containers). Default: 0 (not specified).
    var cpuShares: Int64 = 0

    /// Memory limit in bytes. Default: 0 (not specified).
    var memoryLimitInBytes: Int64 = 0

    /// OOMScoreAdj adjusts the oom-killer score. Default: 0 (not specified).
    var oomScoreAdj: Int64 = 0

    /// CpusetCpus constrains the allowed set of logical CPUs. Default: "" (not specified).
    var cpusetCpus: String = .init()

    /// CpusetMems constrains the allowed set of memory nodes. Default: "" (not specified).
    var cpusetMems: String = .init()

    /// List of HugepageLimits to limit the HugeTLB usage of container per page size. Default: nil (not specified).
    var hugepageLimits: [Runtime_V1_HugepageLimit] = []

    /// Unified resources for cgroup v2. Default: nil (not specified).
    /// Each key/value in the map refers to the cgroup v2.
    /// e.g. "memory.max": "6937202688" or "io.weight": "default 100".
    var unified: [String: String] = [:]

    /// Memory swap limit in bytes. Default 0 (not specified).
    var memorySwapLimitInBytes: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// HugepageLimit corresponds to the file`hugetlb.<hugepagesize>.limit_in_byte` in container level cgroup.
/// For example, `PageSize=1GB`, `Limit=1073741824` means setting `1073741824` bytes to hugetlb.1GB.limit_in_bytes.
struct Runtime_V1_HugepageLimit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The value of PageSize has the format <size><unit-prefix>B (2MB, 1GB),
    /// and must match the <hugepagesize> of the corresponding control file found in
    /// `hugetlb.<hugepagesize>.limit_in_bytes`.
    /// The values of <unit-prefix> are intended to be parsed using base 1024("1KB" = 1024, "1MB" = 1048576, etc).
    var pageSize: String = .init()

    /// limit in bytes of hugepagesize HugeTLB usage.
    var limit: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// SELinuxOption are the labels to be applied to the container.
struct Runtime_V1_SELinuxOption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var user: String = .init()

    var role: String = .init()

    var type: String = .init()

    var level: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Capability contains the container capabilities to add or drop
/// Dropping a capability will drop it from all sets.
/// If a capability is added to only the add_capabilities list then it gets added to permitted,
/// inheritable, effective and bounding sets, i.e. all sets except the ambient set.
/// If a capability is added to only the add_ambient_capabilities list then it gets added to all sets, i.e permitted
/// inheritable, effective, bounding and ambient sets.
/// If a capability is added to add_capabilities and add_ambient_capabilities lists then it gets added to all sets, i.e.
/// permitted, inheritable, effective, bounding and ambient sets.
struct Runtime_V1_Capability {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of capabilities to add.
    var addCapabilities: [String] = []

    /// List of capabilities to drop.
    var dropCapabilities: [String] = []

    /// List of ambient capabilities to add.
    var addAmbientCapabilities: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// LinuxContainerSecurityContext holds linux security configuration that will be applied to a container.
struct Runtime_V1_LinuxContainerSecurityContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Capabilities to add or drop.
    var capabilities: Runtime_V1_Capability {
        get { _storage._capabilities ?? Runtime_V1_Capability() }
        set { _uniqueStorage()._capabilities = newValue }
    }

    /// Returns true if `capabilities` has been explicitly set.
    var hasCapabilities: Bool { _storage._capabilities != nil }
    /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
    mutating func clearCapabilities() { _uniqueStorage()._capabilities = nil }

    /// If set, run container in privileged mode.
    /// Privileged mode is incompatible with the following options. If
    /// privileged is set, the following features MAY have no effect:
    /// 1. capabilities
    /// 2. selinux_options
    /// 4. seccomp
    /// 5. apparmor
    ///
    /// Privileged mode implies the following specific options are applied:
    /// 1. All capabilities are added.
    /// 2. Sensitive paths, such as kernel module paths within sysfs, are not masked.
    /// 3. Any sysfs and procfs mounts are mounted RW.
    /// 4. AppArmor confinement is not applied.
    /// 5. Seccomp restrictions are not applied.
    /// 6. The device cgroup does not restrict access to any devices.
    /// 7. All devices from the host's /dev are available within the container.
    /// 8. SELinux restrictions are not applied (e.g. label=disabled).
    var privileged: Bool {
        get { _storage._privileged }
        set { _uniqueStorage()._privileged = newValue }
    }

    /// Configurations for the container's namespaces.
    /// Only used if the container uses namespace for isolation.
    var namespaceOptions: Runtime_V1_NamespaceOption {
        get { _storage._namespaceOptions ?? Runtime_V1_NamespaceOption() }
        set { _uniqueStorage()._namespaceOptions = newValue }
    }

    /// Returns true if `namespaceOptions` has been explicitly set.
    var hasNamespaceOptions: Bool { _storage._namespaceOptions != nil }
    /// Clears the value of `namespaceOptions`. Subsequent reads from it will return its default value.
    mutating func clearNamespaceOptions() { _uniqueStorage()._namespaceOptions = nil }

    /// SELinux context to be optionally applied.
    var selinuxOptions: Runtime_V1_SELinuxOption {
        get { _storage._selinuxOptions ?? Runtime_V1_SELinuxOption() }
        set { _uniqueStorage()._selinuxOptions = newValue }
    }

    /// Returns true if `selinuxOptions` has been explicitly set.
    var hasSelinuxOptions: Bool { _storage._selinuxOptions != nil }
    /// Clears the value of `selinuxOptions`. Subsequent reads from it will return its default value.
    mutating func clearSelinuxOptions() { _uniqueStorage()._selinuxOptions = nil }

    /// UID to run the container process as. Only one of run_as_user and
    /// run_as_username can be specified at a time.
    var runAsUser: Runtime_V1_Int64Value {
        get { _storage._runAsUser ?? Runtime_V1_Int64Value() }
        set { _uniqueStorage()._runAsUser = newValue }
    }

    /// Returns true if `runAsUser` has been explicitly set.
    var hasRunAsUser: Bool { _storage._runAsUser != nil }
    /// Clears the value of `runAsUser`. Subsequent reads from it will return its default value.
    mutating func clearRunAsUser() { _uniqueStorage()._runAsUser = nil }

    /// GID to run the container process as. run_as_group should only be specified
    /// when run_as_user or run_as_username is specified; otherwise, the runtime
    /// MUST error.
    var runAsGroup: Runtime_V1_Int64Value {
        get { _storage._runAsGroup ?? Runtime_V1_Int64Value() }
        set { _uniqueStorage()._runAsGroup = newValue }
    }

    /// Returns true if `runAsGroup` has been explicitly set.
    var hasRunAsGroup: Bool { _storage._runAsGroup != nil }
    /// Clears the value of `runAsGroup`. Subsequent reads from it will return its default value.
    mutating func clearRunAsGroup() { _uniqueStorage()._runAsGroup = nil }

    /// User name to run the container process as. If specified, the user MUST
    /// exist in the container image (i.e. in the /etc/passwd inside the image),
    /// and be resolved there by the runtime; otherwise, the runtime MUST error.
    var runAsUsername: String {
        get { _storage._runAsUsername }
        set { _uniqueStorage()._runAsUsername = newValue }
    }

    /// If set, the root filesystem of the container is read-only.
    var readonlyRootfs: Bool {
        get { _storage._readonlyRootfs }
        set { _uniqueStorage()._readonlyRootfs = newValue }
    }

    /// List of groups applied to the first process run in each container.
    /// supplemental_groups_policy can control how groups will be calculated.
    var supplementalGroups: [Int64] {
        get { _storage._supplementalGroups }
        set { _uniqueStorage()._supplementalGroups = newValue }
    }

    /// supplemental_groups_policy defines how supplemental groups of the first
    /// container processes are calculated.
    /// Valid values are "Merge" and "Strict".
    /// If not specified, "Merge" is used.
    var supplementalGroupsPolicy: Runtime_V1_SupplementalGroupsPolicy {
        get { _storage._supplementalGroupsPolicy }
        set { _uniqueStorage()._supplementalGroupsPolicy = newValue }
    }

    /// no_new_privs defines if the flag for no_new_privs should be set on the
    /// container.
    var noNewPrivs: Bool {
        get { _storage._noNewPrivs }
        set { _uniqueStorage()._noNewPrivs = newValue }
    }

    /// masked_paths is a slice of paths that should be masked by the container
    /// runtime, this can be passed directly to the OCI spec.
    var maskedPaths: [String] {
        get { _storage._maskedPaths }
        set { _uniqueStorage()._maskedPaths = newValue }
    }

    /// readonly_paths is a slice of paths that should be set as readonly by the
    /// container runtime, this can be passed directly to the OCI spec.
    var readonlyPaths: [String] {
        get { _storage._readonlyPaths }
        set { _uniqueStorage()._readonlyPaths = newValue }
    }

    /// Seccomp profile for the container.
    var seccomp: Runtime_V1_SecurityProfile {
        get { _storage._seccomp ?? Runtime_V1_SecurityProfile() }
        set { _uniqueStorage()._seccomp = newValue }
    }

    /// Returns true if `seccomp` has been explicitly set.
    var hasSeccomp: Bool { _storage._seccomp != nil }
    /// Clears the value of `seccomp`. Subsequent reads from it will return its default value.
    mutating func clearSeccomp() { _uniqueStorage()._seccomp = nil }

    /// AppArmor profile for the container.
    var apparmor: Runtime_V1_SecurityProfile {
        get { _storage._apparmor ?? Runtime_V1_SecurityProfile() }
        set { _uniqueStorage()._apparmor = newValue }
    }

    /// Returns true if `apparmor` has been explicitly set.
    var hasApparmor: Bool { _storage._apparmor != nil }
    /// Clears the value of `apparmor`. Subsequent reads from it will return its default value.
    mutating func clearApparmor() { _uniqueStorage()._apparmor = nil }

    /// AppArmor profile for the container, candidate values are:
    /// * runtime/default: equivalent to not specifying a profile.
    /// * unconfined: no profiles are loaded
    /// * localhost/<profile_name>: profile loaded on the node
    ///    (localhost) by name. The possible profile names are detailed at
    ///    https://gitlab.com/apparmor/apparmor/-/wikis/AppArmor_Core_Policy_Reference
    var apparmorProfile: String {
        get { _storage._apparmorProfile }
        set { _uniqueStorage()._apparmorProfile = newValue }
    }

    /// Seccomp profile for the container, candidate values are:
    /// * runtime/default: the default profile for the container runtime
    /// * unconfined: unconfined profile, ie, no seccomp sandboxing
    /// * localhost/<full-path-to-profile>: the profile installed on the node.
    ///   <full-path-to-profile> is the full path of the profile.
    /// Default: "", which is identical with unconfined.
    var seccompProfilePath: String {
        get { _storage._seccompProfilePath }
        set { _uniqueStorage()._seccompProfilePath = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// LinuxContainerConfig contains platform-specific configuration for
/// Linux-based containers.
struct Runtime_V1_LinuxContainerConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resources specification for the container.
    var resources: Runtime_V1_LinuxContainerResources {
        get { _resources ?? Runtime_V1_LinuxContainerResources() }
        set { _resources = newValue }
    }

    /// Returns true if `resources` has been explicitly set.
    var hasResources: Bool { _resources != nil }
    /// Clears the value of `resources`. Subsequent reads from it will return its default value.
    mutating func clearResources() { _resources = nil }

    /// LinuxContainerSecurityContext configuration for the container.
    var securityContext: Runtime_V1_LinuxContainerSecurityContext {
        get { _securityContext ?? Runtime_V1_LinuxContainerSecurityContext() }
        set { _securityContext = newValue }
    }

    /// Returns true if `securityContext` has been explicitly set.
    var hasSecurityContext: Bool { _securityContext != nil }
    /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
    mutating func clearSecurityContext() { _securityContext = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _resources: Runtime_V1_LinuxContainerResources?
    fileprivate var _securityContext: Runtime_V1_LinuxContainerSecurityContext?
}

struct Runtime_V1_LinuxContainerUser {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// uid is the primary uid initially attached to the first process in the container
    var uid: Int64 = 0

    /// gid is the primary gid initially attached to the first process in the container
    var gid: Int64 = 0

    /// supplemental_groups are the supplemental groups initially attached to the first process in the container
    var supplementalGroups: [Int64] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// WindowsNamespaceOption provides options for Windows namespaces.
struct Runtime_V1_WindowsNamespaceOption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Network namespace for this container/sandbox.
    /// Namespaces currently set by the kubelet: POD, NODE
    var network: Runtime_V1_NamespaceMode = .pod

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// WindowsSandboxSecurityContext holds platform-specific configurations that will be
/// applied to a sandbox.
/// These settings will only apply to the sandbox container.
struct Runtime_V1_WindowsSandboxSecurityContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User name to run the container process as. If specified, the user MUST
    /// exist in the container image and be resolved there by the runtime;
    /// otherwise, the runtime MUST return error.
    var runAsUsername: String = .init()

    /// The contents of the GMSA credential spec to use to run this container.
    var credentialSpec: String = .init()

    /// Indicates whether the container requested to run as a HostProcess container.
    var hostProcess: Bool = false

    /// Configuration for the sandbox's namespaces
    var namespaceOptions: Runtime_V1_WindowsNamespaceOption {
        get { _namespaceOptions ?? Runtime_V1_WindowsNamespaceOption() }
        set { _namespaceOptions = newValue }
    }

    /// Returns true if `namespaceOptions` has been explicitly set.
    var hasNamespaceOptions: Bool { _namespaceOptions != nil }
    /// Clears the value of `namespaceOptions`. Subsequent reads from it will return its default value.
    mutating func clearNamespaceOptions() { _namespaceOptions = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _namespaceOptions: Runtime_V1_WindowsNamespaceOption?
}

/// WindowsPodSandboxConfig holds platform-specific configurations for Windows
/// host platforms and Windows-based containers.
struct Runtime_V1_WindowsPodSandboxConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// WindowsSandboxSecurityContext holds sandbox security attributes.
    var securityContext: Runtime_V1_WindowsSandboxSecurityContext {
        get { _securityContext ?? Runtime_V1_WindowsSandboxSecurityContext() }
        set { _securityContext = newValue }
    }

    /// Returns true if `securityContext` has been explicitly set.
    var hasSecurityContext: Bool { _securityContext != nil }
    /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
    mutating func clearSecurityContext() { _securityContext = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _securityContext: Runtime_V1_WindowsSandboxSecurityContext?
}

/// WindowsContainerSecurityContext holds windows security configuration that will be applied to a container.
struct Runtime_V1_WindowsContainerSecurityContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User name to run the container process as. If specified, the user MUST
    /// exist in the container image and be resolved there by the runtime;
    /// otherwise, the runtime MUST return error.
    var runAsUsername: String = .init()

    /// The contents of the GMSA credential spec to use to run this container.
    var credentialSpec: String = .init()

    /// Indicates whether a container is to be run as a HostProcess container.
    var hostProcess: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// WindowsContainerConfig contains platform-specific configuration for
/// Windows-based containers.
struct Runtime_V1_WindowsContainerConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resources specification for the container.
    var resources: Runtime_V1_WindowsContainerResources {
        get { _resources ?? Runtime_V1_WindowsContainerResources() }
        set { _resources = newValue }
    }

    /// Returns true if `resources` has been explicitly set.
    var hasResources: Bool { _resources != nil }
    /// Clears the value of `resources`. Subsequent reads from it will return its default value.
    mutating func clearResources() { _resources = nil }

    /// WindowsContainerSecurityContext configuration for the container.
    var securityContext: Runtime_V1_WindowsContainerSecurityContext {
        get { _securityContext ?? Runtime_V1_WindowsContainerSecurityContext() }
        set { _securityContext = newValue }
    }

    /// Returns true if `securityContext` has been explicitly set.
    var hasSecurityContext: Bool { _securityContext != nil }
    /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
    mutating func clearSecurityContext() { _securityContext = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _resources: Runtime_V1_WindowsContainerResources?
    fileprivate var _securityContext: Runtime_V1_WindowsContainerSecurityContext?
}

/// WindowsContainerResources specifies Windows specific configuration for
/// resources.
struct Runtime_V1_WindowsContainerResources {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// CPU shares (relative weight vs. other containers). Default: 0 (not specified).
    var cpuShares: Int64 = 0

    /// Number of CPUs available to the container. Default: 0 (not specified).
    var cpuCount: Int64 = 0

    /// Specifies the portion of processor cycles that this container can use as a percentage times 100.
    var cpuMaximum: Int64 = 0

    /// Memory limit in bytes. Default: 0 (not specified).
    var memoryLimitInBytes: Int64 = 0

    /// Specifies the size of the rootfs / scratch space in bytes to be configured for this container. Default: 0 (not
    /// specified).
    var rootfsSizeInBytes: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ContainerMetadata holds all necessary information for building the container
/// name. The container runtime is encouraged to expose the metadata in its user
/// interface for better user experience. E.g., runtime can construct a unique
/// container name based on the metadata. Note that (name, attempt) is unique
/// within a sandbox for the entire lifetime of the sandbox.
struct Runtime_V1_ContainerMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the container. Same as the container name in the PodSpec.
    var name: String = .init()

    /// Attempt number of creating the container. Default: 0.
    var attempt: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Device specifies a host device to mount into a container.
struct Runtime_V1_Device {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Path of the device within the container.
    var containerPath: String = .init()

    /// Path of the device on the host.
    var hostPath: String = .init()

    /// Cgroups permissions of the device, candidates are one or more of
    /// * r - allows container to read from the specified device.
    /// * w - allows container to write to the specified device.
    /// * m - allows container to create device files that do not yet exist.
    var permissions: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// CDIDevice specifies a CDI device information.
struct Runtime_V1_CDIDevice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Fully qualified CDI device name
    /// for example: vendor.com/gpu=gpudevice1
    /// see more details in the CDI specification:
    /// https://github.com/container-orchestrated-devices/container-device-interface/blob/main/SPEC.md
    var name: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ContainerConfig holds all the required and optional fields for creating a
/// container.
struct Runtime_V1_ContainerConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Metadata of the container. This information will uniquely identify the
    /// container, and the runtime should leverage this to ensure correct
    /// operation. The runtime may also use this information to improve UX, such
    /// as by constructing a readable name.
    var metadata: Runtime_V1_ContainerMetadata {
        get { _storage._metadata ?? Runtime_V1_ContainerMetadata() }
        set { _uniqueStorage()._metadata = newValue }
    }

    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool { _storage._metadata != nil }
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() { _uniqueStorage()._metadata = nil }

    /// Image to use.
    var image: Runtime_V1_ImageSpec {
        get { _storage._image ?? Runtime_V1_ImageSpec() }
        set { _uniqueStorage()._image = newValue }
    }

    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool { _storage._image != nil }
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() { _uniqueStorage()._image = nil }

    /// Command to execute (i.e., entrypoint for docker)
    var command: [String] {
        get { _storage._command }
        set { _uniqueStorage()._command = newValue }
    }

    /// Args for the Command (i.e., command for docker)
    var args: [String] {
        get { _storage._args }
        set { _uniqueStorage()._args = newValue }
    }

    /// Current working directory of the command.
    var workingDir: String {
        get { _storage._workingDir }
        set { _uniqueStorage()._workingDir = newValue }
    }

    /// List of environment variable to set in the container.
    var envs: [Runtime_V1_KeyValue] {
        get { _storage._envs }
        set { _uniqueStorage()._envs = newValue }
    }

    /// Mounts for the container.
    var mounts: [Runtime_V1_Mount] {
        get { _storage._mounts }
        set { _uniqueStorage()._mounts = newValue }
    }

    /// Devices for the container.
    var devices: [Runtime_V1_Device] {
        get { _storage._devices }
        set { _uniqueStorage()._devices = newValue }
    }

    /// Key-value pairs that may be used to scope and select individual resources.
    /// Label keys are of the form:
    ///     label-key ::= prefixed-name | name
    ///     prefixed-name ::= prefix '/' name
    ///     prefix ::= DNS_SUBDOMAIN
    ///     name ::= DNS_LABEL
    var labels: [String: String] {
        get { _storage._labels }
        set { _uniqueStorage()._labels = newValue }
    }

    /// Unstructured key-value map that may be used by the kubelet to store and
    /// retrieve arbitrary metadata.
    ///
    /// Annotations MUST NOT be altered by the runtime; the annotations stored
    /// here MUST be returned in the ContainerStatus associated with the container
    /// this ContainerConfig creates.
    ///
    /// In general, in order to preserve a well-defined interface between the
    /// kubelet and the container runtime, annotations SHOULD NOT influence
    /// runtime behaviour.
    var annotations: [String: String] {
        get { _storage._annotations }
        set { _uniqueStorage()._annotations = newValue }
    }

    /// Path relative to PodSandboxConfig.LogDirectory for container to store
    /// the log (STDOUT and STDERR) on the host.
    /// E.g.,
    ///     PodSandboxConfig.LogDirectory = `/var/log/pods/<NAMESPACE>_<NAME>_<UID>/`
    ///     ContainerConfig.LogPath = `containerName/Instance#.log`
    var logPath: String {
        get { _storage._logPath }
        set { _uniqueStorage()._logPath = newValue }
    }

    /// Variables for interactive containers, these have very specialized
    /// use-cases (e.g. debugging).
    var stdin: Bool {
        get { _storage._stdin }
        set { _uniqueStorage()._stdin = newValue }
    }

    var stdinOnce: Bool {
        get { _storage._stdinOnce }
        set { _uniqueStorage()._stdinOnce = newValue }
    }

    var tty: Bool {
        get { _storage._tty }
        set { _uniqueStorage()._tty = newValue }
    }

    /// Configuration specific to Linux containers.
    var linux: Runtime_V1_LinuxContainerConfig {
        get { _storage._linux ?? Runtime_V1_LinuxContainerConfig() }
        set { _uniqueStorage()._linux = newValue }
    }

    /// Returns true if `linux` has been explicitly set.
    var hasLinux: Bool { _storage._linux != nil }
    /// Clears the value of `linux`. Subsequent reads from it will return its default value.
    mutating func clearLinux() { _uniqueStorage()._linux = nil }

    /// Configuration specific to Windows containers.
    var windows: Runtime_V1_WindowsContainerConfig {
        get { _storage._windows ?? Runtime_V1_WindowsContainerConfig() }
        set { _uniqueStorage()._windows = newValue }
    }

    /// Returns true if `windows` has been explicitly set.
    var hasWindows: Bool { _storage._windows != nil }
    /// Clears the value of `windows`. Subsequent reads from it will return its default value.
    mutating func clearWindows() { _uniqueStorage()._windows = nil }

    /// CDI devices for the container.
    var cdiDevices: [Runtime_V1_CDIDevice] {
        get { _storage._cdiDevices }
        set { _uniqueStorage()._cdiDevices = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_CreateContainerRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the PodSandbox in which the container should be created.
    var podSandboxID: String = .init()

    /// Config of the container.
    var config: Runtime_V1_ContainerConfig {
        get { _config ?? Runtime_V1_ContainerConfig() }
        set { _config = newValue }
    }

    /// Returns true if `config` has been explicitly set.
    var hasConfig: Bool { _config != nil }
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    mutating func clearConfig() { _config = nil }

    /// Config of the PodSandbox. This is the same config that was passed
    /// to RunPodSandboxRequest to create the PodSandbox. It is passed again
    /// here just for easy reference. The PodSandboxConfig is immutable and
    /// remains the same throughout the lifetime of the pod.
    var sandboxConfig: Runtime_V1_PodSandboxConfig {
        get { _sandboxConfig ?? Runtime_V1_PodSandboxConfig() }
        set { _sandboxConfig = newValue }
    }

    /// Returns true if `sandboxConfig` has been explicitly set.
    var hasSandboxConfig: Bool { _sandboxConfig != nil }
    /// Clears the value of `sandboxConfig`. Subsequent reads from it will return its default value.
    mutating func clearSandboxConfig() { _sandboxConfig = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _config: Runtime_V1_ContainerConfig?
    fileprivate var _sandboxConfig: Runtime_V1_PodSandboxConfig?
}

struct Runtime_V1_CreateContainerResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the created container.
    var containerID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_StartContainerRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container to start.
    var containerID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_StartContainerResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_StopContainerRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container to stop.
    var containerID: String = .init()

    /// Timeout in seconds to wait for the container to stop before forcibly
    /// terminating it. Default: 0 (forcibly terminate the container immediately)
    var timeout: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_StopContainerResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RemoveContainerRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container to remove.
    var containerID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RemoveContainerResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ContainerStateValue is the wrapper of ContainerState.
struct Runtime_V1_ContainerStateValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// State of the container.
    var state: Runtime_V1_ContainerState = .containerCreated

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ContainerFilter is used to filter containers.
/// All those fields are combined with 'AND'
struct Runtime_V1_ContainerFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container.
    var id: String = .init()

    /// State of the container.
    var state: Runtime_V1_ContainerStateValue {
        get { _state ?? Runtime_V1_ContainerStateValue() }
        set { _state = newValue }
    }

    /// Returns true if `state` has been explicitly set.
    var hasState: Bool { _state != nil }
    /// Clears the value of `state`. Subsequent reads from it will return its default value.
    mutating func clearState() { _state = nil }

    /// ID of the PodSandbox.
    var podSandboxID: String = .init()

    /// LabelSelector to select matches.
    /// Only api.MatchLabels is supported for now and the requirements
    /// are ANDed. MatchExpressions is not supported yet.
    var labelSelector: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _state: Runtime_V1_ContainerStateValue?
}

struct Runtime_V1_ListContainersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var filter: Runtime_V1_ContainerFilter {
        get { _filter ?? Runtime_V1_ContainerFilter() }
        set { _filter = newValue }
    }

    /// Returns true if `filter` has been explicitly set.
    var hasFilter: Bool { _filter != nil }
    /// Clears the value of `filter`. Subsequent reads from it will return its default value.
    mutating func clearFilter() { _filter = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _filter: Runtime_V1_ContainerFilter?
}

/// Container provides the runtime information for a container, such as ID, hash,
/// state of the container.
struct Runtime_V1_Container {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container, used by the container runtime to identify
    /// a container.
    var id: String = .init()

    /// ID of the sandbox to which this container belongs.
    var podSandboxID: String = .init()

    /// Metadata of the container.
    var metadata: Runtime_V1_ContainerMetadata {
        get { _metadata ?? Runtime_V1_ContainerMetadata() }
        set { _metadata = newValue }
    }

    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool { _metadata != nil }
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() { _metadata = nil }

    /// Spec of the image.
    var image: Runtime_V1_ImageSpec {
        get { _image ?? Runtime_V1_ImageSpec() }
        set { _image = newValue }
    }

    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool { _image != nil }
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() { _image = nil }

    /// Digested reference to the image in use.
    var imageRef: String = .init()

    /// State of the container.
    var state: Runtime_V1_ContainerState = .containerCreated

    /// Creation time of the container in nanoseconds.
    var createdAt: Int64 = 0

    /// Key-value pairs that may be used to scope and select individual resources.
    var labels: [String: String] = [:]

    /// Unstructured key-value map holding arbitrary metadata.
    /// Annotations MUST NOT be altered by the runtime; the value of this field
    /// MUST be identical to that of the corresponding ContainerConfig used to
    /// instantiate this Container.
    var annotations: [String: String] = [:]

    /// Reference to the unique identifier of the image, on the node, as
    /// returned in the image service apis.
    ///
    /// Note: The image_ref above has been historically used by container
    /// runtimes to reference images by digest. The image_ref has been also used
    /// in the kubelet image garbage collection, which does not work with
    /// digests at all. To separate and avoid possible misusage, we now
    /// introduce the image_id field, which should always refer to a unique
    /// image identifier on the node.
    var imageID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _metadata: Runtime_V1_ContainerMetadata?
    fileprivate var _image: Runtime_V1_ImageSpec?
}

struct Runtime_V1_ListContainersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of containers.
    var containers: [Runtime_V1_Container] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ContainerStatusRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container for which to retrieve status.
    var containerID: String = .init()

    /// Verbose indicates whether to return extra information about the container.
    var verbose: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ContainerStatus represents the status of a container.
struct Runtime_V1_ContainerStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container.
    var id: String {
        get { _storage._id }
        set { _uniqueStorage()._id = newValue }
    }

    /// Metadata of the container.
    var metadata: Runtime_V1_ContainerMetadata {
        get { _storage._metadata ?? Runtime_V1_ContainerMetadata() }
        set { _uniqueStorage()._metadata = newValue }
    }

    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool { _storage._metadata != nil }
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() { _uniqueStorage()._metadata = nil }

    /// Status of the container.
    var state: Runtime_V1_ContainerState {
        get { _storage._state }
        set { _uniqueStorage()._state = newValue }
    }

    /// Creation time of the container in nanoseconds.
    var createdAt: Int64 {
        get { _storage._createdAt }
        set { _uniqueStorage()._createdAt = newValue }
    }

    /// Start time of the container in nanoseconds. Default: 0 (not specified).
    var startedAt: Int64 {
        get { _storage._startedAt }
        set { _uniqueStorage()._startedAt = newValue }
    }

    /// Finish time of the container in nanoseconds. Default: 0 (not specified).
    var finishedAt: Int64 {
        get { _storage._finishedAt }
        set { _uniqueStorage()._finishedAt = newValue }
    }

    /// Exit code of the container. Only required when finished_at != 0. Default: 0.
    var exitCode: Int32 {
        get { _storage._exitCode }
        set { _uniqueStorage()._exitCode = newValue }
    }

    /// Spec of the image.
    var image: Runtime_V1_ImageSpec {
        get { _storage._image ?? Runtime_V1_ImageSpec() }
        set { _uniqueStorage()._image = newValue }
    }

    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool { _storage._image != nil }
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() { _uniqueStorage()._image = nil }

    /// Digested reference to the image in use.
    var imageRef: String {
        get { _storage._imageRef }
        set { _uniqueStorage()._imageRef = newValue }
    }

    /// Brief CamelCase string explaining why container is in its current state.
    /// Must be set to "OOMKilled" for containers terminated by cgroup-based Out-of-Memory killer.
    var reason: String {
        get { _storage._reason }
        set { _uniqueStorage()._reason = newValue }
    }

    /// Human-readable message indicating details about why container is in its
    /// current state.
    var message: String {
        get { _storage._message }
        set { _uniqueStorage()._message = newValue }
    }

    /// Key-value pairs that may be used to scope and select individual resources.
    var labels: [String: String] {
        get { _storage._labels }
        set { _uniqueStorage()._labels = newValue }
    }

    /// Unstructured key-value map holding arbitrary metadata.
    /// Annotations MUST NOT be altered by the runtime; the value of this field
    /// MUST be identical to that of the corresponding ContainerConfig used to
    /// instantiate the Container this status represents.
    var annotations: [String: String] {
        get { _storage._annotations }
        set { _uniqueStorage()._annotations = newValue }
    }

    /// Mounts for the container.
    var mounts: [Runtime_V1_Mount] {
        get { _storage._mounts }
        set { _uniqueStorage()._mounts = newValue }
    }

    /// Log path of container.
    var logPath: String {
        get { _storage._logPath }
        set { _uniqueStorage()._logPath = newValue }
    }

    /// Resource limits configuration of the container.
    var resources: Runtime_V1_ContainerResources {
        get { _storage._resources ?? Runtime_V1_ContainerResources() }
        set { _uniqueStorage()._resources = newValue }
    }

    /// Returns true if `resources` has been explicitly set.
    var hasResources: Bool { _storage._resources != nil }
    /// Clears the value of `resources`. Subsequent reads from it will return its default value.
    mutating func clearResources() { _uniqueStorage()._resources = nil }

    /// Reference to the unique identifier of the image, on the node, as
    /// returned in the image service apis.
    ///
    /// Note: The image_ref above has been historically used by container
    /// runtimes to reference images by digest. To separate and avoid possible
    /// misusage, we now introduce the image_id field, which should always refer
    /// to a unique image identifier on the node.
    var imageID: String {
        get { _storage._imageID }
        set { _uniqueStorage()._imageID = newValue }
    }

    /// User identities initially attached to the container
    var user: Runtime_V1_ContainerUser {
        get { _storage._user ?? Runtime_V1_ContainerUser() }
        set { _uniqueStorage()._user = newValue }
    }

    /// Returns true if `user` has been explicitly set.
    var hasUser: Bool { _storage._user != nil }
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    mutating func clearUser() { _uniqueStorage()._user = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_ContainerStatusResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Status of the container.
    var status: Runtime_V1_ContainerStatus {
        get { _status ?? Runtime_V1_ContainerStatus() }
        set { _status = newValue }
    }

    /// Returns true if `status` has been explicitly set.
    var hasStatus: Bool { _status != nil }
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    mutating func clearStatus() { _status = nil }

    /// Info is extra information of the Container. The key could be arbitrary string, and
    /// value should be in json format. The information could include anything useful for
    /// debug, e.g. pid for linux container based container runtime.
    /// It should only be returned non-empty when Verbose is true.
    var info: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _status: Runtime_V1_ContainerStatus?
}

/// ContainerResources holds resource limits configuration for a container.
struct Runtime_V1_ContainerResources {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource limits configuration specific to Linux container.
    var linux: Runtime_V1_LinuxContainerResources {
        get { _linux ?? Runtime_V1_LinuxContainerResources() }
        set { _linux = newValue }
    }

    /// Returns true if `linux` has been explicitly set.
    var hasLinux: Bool { _linux != nil }
    /// Clears the value of `linux`. Subsequent reads from it will return its default value.
    mutating func clearLinux() { _linux = nil }

    /// Resource limits configuration specific to Windows container.
    var windows: Runtime_V1_WindowsContainerResources {
        get { _windows ?? Runtime_V1_WindowsContainerResources() }
        set { _windows = newValue }
    }

    /// Returns true if `windows` has been explicitly set.
    var hasWindows: Bool { _windows != nil }
    /// Clears the value of `windows`. Subsequent reads from it will return its default value.
    mutating func clearWindows() { _windows = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _linux: Runtime_V1_LinuxContainerResources?
    fileprivate var _windows: Runtime_V1_WindowsContainerResources?
}

struct Runtime_V1_ContainerUser {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User identities initially attached to first process in the Linux container.
    /// Note that the actual running identity can be changed if the process has enough privilege to do so.
    var linux: Runtime_V1_LinuxContainerUser {
        get { _linux ?? Runtime_V1_LinuxContainerUser() }
        set { _linux = newValue }
    }

    /// Returns true if `linux` has been explicitly set.
    var hasLinux: Bool { _linux != nil }
    /// Clears the value of `linux`. Subsequent reads from it will return its default value.
    mutating func clearLinux() { _linux = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _linux: Runtime_V1_LinuxContainerUser?
}

struct Runtime_V1_UpdateContainerResourcesRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container to update.
    var containerID: String {
        get { _storage._containerID }
        set { _uniqueStorage()._containerID = newValue }
    }

    /// Resource configuration specific to Linux containers.
    var linux: Runtime_V1_LinuxContainerResources {
        get { _storage._linux ?? Runtime_V1_LinuxContainerResources() }
        set { _uniqueStorage()._linux = newValue }
    }

    /// Returns true if `linux` has been explicitly set.
    var hasLinux: Bool { _storage._linux != nil }
    /// Clears the value of `linux`. Subsequent reads from it will return its default value.
    mutating func clearLinux() { _uniqueStorage()._linux = nil }

    /// Resource configuration specific to Windows containers.
    var windows: Runtime_V1_WindowsContainerResources {
        get { _storage._windows ?? Runtime_V1_WindowsContainerResources() }
        set { _uniqueStorage()._windows = newValue }
    }

    /// Returns true if `windows` has been explicitly set.
    var hasWindows: Bool { _storage._windows != nil }
    /// Clears the value of `windows`. Subsequent reads from it will return its default value.
    mutating func clearWindows() { _uniqueStorage()._windows = nil }

    /// Unstructured key-value map holding arbitrary additional information for
    /// container resources updating. This can be used for specifying experimental
    /// resources to update or other options to use when updating the container.
    var annotations: [String: String] {
        get { _storage._annotations }
        set { _uniqueStorage()._annotations = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_UpdateContainerResourcesResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ExecSyncRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container.
    var containerID: String = .init()

    /// Command to execute.
    var cmd: [String] = []

    /// Timeout in seconds to stop the command. Default: 0 (run forever).
    var timeout: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ExecSyncResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Captured command stdout output.
    /// The runtime should cap the output of this response to 16MB.
    /// If the stdout of the command produces more than 16MB, the remaining output
    /// should be discarded, and the command should proceed with no error.
    /// See CVE-2022-1708 and CVE-2022-31030 for more information.
    var stdout: Data = .init()

    /// Captured command stderr output.
    /// The runtime should cap the output of this response to 16MB.
    /// If the stderr of the command produces more than 16MB, the remaining output
    /// should be discarded, and the command should proceed with no error.
    /// See CVE-2022-1708 and CVE-2022-31030 for more information.
    var stderr: Data = .init()

    /// Exit code the command finished with. Default: 0 (success).
    var exitCode: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ExecRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container in which to execute the command.
    var containerID: String = .init()

    /// Command to execute.
    var cmd: [String] = []

    /// Whether to exec the command in a TTY.
    var tty: Bool = false

    /// Whether to stream stdin.
    /// One of `stdin`, `stdout`, and `stderr` MUST be true.
    var stdin: Bool = false

    /// Whether to stream stdout.
    /// One of `stdin`, `stdout`, and `stderr` MUST be true.
    var stdout: Bool = false

    /// Whether to stream stderr.
    /// One of `stdin`, `stdout`, and `stderr` MUST be true.
    /// If `tty` is true, `stderr` MUST be false. Multiplexing is not supported
    /// in this case. The output of stdout and stderr will be combined to a
    /// single stream.
    var stderr: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ExecResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Fully qualified URL of the exec streaming server.
    var url: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_AttachRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container to which to attach.
    var containerID: String = .init()

    /// Whether to stream stdin.
    /// One of `stdin`, `stdout`, and `stderr` MUST be true.
    var stdin: Bool = false

    /// Whether the process being attached is running in a TTY.
    /// This must match the TTY setting in the ContainerConfig.
    var tty: Bool = false

    /// Whether to stream stdout.
    /// One of `stdin`, `stdout`, and `stderr` MUST be true.
    var stdout: Bool = false

    /// Whether to stream stderr.
    /// One of `stdin`, `stdout`, and `stderr` MUST be true.
    /// If `tty` is true, `stderr` MUST be false. Multiplexing is not supported
    /// in this case. The output of stdout and stderr will be combined to a
    /// single stream.
    var stderr: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_AttachResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Fully qualified URL of the attach streaming server.
    var url: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_PortForwardRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container to which to forward the port.
    var podSandboxID: String = .init()

    /// Port to forward.
    var port: [Int32] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_PortForwardResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Fully qualified URL of the port-forward streaming server.
    var url: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ImageFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Spec of the image.
    var image: Runtime_V1_ImageSpec {
        get { _image ?? Runtime_V1_ImageSpec() }
        set { _image = newValue }
    }

    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool { _image != nil }
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() { _image = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _image: Runtime_V1_ImageSpec?
}

struct Runtime_V1_ListImagesRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Filter to list images.
    var filter: Runtime_V1_ImageFilter {
        get { _filter ?? Runtime_V1_ImageFilter() }
        set { _filter = newValue }
    }

    /// Returns true if `filter` has been explicitly set.
    var hasFilter: Bool { _filter != nil }
    /// Clears the value of `filter`. Subsequent reads from it will return its default value.
    mutating func clearFilter() { _filter = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _filter: Runtime_V1_ImageFilter?
}

/// Basic information about a container image.
struct Runtime_V1_Image {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the image.
    var id: String = .init()

    /// Other names by which this image is known.
    var repoTags: [String] = []

    /// Digests by which this image is known.
    var repoDigests: [String] = []

    /// Size of the image in bytes. Must be > 0.
    var size: UInt64 = 0

    /// UID that will run the command(s). This is used as a default if no user is
    /// specified when creating the container. UID and the following user name
    /// are mutually exclusive.
    var uid: Runtime_V1_Int64Value {
        get { _uid ?? Runtime_V1_Int64Value() }
        set { _uid = newValue }
    }

    /// Returns true if `uid` has been explicitly set.
    var hasUid: Bool { _uid != nil }
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    mutating func clearUid() { _uid = nil }

    /// User name that will run the command(s). This is used if UID is not set
    /// and no user is specified when creating container.
    var username: String = .init()

    /// ImageSpec for image which includes annotations
    var spec: Runtime_V1_ImageSpec {
        get { _spec ?? Runtime_V1_ImageSpec() }
        set { _spec = newValue }
    }

    /// Returns true if `spec` has been explicitly set.
    var hasSpec: Bool { _spec != nil }
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    mutating func clearSpec() { _spec = nil }

    /// Recommendation on whether this image should be exempt from garbage collection.
    /// It must only be treated as a recommendation -- the client can still request that the image be deleted,
    /// and the runtime must oblige.
    var pinned: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uid: Runtime_V1_Int64Value?
    fileprivate var _spec: Runtime_V1_ImageSpec?
}

struct Runtime_V1_ListImagesResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of images.
    var images: [Runtime_V1_Image] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ImageStatusRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Spec of the image.
    var image: Runtime_V1_ImageSpec {
        get { _image ?? Runtime_V1_ImageSpec() }
        set { _image = newValue }
    }

    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool { _image != nil }
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() { _image = nil }

    /// Verbose indicates whether to return extra information about the image.
    var verbose: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _image: Runtime_V1_ImageSpec?
}

struct Runtime_V1_ImageStatusResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Status of the image.
    var image: Runtime_V1_Image {
        get { _image ?? Runtime_V1_Image() }
        set { _image = newValue }
    }

    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool { _image != nil }
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() { _image = nil }

    /// Info is extra information of the Image. The key could be arbitrary string, and
    /// value should be in json format. The information could include anything useful
    /// for debug, e.g. image config for oci image based container runtime.
    /// It should only be returned non-empty when Verbose is true.
    var info: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _image: Runtime_V1_Image?
}

/// AuthConfig contains authorization information for connecting to a registry.
struct Runtime_V1_AuthConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var username: String = .init()

    var password: String = .init()

    var auth: String = .init()

    var serverAddress: String = .init()

    /// IdentityToken is used to authenticate the user and get
    /// an access token for the registry.
    var identityToken: String = .init()

    /// RegistryToken is a bearer token to be sent to a registry
    var registryToken: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_PullImageRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Spec of the image.
    var image: Runtime_V1_ImageSpec {
        get { _image ?? Runtime_V1_ImageSpec() }
        set { _image = newValue }
    }

    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool { _image != nil }
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() { _image = nil }

    /// Authentication configuration for pulling the image.
    var auth: Runtime_V1_AuthConfig {
        get { _auth ?? Runtime_V1_AuthConfig() }
        set { _auth = newValue }
    }

    /// Returns true if `auth` has been explicitly set.
    var hasAuth: Bool { _auth != nil }
    /// Clears the value of `auth`. Subsequent reads from it will return its default value.
    mutating func clearAuth() { _auth = nil }

    /// Config of the PodSandbox, which is used to pull image in PodSandbox context.
    var sandboxConfig: Runtime_V1_PodSandboxConfig {
        get { _sandboxConfig ?? Runtime_V1_PodSandboxConfig() }
        set { _sandboxConfig = newValue }
    }

    /// Returns true if `sandboxConfig` has been explicitly set.
    var hasSandboxConfig: Bool { _sandboxConfig != nil }
    /// Clears the value of `sandboxConfig`. Subsequent reads from it will return its default value.
    mutating func clearSandboxConfig() { _sandboxConfig = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _image: Runtime_V1_ImageSpec?
    private var _auth: Runtime_V1_AuthConfig?
    fileprivate var _sandboxConfig: Runtime_V1_PodSandboxConfig?
}

struct Runtime_V1_PullImageResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Reference to the image in use. For most runtimes, this should be an
    /// image ID or digest.
    var imageRef: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RemoveImageRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Spec of the image to remove.
    var image: Runtime_V1_ImageSpec {
        get { _image ?? Runtime_V1_ImageSpec() }
        set { _image = newValue }
    }

    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool { _image != nil }
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() { _image = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _image: Runtime_V1_ImageSpec?
}

struct Runtime_V1_RemoveImageResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_NetworkConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// CIDR to use for pod IP addresses. If the CIDR is empty, runtimes
    /// should omit it.
    var podCidr: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RuntimeConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var networkConfig: Runtime_V1_NetworkConfig {
        get { _networkConfig ?? Runtime_V1_NetworkConfig() }
        set { _networkConfig = newValue }
    }

    /// Returns true if `networkConfig` has been explicitly set.
    var hasNetworkConfig: Bool { _networkConfig != nil }
    /// Clears the value of `networkConfig`. Subsequent reads from it will return its default value.
    mutating func clearNetworkConfig() { _networkConfig = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _networkConfig: Runtime_V1_NetworkConfig?
}

struct Runtime_V1_UpdateRuntimeConfigRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var runtimeConfig: Runtime_V1_RuntimeConfig {
        get { _runtimeConfig ?? Runtime_V1_RuntimeConfig() }
        set { _runtimeConfig = newValue }
    }

    /// Returns true if `runtimeConfig` has been explicitly set.
    var hasRuntimeConfig: Bool { _runtimeConfig != nil }
    /// Clears the value of `runtimeConfig`. Subsequent reads from it will return its default value.
    mutating func clearRuntimeConfig() { _runtimeConfig = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _runtimeConfig: Runtime_V1_RuntimeConfig?
}

struct Runtime_V1_UpdateRuntimeConfigResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// RuntimeCondition contains condition information for the runtime.
/// There are 2 kinds of runtime conditions:
/// 1. Required conditions: Conditions are required for kubelet to work
/// properly. If any required condition is unmet, the node will be not ready.
/// The required conditions include:
///   * RuntimeReady: RuntimeReady means the runtime is up and ready to accept
///   basic containers e.g. container only needs host network.
///   * NetworkReady: NetworkReady means the runtime network is up and ready to
///   accept containers which require container network.
/// 2. Optional conditions: Conditions are informative to the user, but kubelet
/// will not rely on. Since condition type is an arbitrary string, all conditions
/// not required are optional. These conditions will be exposed to users to help
/// them understand the status of the system.
struct Runtime_V1_RuntimeCondition {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type of runtime condition.
    var type: String = .init()

    /// Status of the condition, one of true/false. Default: false.
    var status: Bool = false

    /// Brief CamelCase string containing reason for the condition's last transition.
    var reason: String = .init()

    /// Human-readable message indicating details about last transition.
    var message: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// RuntimeStatus is information about the current status of the runtime.
struct Runtime_V1_RuntimeStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of current observed runtime conditions.
    var conditions: [Runtime_V1_RuntimeCondition] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_StatusRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Verbose indicates whether to return extra information about the runtime.
    var verbose: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RuntimeHandlerFeatures {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// recursive_read_only_mounts is set to true if the runtime handler supports
    /// recursive read-only mounts.
    /// For runc-compatible runtimes, availability of this feature can be detected by checking whether
    /// the Linux kernel version is >= 5.12, and,  `runc features | jq .mountOptions` contains "rro".
    var recursiveReadOnlyMounts: Bool = false

    /// user_namespaces is set to true if the runtime handler supports user namespaces as implemented
    /// in Kubernetes. This means support for both, user namespaces and idmap mounts.
    var userNamespaces: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RuntimeHandler {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name must be unique in StatusResponse.
    /// An empty string denotes the default handler.
    var name: String = .init()

    /// Supported features.
    var features: Runtime_V1_RuntimeHandlerFeatures {
        get { _features ?? Runtime_V1_RuntimeHandlerFeatures() }
        set { _features = newValue }
    }

    /// Returns true if `features` has been explicitly set.
    var hasFeatures: Bool { _features != nil }
    /// Clears the value of `features`. Subsequent reads from it will return its default value.
    mutating func clearFeatures() { _features = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _features: Runtime_V1_RuntimeHandlerFeatures?
}

struct Runtime_V1_StatusResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Status of the Runtime.
    var status: Runtime_V1_RuntimeStatus {
        get { _status ?? Runtime_V1_RuntimeStatus() }
        set { _status = newValue }
    }

    /// Returns true if `status` has been explicitly set.
    var hasStatus: Bool { _status != nil }
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    mutating func clearStatus() { _status = nil }

    /// Info is extra information of the Runtime. The key could be arbitrary string, and
    /// value should be in json format. The information could include anything useful for
    /// debug, e.g. plugins used by the container runtime.
    /// It should only be returned non-empty when Verbose is true.
    var info: [String: String] = [:]

    /// Runtime handlers.
    var runtimeHandlers: [Runtime_V1_RuntimeHandler] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _status: Runtime_V1_RuntimeStatus?
}

struct Runtime_V1_ImageFsInfoRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// UInt64Value is the wrapper of uint64.
struct Runtime_V1_UInt64Value {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The value.
    var value: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// FilesystemIdentifier uniquely identify the filesystem.
struct Runtime_V1_FilesystemIdentifier {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Mountpoint of a filesystem.
    var mountpoint: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// FilesystemUsage provides the filesystem usage information.
struct Runtime_V1_FilesystemUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// The unique identifier of the filesystem.
    var fsID: Runtime_V1_FilesystemIdentifier {
        get { _fsID ?? Runtime_V1_FilesystemIdentifier() }
        set { _fsID = newValue }
    }

    /// Returns true if `fsID` has been explicitly set.
    var hasFsID: Bool { _fsID != nil }
    /// Clears the value of `fsID`. Subsequent reads from it will return its default value.
    mutating func clearFsID() { _fsID = nil }

    /// UsedBytes represents the bytes used for images on the filesystem.
    /// This may differ from the total bytes used on the filesystem and may not
    /// equal CapacityBytes - AvailableBytes.
    var usedBytes: Runtime_V1_UInt64Value {
        get { _usedBytes ?? Runtime_V1_UInt64Value() }
        set { _usedBytes = newValue }
    }

    /// Returns true if `usedBytes` has been explicitly set.
    var hasUsedBytes: Bool { _usedBytes != nil }
    /// Clears the value of `usedBytes`. Subsequent reads from it will return its default value.
    mutating func clearUsedBytes() { _usedBytes = nil }

    /// InodesUsed represents the inodes used by the images.
    /// This may not equal InodesCapacity - InodesAvailable because the underlying
    /// filesystem may also be used for purposes other than storing images.
    var inodesUsed: Runtime_V1_UInt64Value {
        get { _inodesUsed ?? Runtime_V1_UInt64Value() }
        set { _inodesUsed = newValue }
    }

    /// Returns true if `inodesUsed` has been explicitly set.
    var hasInodesUsed: Bool { _inodesUsed != nil }
    /// Clears the value of `inodesUsed`. Subsequent reads from it will return its default value.
    mutating func clearInodesUsed() { _inodesUsed = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _fsID: Runtime_V1_FilesystemIdentifier?
    fileprivate var _usedBytes: Runtime_V1_UInt64Value?
    fileprivate var _inodesUsed: Runtime_V1_UInt64Value?
}

/// WindowsFilesystemUsage provides the filesystem usage information specific to Windows.
struct Runtime_V1_WindowsFilesystemUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// The unique identifier of the filesystem.
    var fsID: Runtime_V1_FilesystemIdentifier {
        get { _fsID ?? Runtime_V1_FilesystemIdentifier() }
        set { _fsID = newValue }
    }

    /// Returns true if `fsID` has been explicitly set.
    var hasFsID: Bool { _fsID != nil }
    /// Clears the value of `fsID`. Subsequent reads from it will return its default value.
    mutating func clearFsID() { _fsID = nil }

    /// UsedBytes represents the bytes used for images on the filesystem.
    /// This may differ from the total bytes used on the filesystem and may not
    /// equal CapacityBytes - AvailableBytes.
    var usedBytes: Runtime_V1_UInt64Value {
        get { _usedBytes ?? Runtime_V1_UInt64Value() }
        set { _usedBytes = newValue }
    }

    /// Returns true if `usedBytes` has been explicitly set.
    var hasUsedBytes: Bool { _usedBytes != nil }
    /// Clears the value of `usedBytes`. Subsequent reads from it will return its default value.
    mutating func clearUsedBytes() { _usedBytes = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _fsID: Runtime_V1_FilesystemIdentifier?
    fileprivate var _usedBytes: Runtime_V1_UInt64Value?
}

struct Runtime_V1_ImageFsInfoResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Information of image filesystem(s).
    var imageFilesystems: [Runtime_V1_FilesystemUsage] = []

    /// Information of container filesystem(s).
    /// This is an optional field, may be used for example if container and image
    /// storage are separated.
    /// Default will be to return this as empty.
    var containerFilesystems: [Runtime_V1_FilesystemUsage] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ContainerStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container for which to retrieve stats.
    var containerID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ContainerStatsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Stats of the container.
    var stats: Runtime_V1_ContainerStats {
        get { _stats ?? Runtime_V1_ContainerStats() }
        set { _stats = newValue }
    }

    /// Returns true if `stats` has been explicitly set.
    var hasStats: Bool { _stats != nil }
    /// Clears the value of `stats`. Subsequent reads from it will return its default value.
    mutating func clearStats() { _stats = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _stats: Runtime_V1_ContainerStats?
}

struct Runtime_V1_ListContainerStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Filter for the list request.
    var filter: Runtime_V1_ContainerStatsFilter {
        get { _filter ?? Runtime_V1_ContainerStatsFilter() }
        set { _filter = newValue }
    }

    /// Returns true if `filter` has been explicitly set.
    var hasFilter: Bool { _filter != nil }
    /// Clears the value of `filter`. Subsequent reads from it will return its default value.
    mutating func clearFilter() { _filter = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _filter: Runtime_V1_ContainerStatsFilter?
}

/// ContainerStatsFilter is used to filter containers.
/// All those fields are combined with 'AND'
struct Runtime_V1_ContainerStatsFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container.
    var id: String = .init()

    /// ID of the PodSandbox.
    var podSandboxID: String = .init()

    /// LabelSelector to select matches.
    /// Only api.MatchLabels is supported for now and the requirements
    /// are ANDed. MatchExpressions is not supported yet.
    var labelSelector: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ListContainerStatsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Stats of the container.
    var stats: [Runtime_V1_ContainerStats] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ContainerAttributes provides basic information of the container.
struct Runtime_V1_ContainerAttributes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container.
    var id: String = .init()

    /// Metadata of the container.
    var metadata: Runtime_V1_ContainerMetadata {
        get { _metadata ?? Runtime_V1_ContainerMetadata() }
        set { _metadata = newValue }
    }

    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool { _metadata != nil }
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() { _metadata = nil }

    /// Key-value pairs that may be used to scope and select individual resources.
    var labels: [String: String] = [:]

    /// Unstructured key-value map holding arbitrary metadata.
    /// Annotations MUST NOT be altered by the runtime; the value of this field
    /// MUST be identical to that of the corresponding ContainerConfig used to
    /// instantiate the Container this status represents.
    var annotations: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _metadata: Runtime_V1_ContainerMetadata?
}

/// ContainerStats provides the resource usage statistics for a container.
struct Runtime_V1_ContainerStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Information of the container.
    var attributes: Runtime_V1_ContainerAttributes {
        get { _storage._attributes ?? Runtime_V1_ContainerAttributes() }
        set { _uniqueStorage()._attributes = newValue }
    }

    /// Returns true if `attributes` has been explicitly set.
    var hasAttributes: Bool { _storage._attributes != nil }
    /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
    mutating func clearAttributes() { _uniqueStorage()._attributes = nil }

    /// CPU usage gathered from the container.
    var cpu: Runtime_V1_CpuUsage {
        get { _storage._cpu ?? Runtime_V1_CpuUsage() }
        set { _uniqueStorage()._cpu = newValue }
    }

    /// Returns true if `cpu` has been explicitly set.
    var hasCpu: Bool { _storage._cpu != nil }
    /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
    mutating func clearCpu() { _uniqueStorage()._cpu = nil }

    /// Memory usage gathered from the container.
    var memory: Runtime_V1_MemoryUsage {
        get { _storage._memory ?? Runtime_V1_MemoryUsage() }
        set { _uniqueStorage()._memory = newValue }
    }

    /// Returns true if `memory` has been explicitly set.
    var hasMemory: Bool { _storage._memory != nil }
    /// Clears the value of `memory`. Subsequent reads from it will return its default value.
    mutating func clearMemory() { _uniqueStorage()._memory = nil }

    /// Usage of the writable layer.
    var writableLayer: Runtime_V1_FilesystemUsage {
        get { _storage._writableLayer ?? Runtime_V1_FilesystemUsage() }
        set { _uniqueStorage()._writableLayer = newValue }
    }

    /// Returns true if `writableLayer` has been explicitly set.
    var hasWritableLayer: Bool { _storage._writableLayer != nil }
    /// Clears the value of `writableLayer`. Subsequent reads from it will return its default value.
    mutating func clearWritableLayer() { _uniqueStorage()._writableLayer = nil }

    /// Swap usage gathered from the container.
    var swap: Runtime_V1_SwapUsage {
        get { _storage._swap ?? Runtime_V1_SwapUsage() }
        set { _uniqueStorage()._swap = newValue }
    }

    /// Returns true if `swap` has been explicitly set.
    var hasSwap: Bool { _storage._swap != nil }
    /// Clears the value of `swap`. Subsequent reads from it will return its default value.
    mutating func clearSwap() { _uniqueStorage()._swap = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// WindowsContainerStats provides the resource usage statistics for a container specific for Windows
struct Runtime_V1_WindowsContainerStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Information of the container.
    var attributes: Runtime_V1_ContainerAttributes {
        get { _attributes ?? Runtime_V1_ContainerAttributes() }
        set { _attributes = newValue }
    }

    /// Returns true if `attributes` has been explicitly set.
    var hasAttributes: Bool { _attributes != nil }
    /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
    mutating func clearAttributes() { _attributes = nil }

    /// CPU usage gathered from the container.
    var cpu: Runtime_V1_WindowsCpuUsage {
        get { _cpu ?? Runtime_V1_WindowsCpuUsage() }
        set { _cpu = newValue }
    }

    /// Returns true if `cpu` has been explicitly set.
    var hasCpu: Bool { _cpu != nil }
    /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
    mutating func clearCpu() { _cpu = nil }

    /// Memory usage gathered from the container.
    var memory: Runtime_V1_WindowsMemoryUsage {
        get { _memory ?? Runtime_V1_WindowsMemoryUsage() }
        set { _memory = newValue }
    }

    /// Returns true if `memory` has been explicitly set.
    var hasMemory: Bool { _memory != nil }
    /// Clears the value of `memory`. Subsequent reads from it will return its default value.
    mutating func clearMemory() { _memory = nil }

    /// Usage of the writable layer.
    var writableLayer: Runtime_V1_WindowsFilesystemUsage {
        get { _writableLayer ?? Runtime_V1_WindowsFilesystemUsage() }
        set { _writableLayer = newValue }
    }

    /// Returns true if `writableLayer` has been explicitly set.
    var hasWritableLayer: Bool { _writableLayer != nil }
    /// Clears the value of `writableLayer`. Subsequent reads from it will return its default value.
    mutating func clearWritableLayer() { _writableLayer = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attributes: Runtime_V1_ContainerAttributes?
    fileprivate var _cpu: Runtime_V1_WindowsCpuUsage?
    fileprivate var _memory: Runtime_V1_WindowsMemoryUsage?
    fileprivate var _writableLayer: Runtime_V1_WindowsFilesystemUsage?
}

/// CpuUsage provides the CPU usage information.
struct Runtime_V1_CpuUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// Cumulative CPU usage (sum across all cores) since object creation.
    var usageCoreNanoSeconds: Runtime_V1_UInt64Value {
        get { _usageCoreNanoSeconds ?? Runtime_V1_UInt64Value() }
        set { _usageCoreNanoSeconds = newValue }
    }

    /// Returns true if `usageCoreNanoSeconds` has been explicitly set.
    var hasUsageCoreNanoSeconds: Bool { _usageCoreNanoSeconds != nil }
    /// Clears the value of `usageCoreNanoSeconds`. Subsequent reads from it will return its default value.
    mutating func clearUsageCoreNanoSeconds() { _usageCoreNanoSeconds = nil }

    /// Total CPU usage (sum of all cores) averaged over the sample window.
    /// The "core" unit can be interpreted as CPU core-nanoseconds per second.
    var usageNanoCores: Runtime_V1_UInt64Value {
        get { _usageNanoCores ?? Runtime_V1_UInt64Value() }
        set { _usageNanoCores = newValue }
    }

    /// Returns true if `usageNanoCores` has been explicitly set.
    var hasUsageNanoCores: Bool { _usageNanoCores != nil }
    /// Clears the value of `usageNanoCores`. Subsequent reads from it will return its default value.
    mutating func clearUsageNanoCores() { _usageNanoCores = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _usageCoreNanoSeconds: Runtime_V1_UInt64Value?
    fileprivate var _usageNanoCores: Runtime_V1_UInt64Value?
}

/// WindowsCpuUsage provides the CPU usage information specific to Windows
struct Runtime_V1_WindowsCpuUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// Cumulative CPU usage (sum across all cores) since object creation.
    var usageCoreNanoSeconds: Runtime_V1_UInt64Value {
        get { _usageCoreNanoSeconds ?? Runtime_V1_UInt64Value() }
        set { _usageCoreNanoSeconds = newValue }
    }

    /// Returns true if `usageCoreNanoSeconds` has been explicitly set.
    var hasUsageCoreNanoSeconds: Bool { _usageCoreNanoSeconds != nil }
    /// Clears the value of `usageCoreNanoSeconds`. Subsequent reads from it will return its default value.
    mutating func clearUsageCoreNanoSeconds() { _usageCoreNanoSeconds = nil }

    /// Total CPU usage (sum of all cores) averaged over the sample window.
    /// The "core" unit can be interpreted as CPU core-nanoseconds per second.
    var usageNanoCores: Runtime_V1_UInt64Value {
        get { _usageNanoCores ?? Runtime_V1_UInt64Value() }
        set { _usageNanoCores = newValue }
    }

    /// Returns true if `usageNanoCores` has been explicitly set.
    var hasUsageNanoCores: Bool { _usageNanoCores != nil }
    /// Clears the value of `usageNanoCores`. Subsequent reads from it will return its default value.
    mutating func clearUsageNanoCores() { _usageNanoCores = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _usageCoreNanoSeconds: Runtime_V1_UInt64Value?
    fileprivate var _usageNanoCores: Runtime_V1_UInt64Value?
}

/// MemoryUsage provides the memory usage information.
struct Runtime_V1_MemoryUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// The amount of working set memory in bytes.
    var workingSetBytes: Runtime_V1_UInt64Value {
        get { _workingSetBytes ?? Runtime_V1_UInt64Value() }
        set { _workingSetBytes = newValue }
    }

    /// Returns true if `workingSetBytes` has been explicitly set.
    var hasWorkingSetBytes: Bool { _workingSetBytes != nil }
    /// Clears the value of `workingSetBytes`. Subsequent reads from it will return its default value.
    mutating func clearWorkingSetBytes() { _workingSetBytes = nil }

    /// Available memory for use. This is defined as the memory limit - workingSetBytes.
    var availableBytes: Runtime_V1_UInt64Value {
        get { _availableBytes ?? Runtime_V1_UInt64Value() }
        set { _availableBytes = newValue }
    }

    /// Returns true if `availableBytes` has been explicitly set.
    var hasAvailableBytes: Bool { _availableBytes != nil }
    /// Clears the value of `availableBytes`. Subsequent reads from it will return its default value.
    mutating func clearAvailableBytes() { _availableBytes = nil }

    /// Total memory in use. This includes all memory regardless of when it was accessed.
    var usageBytes: Runtime_V1_UInt64Value {
        get { _usageBytes ?? Runtime_V1_UInt64Value() }
        set { _usageBytes = newValue }
    }

    /// Returns true if `usageBytes` has been explicitly set.
    var hasUsageBytes: Bool { _usageBytes != nil }
    /// Clears the value of `usageBytes`. Subsequent reads from it will return its default value.
    mutating func clearUsageBytes() { _usageBytes = nil }

    /// The amount of anonymous and swap cache memory (includes transparent hugepages).
    var rssBytes: Runtime_V1_UInt64Value {
        get { _rssBytes ?? Runtime_V1_UInt64Value() }
        set { _rssBytes = newValue }
    }

    /// Returns true if `rssBytes` has been explicitly set.
    var hasRssBytes: Bool { _rssBytes != nil }
    /// Clears the value of `rssBytes`. Subsequent reads from it will return its default value.
    mutating func clearRssBytes() { _rssBytes = nil }

    /// Cumulative number of minor page faults.
    var pageFaults: Runtime_V1_UInt64Value {
        get { _pageFaults ?? Runtime_V1_UInt64Value() }
        set { _pageFaults = newValue }
    }

    /// Returns true if `pageFaults` has been explicitly set.
    var hasPageFaults: Bool { _pageFaults != nil }
    /// Clears the value of `pageFaults`. Subsequent reads from it will return its default value.
    mutating func clearPageFaults() { _pageFaults = nil }

    /// Cumulative number of major page faults.
    var majorPageFaults: Runtime_V1_UInt64Value {
        get { _majorPageFaults ?? Runtime_V1_UInt64Value() }
        set { _majorPageFaults = newValue }
    }

    /// Returns true if `majorPageFaults` has been explicitly set.
    var hasMajorPageFaults: Bool { _majorPageFaults != nil }
    /// Clears the value of `majorPageFaults`. Subsequent reads from it will return its default value.
    mutating func clearMajorPageFaults() { _majorPageFaults = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _workingSetBytes: Runtime_V1_UInt64Value?
    fileprivate var _availableBytes: Runtime_V1_UInt64Value?
    fileprivate var _usageBytes: Runtime_V1_UInt64Value?
    fileprivate var _rssBytes: Runtime_V1_UInt64Value?
    fileprivate var _pageFaults: Runtime_V1_UInt64Value?
    fileprivate var _majorPageFaults: Runtime_V1_UInt64Value?
}

struct Runtime_V1_SwapUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// Available swap for use. This is defined as the swap limit - swapUsageBytes.
    var swapAvailableBytes: Runtime_V1_UInt64Value {
        get { _swapAvailableBytes ?? Runtime_V1_UInt64Value() }
        set { _swapAvailableBytes = newValue }
    }

    /// Returns true if `swapAvailableBytes` has been explicitly set.
    var hasSwapAvailableBytes: Bool { _swapAvailableBytes != nil }
    /// Clears the value of `swapAvailableBytes`. Subsequent reads from it will return its default value.
    mutating func clearSwapAvailableBytes() { _swapAvailableBytes = nil }

    /// Total memory in use. This includes all memory regardless of when it was accessed.
    var swapUsageBytes: Runtime_V1_UInt64Value {
        get { _swapUsageBytes ?? Runtime_V1_UInt64Value() }
        set { _swapUsageBytes = newValue }
    }

    /// Returns true if `swapUsageBytes` has been explicitly set.
    var hasSwapUsageBytes: Bool { _swapUsageBytes != nil }
    /// Clears the value of `swapUsageBytes`. Subsequent reads from it will return its default value.
    mutating func clearSwapUsageBytes() { _swapUsageBytes = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _swapAvailableBytes: Runtime_V1_UInt64Value?
    fileprivate var _swapUsageBytes: Runtime_V1_UInt64Value?
}

/// WindowsMemoryUsage provides the memory usage information specific to Windows
struct Runtime_V1_WindowsMemoryUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
    var timestamp: Int64 = 0

    /// The amount of working set memory in bytes.
    var workingSetBytes: Runtime_V1_UInt64Value {
        get { _workingSetBytes ?? Runtime_V1_UInt64Value() }
        set { _workingSetBytes = newValue }
    }

    /// Returns true if `workingSetBytes` has been explicitly set.
    var hasWorkingSetBytes: Bool { _workingSetBytes != nil }
    /// Clears the value of `workingSetBytes`. Subsequent reads from it will return its default value.
    mutating func clearWorkingSetBytes() { _workingSetBytes = nil }

    /// Available memory for use. This is defined as the memory limit - commit_memory_bytes.
    var availableBytes: Runtime_V1_UInt64Value {
        get { _availableBytes ?? Runtime_V1_UInt64Value() }
        set { _availableBytes = newValue }
    }

    /// Returns true if `availableBytes` has been explicitly set.
    var hasAvailableBytes: Bool { _availableBytes != nil }
    /// Clears the value of `availableBytes`. Subsequent reads from it will return its default value.
    mutating func clearAvailableBytes() { _availableBytes = nil }

    /// Cumulative number of page faults.
    var pageFaults: Runtime_V1_UInt64Value {
        get { _pageFaults ?? Runtime_V1_UInt64Value() }
        set { _pageFaults = newValue }
    }

    /// Returns true if `pageFaults` has been explicitly set.
    var hasPageFaults: Bool { _pageFaults != nil }
    /// Clears the value of `pageFaults`. Subsequent reads from it will return its default value.
    mutating func clearPageFaults() { _pageFaults = nil }

    /// Total commit memory in use. Commit memory is total of physical and virtual memory in use.
    var commitMemoryBytes: Runtime_V1_UInt64Value {
        get { _commitMemoryBytes ?? Runtime_V1_UInt64Value() }
        set { _commitMemoryBytes = newValue }
    }

    /// Returns true if `commitMemoryBytes` has been explicitly set.
    var hasCommitMemoryBytes: Bool { _commitMemoryBytes != nil }
    /// Clears the value of `commitMemoryBytes`. Subsequent reads from it will return its default value.
    mutating func clearCommitMemoryBytes() { _commitMemoryBytes = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _workingSetBytes: Runtime_V1_UInt64Value?
    fileprivate var _availableBytes: Runtime_V1_UInt64Value?
    fileprivate var _pageFaults: Runtime_V1_UInt64Value?
    fileprivate var _commitMemoryBytes: Runtime_V1_UInt64Value?
}

struct Runtime_V1_ReopenContainerLogRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container for which to reopen the log.
    var containerID: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ReopenContainerLogResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_CheckpointContainerRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container to be checkpointed.
    var containerID: String = .init()

    /// Location of the checkpoint archive used for export
    var location: String = .init()

    /// Timeout in seconds for the checkpoint to complete.
    /// Timeout of zero means to use the CRI default.
    /// Timeout > 0 means to use the user specified timeout.
    var timeout: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_CheckpointContainerResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_GetEventsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ContainerEventResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the container
    var containerID: String = .init()

    /// Type of the container event
    var containerEventType: Runtime_V1_ContainerEventType = .containerCreatedEvent

    /// Creation timestamp of this event
    var createdAt: Int64 = 0

    /// Sandbox status
    var podSandboxStatus: Runtime_V1_PodSandboxStatus {
        get { _podSandboxStatus ?? Runtime_V1_PodSandboxStatus() }
        set { _podSandboxStatus = newValue }
    }

    /// Returns true if `podSandboxStatus` has been explicitly set.
    var hasPodSandboxStatus: Bool { _podSandboxStatus != nil }
    /// Clears the value of `podSandboxStatus`. Subsequent reads from it will return its default value.
    mutating func clearPodSandboxStatus() { _podSandboxStatus = nil }

    /// Container statuses
    var containersStatuses: [Runtime_V1_ContainerStatus] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _podSandboxStatus: Runtime_V1_PodSandboxStatus?
}

struct Runtime_V1_ListMetricDescriptorsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ListMetricDescriptorsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var descriptors: [Runtime_V1_MetricDescriptor] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_MetricDescriptor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name field will be used as a unique identifier of this MetricDescriptor,
    /// and be used in conjunction with the Metric structure to populate the full Metric.
    var name: String = .init()

    var help: String = .init()

    /// When a metric uses this metric descriptor, it should only define
    /// labels that have previously been declared in label_keys.
    /// It is the responsibility of the runtime to correctly keep sorted the keys and values.
    /// If the two slices have different length, the behavior is undefined.
    var labelKeys: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ListPodSandboxMetricsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ListPodSandboxMetricsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var podMetrics: [Runtime_V1_PodSandboxMetrics] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_PodSandboxMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var podSandboxID: String = .init()

    var metrics: [Runtime_V1_Metric] = []

    var containerMetrics: [Runtime_V1_ContainerMetrics] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_ContainerMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var containerID: String = .init()

    var metrics: [Runtime_V1_Metric] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_Metric {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name must match a name previously returned in a MetricDescriptors call,
    /// otherwise, it will be ignored.
    var name: String = .init()

    /// Timestamp should be 0 if the metric was gathered live.
    /// If it was cached, the Timestamp should reflect the time it was collected.
    var timestamp: Int64 = 0

    var metricType: Runtime_V1_MetricType = .counter

    /// The corresponding LabelValues to the LabelKeys defined in the MetricDescriptor.
    /// It is the responsibility of the runtime to correctly keep sorted the keys and values.
    /// If the two slices have different length, the behavior is undefined.
    var labelValues: [String] = []

    var value: Runtime_V1_UInt64Value {
        get { _value ?? Runtime_V1_UInt64Value() }
        set { _value = newValue }
    }

    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool { _value != nil }
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() { _value = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _value: Runtime_V1_UInt64Value?
}

struct Runtime_V1_RuntimeConfigRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Runtime_V1_RuntimeConfigResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Configuration information for Linux-based runtimes. This field contains
    /// global runtime configuration options that are not specific to runtime
    /// handlers.
    var linux: Runtime_V1_LinuxRuntimeConfiguration {
        get { _linux ?? Runtime_V1_LinuxRuntimeConfiguration() }
        set { _linux = newValue }
    }

    /// Returns true if `linux` has been explicitly set.
    var hasLinux: Bool { _linux != nil }
    /// Clears the value of `linux`. Subsequent reads from it will return its default value.
    mutating func clearLinux() { _linux = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _linux: Runtime_V1_LinuxRuntimeConfiguration?
}

struct Runtime_V1_LinuxRuntimeConfiguration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Cgroup driver to use
    /// Note: this field should not change for the lifecycle of the Kubelet,
    /// or while there are running containers.
    /// The Kubelet will not re-request this after startup, and will construct the cgroup
    /// hierarchy assuming it is static.
    /// If the runtime wishes to change this value, it must be accompanied by removal of
    /// all pods, and a restart of the Kubelet. The easiest way to do this is with a full node reboot.
    var cgroupDriver: Runtime_V1_CgroupDriver = .systemd

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension Runtime_V1_Protocol: @unchecked Sendable {}
    extension Runtime_V1_MountPropagation: @unchecked Sendable {}
    extension Runtime_V1_NamespaceMode: @unchecked Sendable {}
    extension Runtime_V1_SupplementalGroupsPolicy: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxState: @unchecked Sendable {}
    extension Runtime_V1_ContainerState: @unchecked Sendable {}
    extension Runtime_V1_ContainerEventType: @unchecked Sendable {}
    extension Runtime_V1_MetricType: @unchecked Sendable {}
    extension Runtime_V1_CgroupDriver: @unchecked Sendable {}
    extension Runtime_V1_VersionRequest: @unchecked Sendable {}
    extension Runtime_V1_VersionResponse: @unchecked Sendable {}
    extension Runtime_V1_DNSConfig: @unchecked Sendable {}
    extension Runtime_V1_PortMapping: @unchecked Sendable {}
    extension Runtime_V1_Mount: @unchecked Sendable {}
    extension Runtime_V1_IDMapping: @unchecked Sendable {}
    extension Runtime_V1_UserNamespace: @unchecked Sendable {}
    extension Runtime_V1_NamespaceOption: @unchecked Sendable {}
    extension Runtime_V1_Int64Value: @unchecked Sendable {}
    extension Runtime_V1_LinuxSandboxSecurityContext: @unchecked Sendable {}
    extension Runtime_V1_SecurityProfile: @unchecked Sendable {}
    extension Runtime_V1_SecurityProfile.ProfileType: @unchecked Sendable {}
    extension Runtime_V1_LinuxPodSandboxConfig: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxMetadata: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxConfig: @unchecked Sendable {}
    extension Runtime_V1_RunPodSandboxRequest: @unchecked Sendable {}
    extension Runtime_V1_RunPodSandboxResponse: @unchecked Sendable {}
    extension Runtime_V1_StopPodSandboxRequest: @unchecked Sendable {}
    extension Runtime_V1_StopPodSandboxResponse: @unchecked Sendable {}
    extension Runtime_V1_RemovePodSandboxRequest: @unchecked Sendable {}
    extension Runtime_V1_RemovePodSandboxResponse: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxStatusRequest: @unchecked Sendable {}
    extension Runtime_V1_PodIP: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxNetworkStatus: @unchecked Sendable {}
    extension Runtime_V1_Namespace: @unchecked Sendable {}
    extension Runtime_V1_LinuxPodSandboxStatus: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxStatus: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxStatusResponse: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxStateValue: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxFilter: @unchecked Sendable {}
    extension Runtime_V1_ListPodSandboxRequest: @unchecked Sendable {}
    extension Runtime_V1_PodSandbox: @unchecked Sendable {}
    extension Runtime_V1_ListPodSandboxResponse: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxStatsRequest: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxStatsResponse: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxStatsFilter: @unchecked Sendable {}
    extension Runtime_V1_ListPodSandboxStatsRequest: @unchecked Sendable {}
    extension Runtime_V1_ListPodSandboxStatsResponse: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxAttributes: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxStats: @unchecked Sendable {}
    extension Runtime_V1_LinuxPodSandboxStats: @unchecked Sendable {}
    extension Runtime_V1_WindowsPodSandboxStats: @unchecked Sendable {}
    extension Runtime_V1_NetworkUsage: @unchecked Sendable {}
    extension Runtime_V1_WindowsNetworkUsage: @unchecked Sendable {}
    extension Runtime_V1_NetworkInterfaceUsage: @unchecked Sendable {}
    extension Runtime_V1_WindowsNetworkInterfaceUsage: @unchecked Sendable {}
    extension Runtime_V1_ProcessUsage: @unchecked Sendable {}
    extension Runtime_V1_WindowsProcessUsage: @unchecked Sendable {}
    extension Runtime_V1_ImageSpec: @unchecked Sendable {}
    extension Runtime_V1_KeyValue: @unchecked Sendable {}
    extension Runtime_V1_LinuxContainerResources: @unchecked Sendable {}
    extension Runtime_V1_HugepageLimit: @unchecked Sendable {}
    extension Runtime_V1_SELinuxOption: @unchecked Sendable {}
    extension Runtime_V1_Capability: @unchecked Sendable {}
    extension Runtime_V1_LinuxContainerSecurityContext: @unchecked Sendable {}
    extension Runtime_V1_LinuxContainerConfig: @unchecked Sendable {}
    extension Runtime_V1_LinuxContainerUser: @unchecked Sendable {}
    extension Runtime_V1_WindowsNamespaceOption: @unchecked Sendable {}
    extension Runtime_V1_WindowsSandboxSecurityContext: @unchecked Sendable {}
    extension Runtime_V1_WindowsPodSandboxConfig: @unchecked Sendable {}
    extension Runtime_V1_WindowsContainerSecurityContext: @unchecked Sendable {}
    extension Runtime_V1_WindowsContainerConfig: @unchecked Sendable {}
    extension Runtime_V1_WindowsContainerResources: @unchecked Sendable {}
    extension Runtime_V1_ContainerMetadata: @unchecked Sendable {}
    extension Runtime_V1_Device: @unchecked Sendable {}
    extension Runtime_V1_CDIDevice: @unchecked Sendable {}
    extension Runtime_V1_ContainerConfig: @unchecked Sendable {}
    extension Runtime_V1_CreateContainerRequest: @unchecked Sendable {}
    extension Runtime_V1_CreateContainerResponse: @unchecked Sendable {}
    extension Runtime_V1_StartContainerRequest: @unchecked Sendable {}
    extension Runtime_V1_StartContainerResponse: @unchecked Sendable {}
    extension Runtime_V1_StopContainerRequest: @unchecked Sendable {}
    extension Runtime_V1_StopContainerResponse: @unchecked Sendable {}
    extension Runtime_V1_RemoveContainerRequest: @unchecked Sendable {}
    extension Runtime_V1_RemoveContainerResponse: @unchecked Sendable {}
    extension Runtime_V1_ContainerStateValue: @unchecked Sendable {}
    extension Runtime_V1_ContainerFilter: @unchecked Sendable {}
    extension Runtime_V1_ListContainersRequest: @unchecked Sendable {}
    extension Runtime_V1_Container: @unchecked Sendable {}
    extension Runtime_V1_ListContainersResponse: @unchecked Sendable {}
    extension Runtime_V1_ContainerStatusRequest: @unchecked Sendable {}
    extension Runtime_V1_ContainerStatus: @unchecked Sendable {}
    extension Runtime_V1_ContainerStatusResponse: @unchecked Sendable {}
    extension Runtime_V1_ContainerResources: @unchecked Sendable {}
    extension Runtime_V1_ContainerUser: @unchecked Sendable {}
    extension Runtime_V1_UpdateContainerResourcesRequest: @unchecked Sendable {}
    extension Runtime_V1_UpdateContainerResourcesResponse: @unchecked Sendable {}
    extension Runtime_V1_ExecSyncRequest: @unchecked Sendable {}
    extension Runtime_V1_ExecSyncResponse: @unchecked Sendable {}
    extension Runtime_V1_ExecRequest: @unchecked Sendable {}
    extension Runtime_V1_ExecResponse: @unchecked Sendable {}
    extension Runtime_V1_AttachRequest: @unchecked Sendable {}
    extension Runtime_V1_AttachResponse: @unchecked Sendable {}
    extension Runtime_V1_PortForwardRequest: @unchecked Sendable {}
    extension Runtime_V1_PortForwardResponse: @unchecked Sendable {}
    extension Runtime_V1_ImageFilter: @unchecked Sendable {}
    extension Runtime_V1_ListImagesRequest: @unchecked Sendable {}
    extension Runtime_V1_Image: @unchecked Sendable {}
    extension Runtime_V1_ListImagesResponse: @unchecked Sendable {}
    extension Runtime_V1_ImageStatusRequest: @unchecked Sendable {}
    extension Runtime_V1_ImageStatusResponse: @unchecked Sendable {}
    extension Runtime_V1_AuthConfig: @unchecked Sendable {}
    extension Runtime_V1_PullImageRequest: @unchecked Sendable {}
    extension Runtime_V1_PullImageResponse: @unchecked Sendable {}
    extension Runtime_V1_RemoveImageRequest: @unchecked Sendable {}
    extension Runtime_V1_RemoveImageResponse: @unchecked Sendable {}
    extension Runtime_V1_NetworkConfig: @unchecked Sendable {}
    extension Runtime_V1_RuntimeConfig: @unchecked Sendable {}
    extension Runtime_V1_UpdateRuntimeConfigRequest: @unchecked Sendable {}
    extension Runtime_V1_UpdateRuntimeConfigResponse: @unchecked Sendable {}
    extension Runtime_V1_RuntimeCondition: @unchecked Sendable {}
    extension Runtime_V1_RuntimeStatus: @unchecked Sendable {}
    extension Runtime_V1_StatusRequest: @unchecked Sendable {}
    extension Runtime_V1_RuntimeHandlerFeatures: @unchecked Sendable {}
    extension Runtime_V1_RuntimeHandler: @unchecked Sendable {}
    extension Runtime_V1_StatusResponse: @unchecked Sendable {}
    extension Runtime_V1_ImageFsInfoRequest: @unchecked Sendable {}
    extension Runtime_V1_UInt64Value: @unchecked Sendable {}
    extension Runtime_V1_FilesystemIdentifier: @unchecked Sendable {}
    extension Runtime_V1_FilesystemUsage: @unchecked Sendable {}
    extension Runtime_V1_WindowsFilesystemUsage: @unchecked Sendable {}
    extension Runtime_V1_ImageFsInfoResponse: @unchecked Sendable {}
    extension Runtime_V1_ContainerStatsRequest: @unchecked Sendable {}
    extension Runtime_V1_ContainerStatsResponse: @unchecked Sendable {}
    extension Runtime_V1_ListContainerStatsRequest: @unchecked Sendable {}
    extension Runtime_V1_ContainerStatsFilter: @unchecked Sendable {}
    extension Runtime_V1_ListContainerStatsResponse: @unchecked Sendable {}
    extension Runtime_V1_ContainerAttributes: @unchecked Sendable {}
    extension Runtime_V1_ContainerStats: @unchecked Sendable {}
    extension Runtime_V1_WindowsContainerStats: @unchecked Sendable {}
    extension Runtime_V1_CpuUsage: @unchecked Sendable {}
    extension Runtime_V1_WindowsCpuUsage: @unchecked Sendable {}
    extension Runtime_V1_MemoryUsage: @unchecked Sendable {}
    extension Runtime_V1_SwapUsage: @unchecked Sendable {}
    extension Runtime_V1_WindowsMemoryUsage: @unchecked Sendable {}
    extension Runtime_V1_ReopenContainerLogRequest: @unchecked Sendable {}
    extension Runtime_V1_ReopenContainerLogResponse: @unchecked Sendable {}
    extension Runtime_V1_CheckpointContainerRequest: @unchecked Sendable {}
    extension Runtime_V1_CheckpointContainerResponse: @unchecked Sendable {}
    extension Runtime_V1_GetEventsRequest: @unchecked Sendable {}
    extension Runtime_V1_ContainerEventResponse: @unchecked Sendable {}
    extension Runtime_V1_ListMetricDescriptorsRequest: @unchecked Sendable {}
    extension Runtime_V1_ListMetricDescriptorsResponse: @unchecked Sendable {}
    extension Runtime_V1_MetricDescriptor: @unchecked Sendable {}
    extension Runtime_V1_ListPodSandboxMetricsRequest: @unchecked Sendable {}
    extension Runtime_V1_ListPodSandboxMetricsResponse: @unchecked Sendable {}
    extension Runtime_V1_PodSandboxMetrics: @unchecked Sendable {}
    extension Runtime_V1_ContainerMetrics: @unchecked Sendable {}
    extension Runtime_V1_Metric: @unchecked Sendable {}
    extension Runtime_V1_RuntimeConfigRequest: @unchecked Sendable {}
    extension Runtime_V1_RuntimeConfigResponse: @unchecked Sendable {}
    extension Runtime_V1_LinuxRuntimeConfiguration: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "runtime.v1"

extension Runtime_V1_Protocol: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "TCP"),
        1: .same(proto: "UDP"),
        2: .same(proto: "SCTP"),
    ]
}

extension Runtime_V1_MountPropagation: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "PROPAGATION_PRIVATE"),
        1: .same(proto: "PROPAGATION_HOST_TO_CONTAINER"),
        2: .same(proto: "PROPAGATION_BIDIRECTIONAL"),
    ]
}

extension Runtime_V1_NamespaceMode: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "POD"),
        1: .same(proto: "CONTAINER"),
        2: .same(proto: "NODE"),
        3: .same(proto: "TARGET"),
    ]
}

extension Runtime_V1_SupplementalGroupsPolicy: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Merge"),
        1: .same(proto: "Strict"),
    ]
}

extension Runtime_V1_PodSandboxState: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "SANDBOX_READY"),
        1: .same(proto: "SANDBOX_NOTREADY"),
    ]
}

extension Runtime_V1_ContainerState: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "CONTAINER_CREATED"),
        1: .same(proto: "CONTAINER_RUNNING"),
        2: .same(proto: "CONTAINER_EXITED"),
        3: .same(proto: "CONTAINER_UNKNOWN"),
    ]
}

extension Runtime_V1_ContainerEventType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "CONTAINER_CREATED_EVENT"),
        1: .same(proto: "CONTAINER_STARTED_EVENT"),
        2: .same(proto: "CONTAINER_STOPPED_EVENT"),
        3: .same(proto: "CONTAINER_DELETED_EVENT"),
    ]
}

extension Runtime_V1_MetricType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "COUNTER"),
        1: .same(proto: "GAUGE"),
    ]
}

extension Runtime_V1_CgroupDriver: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "SYSTEMD"),
        1: .same(proto: "CGROUPFS"),
    ]
}

extension Runtime_V1_VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VersionRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &version)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !version.isEmpty {
            try visitor.visitSingularStringField(value: version, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_VersionRequest, rhs: Runtime_V1_VersionRequest) -> Bool {
        if lhs.version != rhs.version { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VersionResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        2: .standard(proto: "runtime_name"),
        3: .standard(proto: "runtime_version"),
        4: .standard(proto: "runtime_api_version"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &version)
            case 2: try try decoder.decodeSingularStringField(value: &runtimeName)
            case 3: try try decoder.decodeSingularStringField(value: &runtimeVersion)
            case 4: try try decoder.decodeSingularStringField(value: &runtimeApiVersion)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !version.isEmpty {
            try visitor.visitSingularStringField(value: version, fieldNumber: 1)
        }
        if !runtimeName.isEmpty {
            try visitor.visitSingularStringField(value: runtimeName, fieldNumber: 2)
        }
        if !runtimeVersion.isEmpty {
            try visitor.visitSingularStringField(value: runtimeVersion, fieldNumber: 3)
        }
        if !runtimeApiVersion.isEmpty {
            try visitor.visitSingularStringField(value: runtimeApiVersion, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_VersionResponse, rhs: Runtime_V1_VersionResponse) -> Bool {
        if lhs.version != rhs.version { return false }
        if lhs.runtimeName != rhs.runtimeName { return false }
        if lhs.runtimeVersion != rhs.runtimeVersion { return false }
        if lhs.runtimeApiVersion != rhs.runtimeApiVersion { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_DNSConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DNSConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "servers"),
        2: .same(proto: "searches"),
        3: .same(proto: "options"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedStringField(value: &servers)
            case 2: try try decoder.decodeRepeatedStringField(value: &searches)
            case 3: try try decoder.decodeRepeatedStringField(value: &options)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !servers.isEmpty {
            try visitor.visitRepeatedStringField(value: servers, fieldNumber: 1)
        }
        if !searches.isEmpty {
            try visitor.visitRepeatedStringField(value: searches, fieldNumber: 2)
        }
        if !options.isEmpty {
            try visitor.visitRepeatedStringField(value: options, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_DNSConfig, rhs: Runtime_V1_DNSConfig) -> Bool {
        if lhs.servers != rhs.servers { return false }
        if lhs.searches != rhs.searches { return false }
        if lhs.options != rhs.options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PortMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PortMapping"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "protocol"),
        2: .standard(proto: "container_port"),
        3: .standard(proto: "host_port"),
        4: .standard(proto: "host_ip"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &self.protocol)
            case 2: try try decoder.decodeSingularInt32Field(value: &containerPort)
            case 3: try try decoder.decodeSingularInt32Field(value: &hostPort)
            case 4: try try decoder.decodeSingularStringField(value: &hostIp)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if self.protocol != .tcp {
            try visitor.visitSingularEnumField(value: self.protocol, fieldNumber: 1)
        }
        if containerPort != 0 {
            try visitor.visitSingularInt32Field(value: containerPort, fieldNumber: 2)
        }
        if hostPort != 0 {
            try visitor.visitSingularInt32Field(value: hostPort, fieldNumber: 3)
        }
        if !hostIp.isEmpty {
            try visitor.visitSingularStringField(value: hostIp, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PortMapping, rhs: Runtime_V1_PortMapping) -> Bool {
        if lhs.protocol != rhs.protocol { return false }
        if lhs.containerPort != rhs.containerPort { return false }
        if lhs.hostPort != rhs.hostPort { return false }
        if lhs.hostIp != rhs.hostIp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_Mount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Mount"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_path"),
        2: .standard(proto: "host_path"),
        3: .same(proto: "readonly"),
        4: .standard(proto: "selinux_relabel"),
        5: .same(proto: "propagation"),
        6: .same(proto: "uidMappings"),
        7: .same(proto: "gidMappings"),
        8: .standard(proto: "recursive_read_only"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerPath)
            case 2: try try decoder.decodeSingularStringField(value: &hostPath)
            case 3: try try decoder.decodeSingularBoolField(value: &readonly)
            case 4: try try decoder.decodeSingularBoolField(value: &selinuxRelabel)
            case 5: try try decoder.decodeSingularEnumField(value: &propagation)
            case 6: try try decoder.decodeRepeatedMessageField(value: &uidMappings)
            case 7: try try decoder.decodeRepeatedMessageField(value: &gidMappings)
            case 8: try try decoder.decodeSingularBoolField(value: &recursiveReadOnly)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerPath.isEmpty {
            try visitor.visitSingularStringField(value: containerPath, fieldNumber: 1)
        }
        if !hostPath.isEmpty {
            try visitor.visitSingularStringField(value: hostPath, fieldNumber: 2)
        }
        if readonly != false {
            try visitor.visitSingularBoolField(value: readonly, fieldNumber: 3)
        }
        if selinuxRelabel != false {
            try visitor.visitSingularBoolField(value: selinuxRelabel, fieldNumber: 4)
        }
        if propagation != .propagationPrivate {
            try visitor.visitSingularEnumField(value: propagation, fieldNumber: 5)
        }
        if !uidMappings.isEmpty {
            try visitor.visitRepeatedMessageField(value: uidMappings, fieldNumber: 6)
        }
        if !gidMappings.isEmpty {
            try visitor.visitRepeatedMessageField(value: gidMappings, fieldNumber: 7)
        }
        if recursiveReadOnly != false {
            try visitor.visitSingularBoolField(value: recursiveReadOnly, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_Mount, rhs: Runtime_V1_Mount) -> Bool {
        if lhs.containerPath != rhs.containerPath { return false }
        if lhs.hostPath != rhs.hostPath { return false }
        if lhs.readonly != rhs.readonly { return false }
        if lhs.selinuxRelabel != rhs.selinuxRelabel { return false }
        if lhs.propagation != rhs.propagation { return false }
        if lhs.uidMappings != rhs.uidMappings { return false }
        if lhs.gidMappings != rhs.gidMappings { return false }
        if lhs.recursiveReadOnly != rhs.recursiveReadOnly { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_IDMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".IDMapping"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "host_id"),
        2: .standard(proto: "container_id"),
        3: .same(proto: "length"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularUInt32Field(value: &hostID)
            case 2: try try decoder.decodeSingularUInt32Field(value: &containerID)
            case 3: try try decoder.decodeSingularUInt32Field(value: &length)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if hostID != 0 {
            try visitor.visitSingularUInt32Field(value: hostID, fieldNumber: 1)
        }
        if containerID != 0 {
            try visitor.visitSingularUInt32Field(value: containerID, fieldNumber: 2)
        }
        if length != 0 {
            try visitor.visitSingularUInt32Field(value: length, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_IDMapping, rhs: Runtime_V1_IDMapping) -> Bool {
        if lhs.hostID != rhs.hostID { return false }
        if lhs.containerID != rhs.containerID { return false }
        if lhs.length != rhs.length { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_UserNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UserNamespace"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "mode"),
        2: .same(proto: "uids"),
        3: .same(proto: "gids"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &mode)
            case 2: try try decoder.decodeRepeatedMessageField(value: &uids)
            case 3: try try decoder.decodeRepeatedMessageField(value: &gids)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if mode != .pod {
            try visitor.visitSingularEnumField(value: mode, fieldNumber: 1)
        }
        if !uids.isEmpty {
            try visitor.visitRepeatedMessageField(value: uids, fieldNumber: 2)
        }
        if !gids.isEmpty {
            try visitor.visitRepeatedMessageField(value: gids, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_UserNamespace, rhs: Runtime_V1_UserNamespace) -> Bool {
        if lhs.mode != rhs.mode { return false }
        if lhs.uids != rhs.uids { return false }
        if lhs.gids != rhs.gids { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_NamespaceOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".NamespaceOption"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "network"),
        2: .same(proto: "pid"),
        3: .same(proto: "ipc"),
        4: .standard(proto: "target_id"),
        5: .standard(proto: "userns_options"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &network)
            case 2: try try decoder.decodeSingularEnumField(value: &pid)
            case 3: try try decoder.decodeSingularEnumField(value: &ipc)
            case 4: try try decoder.decodeSingularStringField(value: &targetID)
            case 5: try try decoder.decodeSingularMessageField(value: &_usernsOptions)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if network != .pod {
            try visitor.visitSingularEnumField(value: network, fieldNumber: 1)
        }
        if pid != .pod {
            try visitor.visitSingularEnumField(value: pid, fieldNumber: 2)
        }
        if ipc != .pod {
            try visitor.visitSingularEnumField(value: ipc, fieldNumber: 3)
        }
        if !targetID.isEmpty {
            try visitor.visitSingularStringField(value: targetID, fieldNumber: 4)
        }
        try { if let v = self._usernsOptions {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_NamespaceOption, rhs: Runtime_V1_NamespaceOption) -> Bool {
        if lhs.network != rhs.network { return false }
        if lhs.pid != rhs.pid { return false }
        if lhs.ipc != rhs.ipc { return false }
        if lhs.targetID != rhs.targetID { return false }
        if lhs._usernsOptions != rhs._usernsOptions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_Int64Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Int64Value"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "value"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &value)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if value != 0 {
            try visitor.visitSingularInt64Field(value: value, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_Int64Value, rhs: Runtime_V1_Int64Value) -> Bool {
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_LinuxSandboxSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxSandboxSecurityContext"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "namespace_options"),
        2: .standard(proto: "selinux_options"),
        3: .standard(proto: "run_as_user"),
        8: .standard(proto: "run_as_group"),
        4: .standard(proto: "readonly_rootfs"),
        5: .standard(proto: "supplemental_groups"),
        11: .standard(proto: "supplemental_groups_policy"),
        6: .same(proto: "privileged"),
        9: .same(proto: "seccomp"),
        10: .same(proto: "apparmor"),
        7: .standard(proto: "seccomp_profile_path"),
    ]

    fileprivate class _StorageClass {
        var _namespaceOptions: Runtime_V1_NamespaceOption?
        var _selinuxOptions: Runtime_V1_SELinuxOption?
        var _runAsUser: Runtime_V1_Int64Value?
        var _runAsGroup: Runtime_V1_Int64Value?
        var _readonlyRootfs: Bool = false
        var _supplementalGroups: [Int64] = []
        var _supplementalGroupsPolicy: Runtime_V1_SupplementalGroupsPolicy = .merge
        var _privileged: Bool = false
        var _seccomp: Runtime_V1_SecurityProfile?
        var _apparmor: Runtime_V1_SecurityProfile?
        var _seccompProfilePath: String = .init()

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _namespaceOptions = source._namespaceOptions
            _selinuxOptions = source._selinuxOptions
            _runAsUser = source._runAsUser
            _runAsGroup = source._runAsGroup
            _readonlyRootfs = source._readonlyRootfs
            _supplementalGroups = source._supplementalGroups
            _supplementalGroupsPolicy = source._supplementalGroupsPolicy
            _privileged = source._privileged
            _seccomp = source._seccomp
            _apparmor = source._apparmor
            _seccompProfilePath = source._seccompProfilePath
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularMessageField(value: &_storage._namespaceOptions)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._selinuxOptions)
                case 3: try try decoder.decodeSingularMessageField(value: &_storage._runAsUser)
                case 4: try try decoder.decodeSingularBoolField(value: &_storage._readonlyRootfs)
                case 5: try try decoder.decodeRepeatedInt64Field(value: &_storage._supplementalGroups)
                case 6: try try decoder.decodeSingularBoolField(value: &_storage._privileged)
                case 7: try try decoder.decodeSingularStringField(value: &_storage._seccompProfilePath)
                case 8: try try decoder.decodeSingularMessageField(value: &_storage._runAsGroup)
                case 9: try try decoder.decodeSingularMessageField(value: &_storage._seccomp)
                case 10: try try decoder.decodeSingularMessageField(value: &_storage._apparmor)
                case 11: try try decoder.decodeSingularEnumField(value: &_storage._supplementalGroupsPolicy)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._namespaceOptions {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._selinuxOptions {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            try { if let v = _storage._runAsUser {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            if _storage._readonlyRootfs != false {
                try visitor.visitSingularBoolField(value: _storage._readonlyRootfs, fieldNumber: 4)
            }
            if !_storage._supplementalGroups.isEmpty {
                try visitor.visitPackedInt64Field(value: _storage._supplementalGroups, fieldNumber: 5)
            }
            if _storage._privileged != false {
                try visitor.visitSingularBoolField(value: _storage._privileged, fieldNumber: 6)
            }
            if !_storage._seccompProfilePath.isEmpty {
                try visitor.visitSingularStringField(value: _storage._seccompProfilePath, fieldNumber: 7)
            }
            try { if let v = _storage._runAsGroup {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            } }()
            try { if let v = _storage._seccomp {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            } }()
            try { if let v = _storage._apparmor {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            } }()
            if _storage._supplementalGroupsPolicy != .merge {
                try visitor.visitSingularEnumField(value: _storage._supplementalGroupsPolicy, fieldNumber: 11)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_LinuxSandboxSecurityContext, rhs: Runtime_V1_LinuxSandboxSecurityContext) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._namespaceOptions != rhs_storage._namespaceOptions { return false }
                if _storage._selinuxOptions != rhs_storage._selinuxOptions { return false }
                if _storage._runAsUser != rhs_storage._runAsUser { return false }
                if _storage._runAsGroup != rhs_storage._runAsGroup { return false }
                if _storage._readonlyRootfs != rhs_storage._readonlyRootfs { return false }
                if _storage._supplementalGroups != rhs_storage._supplementalGroups { return false }
                if _storage._supplementalGroupsPolicy != rhs_storage._supplementalGroupsPolicy { return false }
                if _storage._privileged != rhs_storage._privileged { return false }
                if _storage._seccomp != rhs_storage._seccomp { return false }
                if _storage._apparmor != rhs_storage._apparmor { return false }
                if _storage._seccompProfilePath != rhs_storage._seccompProfilePath { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_SecurityProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SecurityProfile"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "profile_type"),
        2: .standard(proto: "localhost_ref"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &profileType)
            case 2: try try decoder.decodeSingularStringField(value: &localhostRef)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if profileType != .runtimeDefault {
            try visitor.visitSingularEnumField(value: profileType, fieldNumber: 1)
        }
        if !localhostRef.isEmpty {
            try visitor.visitSingularStringField(value: localhostRef, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_SecurityProfile, rhs: Runtime_V1_SecurityProfile) -> Bool {
        if lhs.profileType != rhs.profileType { return false }
        if lhs.localhostRef != rhs.localhostRef { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_SecurityProfile.ProfileType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "RuntimeDefault"),
        1: .same(proto: "Unconfined"),
        2: .same(proto: "Localhost"),
    ]
}

extension Runtime_V1_LinuxPodSandboxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxPodSandboxConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cgroup_parent"),
        2: .standard(proto: "security_context"),
        3: .same(proto: "sysctls"),
        4: .same(proto: "overhead"),
        5: .same(proto: "resources"),
    ]

    fileprivate class _StorageClass {
        var _cgroupParent: String = .init()
        var _securityContext: Runtime_V1_LinuxSandboxSecurityContext?
        var _sysctls: [String: String] = [:]
        var _overhead: Runtime_V1_LinuxContainerResources?
        var _resources: Runtime_V1_LinuxContainerResources?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _cgroupParent = source._cgroupParent
            _securityContext = source._securityContext
            _sysctls = source._sysctls
            _overhead = source._overhead
            _resources = source._resources
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularStringField(value: &_storage._cgroupParent)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._securityContext)
                case 3: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._sysctls
                    ) }()
                case 4: try try decoder.decodeSingularMessageField(value: &_storage._overhead)
                case 5: try try decoder.decodeSingularMessageField(value: &_storage._resources)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._cgroupParent.isEmpty {
                try visitor.visitSingularStringField(value: _storage._cgroupParent, fieldNumber: 1)
            }
            try { if let v = _storage._securityContext {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            if !_storage._sysctls.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._sysctls,
                    fieldNumber: 3
                )
            }
            try { if let v = _storage._overhead {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            } }()
            try { if let v = _storage._resources {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_LinuxPodSandboxConfig, rhs: Runtime_V1_LinuxPodSandboxConfig) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._cgroupParent != rhs_storage._cgroupParent { return false }
                if _storage._securityContext != rhs_storage._securityContext { return false }
                if _storage._sysctls != rhs_storage._sysctls { return false }
                if _storage._overhead != rhs_storage._overhead { return false }
                if _storage._resources != rhs_storage._resources { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxMetadata"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "uid"),
        3: .same(proto: "namespace"),
        4: .same(proto: "attempt"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularStringField(value: &uid)
            case 3: try try decoder.decodeSingularStringField(value: &namespace)
            case 4: try try decoder.decodeSingularUInt32Field(value: &attempt)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !uid.isEmpty {
            try visitor.visitSingularStringField(value: uid, fieldNumber: 2)
        }
        if !namespace.isEmpty {
            try visitor.visitSingularStringField(value: namespace, fieldNumber: 3)
        }
        if attempt != 0 {
            try visitor.visitSingularUInt32Field(value: attempt, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxMetadata, rhs: Runtime_V1_PodSandboxMetadata) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.uid != rhs.uid { return false }
        if lhs.namespace != rhs.namespace { return false }
        if lhs.attempt != rhs.attempt { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "metadata"),
        2: .same(proto: "hostname"),
        3: .standard(proto: "log_directory"),
        4: .standard(proto: "dns_config"),
        5: .standard(proto: "port_mappings"),
        6: .same(proto: "labels"),
        7: .same(proto: "annotations"),
        8: .same(proto: "linux"),
        9: .same(proto: "windows"),
    ]

    fileprivate class _StorageClass {
        var _metadata: Runtime_V1_PodSandboxMetadata?
        var _hostname: String = .init()
        var _logDirectory: String = .init()
        var _dnsConfig: Runtime_V1_DNSConfig?
        var _portMappings: [Runtime_V1_PortMapping] = []
        var _labels: [String: String] = [:]
        var _annotations: [String: String] = [:]
        var _linux: Runtime_V1_LinuxPodSandboxConfig?
        var _windows: Runtime_V1_WindowsPodSandboxConfig?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _metadata = source._metadata
            _hostname = source._hostname
            _logDirectory = source._logDirectory
            _dnsConfig = source._dnsConfig
            _portMappings = source._portMappings
            _labels = source._labels
            _annotations = source._annotations
            _linux = source._linux
            _windows = source._windows
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularMessageField(value: &_storage._metadata)
                case 2: try try decoder.decodeSingularStringField(value: &_storage._hostname)
                case 3: try try decoder.decodeSingularStringField(value: &_storage._logDirectory)
                case 4: try try decoder.decodeSingularMessageField(value: &_storage._dnsConfig)
                case 5: try try decoder.decodeRepeatedMessageField(value: &_storage._portMappings)
                case 6: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._labels
                    ) }()
                case 7: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._annotations
                    ) }()
                case 8: try try decoder.decodeSingularMessageField(value: &_storage._linux)
                case 9: try try decoder.decodeSingularMessageField(value: &_storage._windows)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._metadata {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if !_storage._hostname.isEmpty {
                try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 2)
            }
            if !_storage._logDirectory.isEmpty {
                try visitor.visitSingularStringField(value: _storage._logDirectory, fieldNumber: 3)
            }
            try { if let v = _storage._dnsConfig {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            } }()
            if !_storage._portMappings.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._portMappings, fieldNumber: 5)
            }
            if !_storage._labels.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._labels,
                    fieldNumber: 6
                )
            }
            if !_storage._annotations.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._annotations,
                    fieldNumber: 7
                )
            }
            try { if let v = _storage._linux {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            } }()
            try { if let v = _storage._windows {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxConfig, rhs: Runtime_V1_PodSandboxConfig) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._metadata != rhs_storage._metadata { return false }
                if _storage._hostname != rhs_storage._hostname { return false }
                if _storage._logDirectory != rhs_storage._logDirectory { return false }
                if _storage._dnsConfig != rhs_storage._dnsConfig { return false }
                if _storage._portMappings != rhs_storage._portMappings { return false }
                if _storage._labels != rhs_storage._labels { return false }
                if _storage._annotations != rhs_storage._annotations { return false }
                if _storage._linux != rhs_storage._linux { return false }
                if _storage._windows != rhs_storage._windows { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RunPodSandboxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RunPodSandboxRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "config"),
        2: .standard(proto: "runtime_handler"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_config)
            case 2: try try decoder.decodeSingularStringField(value: &runtimeHandler)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._config {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !runtimeHandler.isEmpty {
            try visitor.visitSingularStringField(value: runtimeHandler, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RunPodSandboxRequest, rhs: Runtime_V1_RunPodSandboxRequest) -> Bool {
        if lhs._config != rhs._config { return false }
        if lhs.runtimeHandler != rhs.runtimeHandler { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RunPodSandboxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RunPodSandboxResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_sandbox_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podSandboxID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RunPodSandboxResponse, rhs: Runtime_V1_RunPodSandboxResponse) -> Bool {
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_StopPodSandboxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopPodSandboxRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_sandbox_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podSandboxID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_StopPodSandboxRequest, rhs: Runtime_V1_StopPodSandboxRequest) -> Bool {
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_StopPodSandboxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopPodSandboxResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_StopPodSandboxResponse, rhs: Runtime_V1_StopPodSandboxResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RemovePodSandboxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemovePodSandboxRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_sandbox_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podSandboxID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RemovePodSandboxRequest, rhs: Runtime_V1_RemovePodSandboxRequest) -> Bool {
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RemovePodSandboxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemovePodSandboxResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RemovePodSandboxResponse, rhs: Runtime_V1_RemovePodSandboxResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxStatusRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_sandbox_id"),
        2: .same(proto: "verbose"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podSandboxID)
            case 2: try try decoder.decodeSingularBoolField(value: &verbose)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 1)
        }
        if verbose != false {
            try visitor.visitSingularBoolField(value: verbose, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxStatusRequest, rhs: Runtime_V1_PodSandboxStatusRequest) -> Bool {
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.verbose != rhs.verbose { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodIP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodIP"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ip"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &ip)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ip.isEmpty {
            try visitor.visitSingularStringField(value: ip, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodIP, rhs: Runtime_V1_PodIP) -> Bool {
        if lhs.ip != rhs.ip { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxNetworkStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxNetworkStatus"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ip"),
        2: .standard(proto: "additional_ips"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &ip)
            case 2: try try decoder.decodeRepeatedMessageField(value: &additionalIps)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ip.isEmpty {
            try visitor.visitSingularStringField(value: ip, fieldNumber: 1)
        }
        if !additionalIps.isEmpty {
            try visitor.visitRepeatedMessageField(value: additionalIps, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxNetworkStatus, rhs: Runtime_V1_PodSandboxNetworkStatus) -> Bool {
        if lhs.ip != rhs.ip { return false }
        if lhs.additionalIps != rhs.additionalIps { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_Namespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Namespace"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "options"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_Namespace, rhs: Runtime_V1_Namespace) -> Bool {
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_LinuxPodSandboxStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxPodSandboxStatus"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "namespaces"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_namespaces)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._namespaces {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_LinuxPodSandboxStatus, rhs: Runtime_V1_LinuxPodSandboxStatus) -> Bool {
        if lhs._namespaces != rhs._namespaces { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxStatus"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .same(proto: "state"),
        4: .standard(proto: "created_at"),
        5: .same(proto: "network"),
        6: .same(proto: "linux"),
        7: .same(proto: "labels"),
        8: .same(proto: "annotations"),
        9: .standard(proto: "runtime_handler"),
    ]

    fileprivate class _StorageClass {
        var _id: String = .init()
        var _metadata: Runtime_V1_PodSandboxMetadata?
        var _state: Runtime_V1_PodSandboxState = .sandboxReady
        var _createdAt: Int64 = 0
        var _network: Runtime_V1_PodSandboxNetworkStatus?
        var _linux: Runtime_V1_LinuxPodSandboxStatus?
        var _labels: [String: String] = [:]
        var _annotations: [String: String] = [:]
        var _runtimeHandler: String = .init()

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _id = source._id
            _metadata = source._metadata
            _state = source._state
            _createdAt = source._createdAt
            _network = source._network
            _linux = source._linux
            _labels = source._labels
            _annotations = source._annotations
            _runtimeHandler = source._runtimeHandler
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularStringField(value: &_storage._id)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._metadata)
                case 3: try try decoder.decodeSingularEnumField(value: &_storage._state)
                case 4: try try decoder.decodeSingularInt64Field(value: &_storage._createdAt)
                case 5: try try decoder.decodeSingularMessageField(value: &_storage._network)
                case 6: try try decoder.decodeSingularMessageField(value: &_storage._linux)
                case 7: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._labels
                    ) }()
                case 8: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._annotations
                    ) }()
                case 9: try try decoder.decodeSingularStringField(value: &_storage._runtimeHandler)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._id.isEmpty {
                try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
            }
            try { if let v = _storage._metadata {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            if _storage._state != .sandboxReady {
                try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
            }
            if _storage._createdAt != 0 {
                try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 4)
            }
            try { if let v = _storage._network {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            } }()
            try { if let v = _storage._linux {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            } }()
            if !_storage._labels.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._labels,
                    fieldNumber: 7
                )
            }
            if !_storage._annotations.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._annotations,
                    fieldNumber: 8
                )
            }
            if !_storage._runtimeHandler.isEmpty {
                try visitor.visitSingularStringField(value: _storage._runtimeHandler, fieldNumber: 9)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxStatus, rhs: Runtime_V1_PodSandboxStatus) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._id != rhs_storage._id { return false }
                if _storage._metadata != rhs_storage._metadata { return false }
                if _storage._state != rhs_storage._state { return false }
                if _storage._createdAt != rhs_storage._createdAt { return false }
                if _storage._network != rhs_storage._network { return false }
                if _storage._linux != rhs_storage._linux { return false }
                if _storage._labels != rhs_storage._labels { return false }
                if _storage._annotations != rhs_storage._annotations { return false }
                if _storage._runtimeHandler != rhs_storage._runtimeHandler { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxStatusResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .same(proto: "info"),
        3: .standard(proto: "containers_statuses"),
        4: .same(proto: "timestamp"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_status)
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.info
                ) }()
            case 3: try try decoder.decodeRepeatedMessageField(value: &containersStatuses)
            case 4: try try decoder.decodeSingularInt64Field(value: &timestamp)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._status {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !info.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: info,
                fieldNumber: 2
            )
        }
        if !containersStatuses.isEmpty {
            try visitor.visitRepeatedMessageField(value: containersStatuses, fieldNumber: 3)
        }
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxStatusResponse, rhs: Runtime_V1_PodSandboxStatusResponse) -> Bool {
        if lhs._status != rhs._status { return false }
        if lhs.info != rhs.info { return false }
        if lhs.containersStatuses != rhs.containersStatuses { return false }
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxStateValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxStateValue"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "state"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &state)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if state != .sandboxReady {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxStateValue, rhs: Runtime_V1_PodSandboxStateValue) -> Bool {
        if lhs.state != rhs.state { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxFilter"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "state"),
        3: .standard(proto: "label_selector"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularMessageField(value: &_state)
            case 3: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.labelSelector
                ) }()
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try { if let v = self._state {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !labelSelector.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: labelSelector,
                fieldNumber: 3
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxFilter, rhs: Runtime_V1_PodSandboxFilter) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs._state != rhs._state { return false }
        if lhs.labelSelector != rhs.labelSelector { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListPodSandboxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListPodSandboxRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "filter"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_filter)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._filter {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListPodSandboxRequest, rhs: Runtime_V1_ListPodSandboxRequest) -> Bool {
        if lhs._filter != rhs._filter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandbox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandbox"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .same(proto: "state"),
        4: .standard(proto: "created_at"),
        5: .same(proto: "labels"),
        6: .same(proto: "annotations"),
        7: .standard(proto: "runtime_handler"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularMessageField(value: &_metadata)
            case 3: try try decoder.decodeSingularEnumField(value: &state)
            case 4: try try decoder.decodeSingularInt64Field(value: &createdAt)
            case 5: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.labels
                ) }()
            case 6: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.annotations
                ) }()
            case 7: try try decoder.decodeSingularStringField(value: &runtimeHandler)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try { if let v = self._metadata {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if state != .sandboxReady {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 3)
        }
        if createdAt != 0 {
            try visitor.visitSingularInt64Field(value: createdAt, fieldNumber: 4)
        }
        if !labels.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: labels,
                fieldNumber: 5
            )
        }
        if !annotations.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: annotations,
                fieldNumber: 6
            )
        }
        if !runtimeHandler.isEmpty {
            try visitor.visitSingularStringField(value: runtimeHandler, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandbox, rhs: Runtime_V1_PodSandbox) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs._metadata != rhs._metadata { return false }
        if lhs.state != rhs.state { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs.labels != rhs.labels { return false }
        if lhs.annotations != rhs.annotations { return false }
        if lhs.runtimeHandler != rhs.runtimeHandler { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListPodSandboxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListPodSandboxResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "items"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &items)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !items.isEmpty {
            try visitor.visitRepeatedMessageField(value: items, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListPodSandboxResponse, rhs: Runtime_V1_ListPodSandboxResponse) -> Bool {
        if lhs.items != rhs.items { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_sandbox_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podSandboxID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxStatsRequest, rhs: Runtime_V1_PodSandboxStatsRequest) -> Bool {
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxStatsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stats"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_stats)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._stats {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxStatsResponse, rhs: Runtime_V1_PodSandboxStatsResponse) -> Bool {
        if lhs._stats != rhs._stats { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxStatsFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxStatsFilter"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "label_selector"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.labelSelector
                ) }()
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !labelSelector.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: labelSelector,
                fieldNumber: 2
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxStatsFilter, rhs: Runtime_V1_PodSandboxStatsFilter) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.labelSelector != rhs.labelSelector { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListPodSandboxStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListPodSandboxStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "filter"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_filter)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._filter {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListPodSandboxStatsRequest, rhs: Runtime_V1_ListPodSandboxStatsRequest) -> Bool {
        if lhs._filter != rhs._filter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListPodSandboxStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListPodSandboxStatsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stats"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &stats)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !stats.isEmpty {
            try visitor.visitRepeatedMessageField(value: stats, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListPodSandboxStatsResponse, rhs: Runtime_V1_ListPodSandboxStatsResponse) -> Bool {
        if lhs.stats != rhs.stats { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxAttributes"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .same(proto: "labels"),
        4: .same(proto: "annotations"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularMessageField(value: &_metadata)
            case 3: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.labels
                ) }()
            case 4: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.annotations
                ) }()
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try { if let v = self._metadata {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !labels.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: labels,
                fieldNumber: 3
            )
        }
        if !annotations.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: annotations,
                fieldNumber: 4
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxAttributes, rhs: Runtime_V1_PodSandboxAttributes) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs._metadata != rhs._metadata { return false }
        if lhs.labels != rhs.labels { return false }
        if lhs.annotations != rhs.annotations { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxStats"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "attributes"),
        2: .same(proto: "linux"),
        3: .same(proto: "windows"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_attributes)
            case 2: try try decoder.decodeSingularMessageField(value: &_linux)
            case 3: try try decoder.decodeSingularMessageField(value: &_windows)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._attributes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._linux {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._windows {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxStats, rhs: Runtime_V1_PodSandboxStats) -> Bool {
        if lhs._attributes != rhs._attributes { return false }
        if lhs._linux != rhs._linux { return false }
        if lhs._windows != rhs._windows { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_LinuxPodSandboxStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxPodSandboxStats"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "cpu"),
        2: .same(proto: "memory"),
        3: .same(proto: "network"),
        4: .same(proto: "process"),
        5: .same(proto: "containers"),
    ]

    fileprivate class _StorageClass {
        var _cpu: Runtime_V1_CpuUsage?
        var _memory: Runtime_V1_MemoryUsage?
        var _network: Runtime_V1_NetworkUsage?
        var _process: Runtime_V1_ProcessUsage?
        var _containers: [Runtime_V1_ContainerStats] = []

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _cpu = source._cpu
            _memory = source._memory
            _network = source._network
            _process = source._process
            _containers = source._containers
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularMessageField(value: &_storage._cpu)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._memory)
                case 3: try try decoder.decodeSingularMessageField(value: &_storage._network)
                case 4: try try decoder.decodeSingularMessageField(value: &_storage._process)
                case 5: try try decoder.decodeRepeatedMessageField(value: &_storage._containers)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._cpu {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._memory {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            try { if let v = _storage._network {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            try { if let v = _storage._process {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            } }()
            if !_storage._containers.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._containers, fieldNumber: 5)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_LinuxPodSandboxStats, rhs: Runtime_V1_LinuxPodSandboxStats) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._cpu != rhs_storage._cpu { return false }
                if _storage._memory != rhs_storage._memory { return false }
                if _storage._network != rhs_storage._network { return false }
                if _storage._process != rhs_storage._process { return false }
                if _storage._containers != rhs_storage._containers { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsPodSandboxStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsPodSandboxStats"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "cpu"),
        2: .same(proto: "memory"),
        3: .same(proto: "network"),
        4: .same(proto: "process"),
        5: .same(proto: "containers"),
    ]

    fileprivate class _StorageClass {
        var _cpu: Runtime_V1_WindowsCpuUsage?
        var _memory: Runtime_V1_WindowsMemoryUsage?
        var _network: Runtime_V1_WindowsNetworkUsage?
        var _process: Runtime_V1_WindowsProcessUsage?
        var _containers: [Runtime_V1_WindowsContainerStats] = []

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _cpu = source._cpu
            _memory = source._memory
            _network = source._network
            _process = source._process
            _containers = source._containers
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularMessageField(value: &_storage._cpu)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._memory)
                case 3: try try decoder.decodeSingularMessageField(value: &_storage._network)
                case 4: try try decoder.decodeSingularMessageField(value: &_storage._process)
                case 5: try try decoder.decodeRepeatedMessageField(value: &_storage._containers)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._cpu {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._memory {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            try { if let v = _storage._network {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            try { if let v = _storage._process {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            } }()
            if !_storage._containers.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._containers, fieldNumber: 5)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsPodSandboxStats, rhs: Runtime_V1_WindowsPodSandboxStats) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._cpu != rhs_storage._cpu { return false }
                if _storage._memory != rhs_storage._memory { return false }
                if _storage._network != rhs_storage._network { return false }
                if _storage._process != rhs_storage._process { return false }
                if _storage._containers != rhs_storage._containers { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_NetworkUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".NetworkUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "default_interface"),
        3: .same(proto: "interfaces"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_defaultInterface)
            case 3: try try decoder.decodeRepeatedMessageField(value: &interfaces)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._defaultInterface {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !interfaces.isEmpty {
            try visitor.visitRepeatedMessageField(value: interfaces, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_NetworkUsage, rhs: Runtime_V1_NetworkUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._defaultInterface != rhs._defaultInterface { return false }
        if lhs.interfaces != rhs.interfaces { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsNetworkUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsNetworkUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "default_interface"),
        3: .same(proto: "interfaces"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_defaultInterface)
            case 3: try try decoder.decodeRepeatedMessageField(value: &interfaces)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._defaultInterface {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !interfaces.isEmpty {
            try visitor.visitRepeatedMessageField(value: interfaces, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsNetworkUsage, rhs: Runtime_V1_WindowsNetworkUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._defaultInterface != rhs._defaultInterface { return false }
        if lhs.interfaces != rhs.interfaces { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_NetworkInterfaceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".NetworkInterfaceUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .standard(proto: "rx_bytes"),
        3: .standard(proto: "rx_errors"),
        4: .standard(proto: "tx_bytes"),
        5: .standard(proto: "tx_errors"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularMessageField(value: &_rxBytes)
            case 3: try try decoder.decodeSingularMessageField(value: &_rxErrors)
            case 4: try try decoder.decodeSingularMessageField(value: &_txBytes)
            case 5: try try decoder.decodeSingularMessageField(value: &_txErrors)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try { if let v = self._rxBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._rxErrors {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._txBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try { if let v = self._txErrors {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_NetworkInterfaceUsage, rhs: Runtime_V1_NetworkInterfaceUsage) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs._rxBytes != rhs._rxBytes { return false }
        if lhs._rxErrors != rhs._rxErrors { return false }
        if lhs._txBytes != rhs._txBytes { return false }
        if lhs._txErrors != rhs._txErrors { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsNetworkInterfaceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsNetworkInterfaceUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .standard(proto: "rx_bytes"),
        3: .standard(proto: "rx_packets_dropped"),
        4: .standard(proto: "tx_bytes"),
        5: .standard(proto: "tx_packets_dropped"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularMessageField(value: &_rxBytes)
            case 3: try try decoder.decodeSingularMessageField(value: &_rxPacketsDropped)
            case 4: try try decoder.decodeSingularMessageField(value: &_txBytes)
            case 5: try try decoder.decodeSingularMessageField(value: &_txPacketsDropped)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try { if let v = self._rxBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._rxPacketsDropped {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._txBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try { if let v = self._txPacketsDropped {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_WindowsNetworkInterfaceUsage,
        rhs: Runtime_V1_WindowsNetworkInterfaceUsage
    ) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs._rxBytes != rhs._rxBytes { return false }
        if lhs._rxPacketsDropped != rhs._rxPacketsDropped { return false }
        if lhs._txBytes != rhs._txBytes { return false }
        if lhs._txPacketsDropped != rhs._txPacketsDropped { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ProcessUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ProcessUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "process_count"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_processCount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._processCount {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ProcessUsage, rhs: Runtime_V1_ProcessUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._processCount != rhs._processCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsProcessUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsProcessUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "process_count"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_processCount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._processCount {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsProcessUsage, rhs: Runtime_V1_WindowsProcessUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._processCount != rhs._processCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ImageSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImageSpec"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "image"),
        2: .same(proto: "annotations"),
        18: .standard(proto: "user_specified_image"),
        19: .standard(proto: "runtime_handler"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &image)
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.annotations
                ) }()
            case 18: try try decoder.decodeSingularStringField(value: &userSpecifiedImage)
            case 19: try try decoder.decodeSingularStringField(value: &runtimeHandler)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !image.isEmpty {
            try visitor.visitSingularStringField(value: image, fieldNumber: 1)
        }
        if !annotations.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: annotations,
                fieldNumber: 2
            )
        }
        if !userSpecifiedImage.isEmpty {
            try visitor.visitSingularStringField(value: userSpecifiedImage, fieldNumber: 18)
        }
        if !runtimeHandler.isEmpty {
            try visitor.visitSingularStringField(value: runtimeHandler, fieldNumber: 19)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ImageSpec, rhs: Runtime_V1_ImageSpec) -> Bool {
        if lhs.image != rhs.image { return false }
        if lhs.annotations != rhs.annotations { return false }
        if lhs.userSpecifiedImage != rhs.userSpecifiedImage { return false }
        if lhs.runtimeHandler != rhs.runtimeHandler { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_KeyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".KeyValue"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
        2: .same(proto: "value"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &key)
            case 2: try try decoder.decodeSingularStringField(value: &value)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        if !value.isEmpty {
            try visitor.visitSingularStringField(value: value, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_KeyValue, rhs: Runtime_V1_KeyValue) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_LinuxContainerResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxContainerResources"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cpu_period"),
        2: .standard(proto: "cpu_quota"),
        3: .standard(proto: "cpu_shares"),
        4: .standard(proto: "memory_limit_in_bytes"),
        5: .standard(proto: "oom_score_adj"),
        6: .standard(proto: "cpuset_cpus"),
        7: .standard(proto: "cpuset_mems"),
        8: .standard(proto: "hugepage_limits"),
        9: .same(proto: "unified"),
        10: .standard(proto: "memory_swap_limit_in_bytes"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &cpuPeriod)
            case 2: try try decoder.decodeSingularInt64Field(value: &cpuQuota)
            case 3: try try decoder.decodeSingularInt64Field(value: &cpuShares)
            case 4: try try decoder.decodeSingularInt64Field(value: &memoryLimitInBytes)
            case 5: try try decoder.decodeSingularInt64Field(value: &oomScoreAdj)
            case 6: try try decoder.decodeSingularStringField(value: &cpusetCpus)
            case 7: try try decoder.decodeSingularStringField(value: &cpusetMems)
            case 8: try try decoder.decodeRepeatedMessageField(value: &hugepageLimits)
            case 9: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.unified
                ) }()
            case 10: try try decoder.decodeSingularInt64Field(value: &memorySwapLimitInBytes)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if cpuPeriod != 0 {
            try visitor.visitSingularInt64Field(value: cpuPeriod, fieldNumber: 1)
        }
        if cpuQuota != 0 {
            try visitor.visitSingularInt64Field(value: cpuQuota, fieldNumber: 2)
        }
        if cpuShares != 0 {
            try visitor.visitSingularInt64Field(value: cpuShares, fieldNumber: 3)
        }
        if memoryLimitInBytes != 0 {
            try visitor.visitSingularInt64Field(value: memoryLimitInBytes, fieldNumber: 4)
        }
        if oomScoreAdj != 0 {
            try visitor.visitSingularInt64Field(value: oomScoreAdj, fieldNumber: 5)
        }
        if !cpusetCpus.isEmpty {
            try visitor.visitSingularStringField(value: cpusetCpus, fieldNumber: 6)
        }
        if !cpusetMems.isEmpty {
            try visitor.visitSingularStringField(value: cpusetMems, fieldNumber: 7)
        }
        if !hugepageLimits.isEmpty {
            try visitor.visitRepeatedMessageField(value: hugepageLimits, fieldNumber: 8)
        }
        if !unified.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: unified,
                fieldNumber: 9
            )
        }
        if memorySwapLimitInBytes != 0 {
            try visitor.visitSingularInt64Field(value: memorySwapLimitInBytes, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_LinuxContainerResources, rhs: Runtime_V1_LinuxContainerResources) -> Bool {
        if lhs.cpuPeriod != rhs.cpuPeriod { return false }
        if lhs.cpuQuota != rhs.cpuQuota { return false }
        if lhs.cpuShares != rhs.cpuShares { return false }
        if lhs.memoryLimitInBytes != rhs.memoryLimitInBytes { return false }
        if lhs.oomScoreAdj != rhs.oomScoreAdj { return false }
        if lhs.cpusetCpus != rhs.cpusetCpus { return false }
        if lhs.cpusetMems != rhs.cpusetMems { return false }
        if lhs.hugepageLimits != rhs.hugepageLimits { return false }
        if lhs.unified != rhs.unified { return false }
        if lhs.memorySwapLimitInBytes != rhs.memorySwapLimitInBytes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_HugepageLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HugepageLimit"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "page_size"),
        2: .same(proto: "limit"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &pageSize)
            case 2: try try decoder.decodeSingularUInt64Field(value: &limit)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !pageSize.isEmpty {
            try visitor.visitSingularStringField(value: pageSize, fieldNumber: 1)
        }
        if limit != 0 {
            try visitor.visitSingularUInt64Field(value: limit, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_HugepageLimit, rhs: Runtime_V1_HugepageLimit) -> Bool {
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.limit != rhs.limit { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_SELinuxOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SELinuxOption"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "user"),
        2: .same(proto: "role"),
        3: .same(proto: "type"),
        4: .same(proto: "level"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &user)
            case 2: try try decoder.decodeSingularStringField(value: &role)
            case 3: try try decoder.decodeSingularStringField(value: &type)
            case 4: try try decoder.decodeSingularStringField(value: &level)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !user.isEmpty {
            try visitor.visitSingularStringField(value: user, fieldNumber: 1)
        }
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 2)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 3)
        }
        if !level.isEmpty {
            try visitor.visitSingularStringField(value: level, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_SELinuxOption, rhs: Runtime_V1_SELinuxOption) -> Bool {
        if lhs.user != rhs.user { return false }
        if lhs.role != rhs.role { return false }
        if lhs.type != rhs.type { return false }
        if lhs.level != rhs.level { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_Capability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Capability"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "add_capabilities"),
        2: .standard(proto: "drop_capabilities"),
        3: .standard(proto: "add_ambient_capabilities"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedStringField(value: &addCapabilities)
            case 2: try try decoder.decodeRepeatedStringField(value: &dropCapabilities)
            case 3: try try decoder.decodeRepeatedStringField(value: &addAmbientCapabilities)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !addCapabilities.isEmpty {
            try visitor.visitRepeatedStringField(value: addCapabilities, fieldNumber: 1)
        }
        if !dropCapabilities.isEmpty {
            try visitor.visitRepeatedStringField(value: dropCapabilities, fieldNumber: 2)
        }
        if !addAmbientCapabilities.isEmpty {
            try visitor.visitRepeatedStringField(value: addAmbientCapabilities, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_Capability, rhs: Runtime_V1_Capability) -> Bool {
        if lhs.addCapabilities != rhs.addCapabilities { return false }
        if lhs.dropCapabilities != rhs.dropCapabilities { return false }
        if lhs.addAmbientCapabilities != rhs.addAmbientCapabilities { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_LinuxContainerSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxContainerSecurityContext"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "capabilities"),
        2: .same(proto: "privileged"),
        3: .standard(proto: "namespace_options"),
        4: .standard(proto: "selinux_options"),
        5: .standard(proto: "run_as_user"),
        12: .standard(proto: "run_as_group"),
        6: .standard(proto: "run_as_username"),
        7: .standard(proto: "readonly_rootfs"),
        8: .standard(proto: "supplemental_groups"),
        17: .standard(proto: "supplemental_groups_policy"),
        11: .standard(proto: "no_new_privs"),
        13: .standard(proto: "masked_paths"),
        14: .standard(proto: "readonly_paths"),
        15: .same(proto: "seccomp"),
        16: .same(proto: "apparmor"),
        9: .standard(proto: "apparmor_profile"),
        10: .standard(proto: "seccomp_profile_path"),
    ]

    fileprivate class _StorageClass {
        var _capabilities: Runtime_V1_Capability?
        var _privileged: Bool = false
        var _namespaceOptions: Runtime_V1_NamespaceOption?
        var _selinuxOptions: Runtime_V1_SELinuxOption?
        var _runAsUser: Runtime_V1_Int64Value?
        var _runAsGroup: Runtime_V1_Int64Value?
        var _runAsUsername: String = .init()
        var _readonlyRootfs: Bool = false
        var _supplementalGroups: [Int64] = []
        var _supplementalGroupsPolicy: Runtime_V1_SupplementalGroupsPolicy = .merge
        var _noNewPrivs: Bool = false
        var _maskedPaths: [String] = []
        var _readonlyPaths: [String] = []
        var _seccomp: Runtime_V1_SecurityProfile?
        var _apparmor: Runtime_V1_SecurityProfile?
        var _apparmorProfile: String = .init()
        var _seccompProfilePath: String = .init()

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _capabilities = source._capabilities
            _privileged = source._privileged
            _namespaceOptions = source._namespaceOptions
            _selinuxOptions = source._selinuxOptions
            _runAsUser = source._runAsUser
            _runAsGroup = source._runAsGroup
            _runAsUsername = source._runAsUsername
            _readonlyRootfs = source._readonlyRootfs
            _supplementalGroups = source._supplementalGroups
            _supplementalGroupsPolicy = source._supplementalGroupsPolicy
            _noNewPrivs = source._noNewPrivs
            _maskedPaths = source._maskedPaths
            _readonlyPaths = source._readonlyPaths
            _seccomp = source._seccomp
            _apparmor = source._apparmor
            _apparmorProfile = source._apparmorProfile
            _seccompProfilePath = source._seccompProfilePath
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularMessageField(value: &_storage._capabilities)
                case 2: try try decoder.decodeSingularBoolField(value: &_storage._privileged)
                case 3: try try decoder.decodeSingularMessageField(value: &_storage._namespaceOptions)
                case 4: try try decoder.decodeSingularMessageField(value: &_storage._selinuxOptions)
                case 5: try try decoder.decodeSingularMessageField(value: &_storage._runAsUser)
                case 6: try try decoder.decodeSingularStringField(value: &_storage._runAsUsername)
                case 7: try try decoder.decodeSingularBoolField(value: &_storage._readonlyRootfs)
                case 8: try try decoder.decodeRepeatedInt64Field(value: &_storage._supplementalGroups)
                case 9: try try decoder.decodeSingularStringField(value: &_storage._apparmorProfile)
                case 10: try try decoder.decodeSingularStringField(value: &_storage._seccompProfilePath)
                case 11: try try decoder.decodeSingularBoolField(value: &_storage._noNewPrivs)
                case 12: try try decoder.decodeSingularMessageField(value: &_storage._runAsGroup)
                case 13: try try decoder.decodeRepeatedStringField(value: &_storage._maskedPaths)
                case 14: try try decoder.decodeRepeatedStringField(value: &_storage._readonlyPaths)
                case 15: try try decoder.decodeSingularMessageField(value: &_storage._seccomp)
                case 16: try try decoder.decodeSingularMessageField(value: &_storage._apparmor)
                case 17: try try decoder.decodeSingularEnumField(value: &_storage._supplementalGroupsPolicy)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._capabilities {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if _storage._privileged != false {
                try visitor.visitSingularBoolField(value: _storage._privileged, fieldNumber: 2)
            }
            try { if let v = _storage._namespaceOptions {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            try { if let v = _storage._selinuxOptions {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            } }()
            try { if let v = _storage._runAsUser {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            } }()
            if !_storage._runAsUsername.isEmpty {
                try visitor.visitSingularStringField(value: _storage._runAsUsername, fieldNumber: 6)
            }
            if _storage._readonlyRootfs != false {
                try visitor.visitSingularBoolField(value: _storage._readonlyRootfs, fieldNumber: 7)
            }
            if !_storage._supplementalGroups.isEmpty {
                try visitor.visitPackedInt64Field(value: _storage._supplementalGroups, fieldNumber: 8)
            }
            if !_storage._apparmorProfile.isEmpty {
                try visitor.visitSingularStringField(value: _storage._apparmorProfile, fieldNumber: 9)
            }
            if !_storage._seccompProfilePath.isEmpty {
                try visitor.visitSingularStringField(value: _storage._seccompProfilePath, fieldNumber: 10)
            }
            if _storage._noNewPrivs != false {
                try visitor.visitSingularBoolField(value: _storage._noNewPrivs, fieldNumber: 11)
            }
            try { if let v = _storage._runAsGroup {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            } }()
            if !_storage._maskedPaths.isEmpty {
                try visitor.visitRepeatedStringField(value: _storage._maskedPaths, fieldNumber: 13)
            }
            if !_storage._readonlyPaths.isEmpty {
                try visitor.visitRepeatedStringField(value: _storage._readonlyPaths, fieldNumber: 14)
            }
            try { if let v = _storage._seccomp {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            } }()
            try { if let v = _storage._apparmor {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
            } }()
            if _storage._supplementalGroupsPolicy != .merge {
                try visitor.visitSingularEnumField(value: _storage._supplementalGroupsPolicy, fieldNumber: 17)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_LinuxContainerSecurityContext,
        rhs: Runtime_V1_LinuxContainerSecurityContext
    ) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._capabilities != rhs_storage._capabilities { return false }
                if _storage._privileged != rhs_storage._privileged { return false }
                if _storage._namespaceOptions != rhs_storage._namespaceOptions { return false }
                if _storage._selinuxOptions != rhs_storage._selinuxOptions { return false }
                if _storage._runAsUser != rhs_storage._runAsUser { return false }
                if _storage._runAsGroup != rhs_storage._runAsGroup { return false }
                if _storage._runAsUsername != rhs_storage._runAsUsername { return false }
                if _storage._readonlyRootfs != rhs_storage._readonlyRootfs { return false }
                if _storage._supplementalGroups != rhs_storage._supplementalGroups { return false }
                if _storage._supplementalGroupsPolicy != rhs_storage._supplementalGroupsPolicy { return false }
                if _storage._noNewPrivs != rhs_storage._noNewPrivs { return false }
                if _storage._maskedPaths != rhs_storage._maskedPaths { return false }
                if _storage._readonlyPaths != rhs_storage._readonlyPaths { return false }
                if _storage._seccomp != rhs_storage._seccomp { return false }
                if _storage._apparmor != rhs_storage._apparmor { return false }
                if _storage._apparmorProfile != rhs_storage._apparmorProfile { return false }
                if _storage._seccompProfilePath != rhs_storage._seccompProfilePath { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_LinuxContainerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxContainerConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "resources"),
        2: .standard(proto: "security_context"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_resources)
            case 2: try try decoder.decodeSingularMessageField(value: &_securityContext)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._resources {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._securityContext {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_LinuxContainerConfig, rhs: Runtime_V1_LinuxContainerConfig) -> Bool {
        if lhs._resources != rhs._resources { return false }
        if lhs._securityContext != rhs._securityContext { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_LinuxContainerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxContainerUser"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "uid"),
        2: .same(proto: "gid"),
        3: .standard(proto: "supplemental_groups"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &uid)
            case 2: try try decoder.decodeSingularInt64Field(value: &gid)
            case 3: try try decoder.decodeRepeatedInt64Field(value: &supplementalGroups)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if uid != 0 {
            try visitor.visitSingularInt64Field(value: uid, fieldNumber: 1)
        }
        if gid != 0 {
            try visitor.visitSingularInt64Field(value: gid, fieldNumber: 2)
        }
        if !supplementalGroups.isEmpty {
            try visitor.visitPackedInt64Field(value: supplementalGroups, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_LinuxContainerUser, rhs: Runtime_V1_LinuxContainerUser) -> Bool {
        if lhs.uid != rhs.uid { return false }
        if lhs.gid != rhs.gid { return false }
        if lhs.supplementalGroups != rhs.supplementalGroups { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsNamespaceOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsNamespaceOption"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "network"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &network)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if network != .pod {
            try visitor.visitSingularEnumField(value: network, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsNamespaceOption, rhs: Runtime_V1_WindowsNamespaceOption) -> Bool {
        if lhs.network != rhs.network { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsSandboxSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsSandboxSecurityContext"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "run_as_username"),
        2: .standard(proto: "credential_spec"),
        3: .standard(proto: "host_process"),
        4: .standard(proto: "namespace_options"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &runAsUsername)
            case 2: try try decoder.decodeSingularStringField(value: &credentialSpec)
            case 3: try try decoder.decodeSingularBoolField(value: &hostProcess)
            case 4: try try decoder.decodeSingularMessageField(value: &_namespaceOptions)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !runAsUsername.isEmpty {
            try visitor.visitSingularStringField(value: runAsUsername, fieldNumber: 1)
        }
        if !credentialSpec.isEmpty {
            try visitor.visitSingularStringField(value: credentialSpec, fieldNumber: 2)
        }
        if hostProcess != false {
            try visitor.visitSingularBoolField(value: hostProcess, fieldNumber: 3)
        }
        try { if let v = self._namespaceOptions {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_WindowsSandboxSecurityContext,
        rhs: Runtime_V1_WindowsSandboxSecurityContext
    ) -> Bool {
        if lhs.runAsUsername != rhs.runAsUsername { return false }
        if lhs.credentialSpec != rhs.credentialSpec { return false }
        if lhs.hostProcess != rhs.hostProcess { return false }
        if lhs._namespaceOptions != rhs._namespaceOptions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsPodSandboxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsPodSandboxConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "security_context"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_securityContext)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._securityContext {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsPodSandboxConfig, rhs: Runtime_V1_WindowsPodSandboxConfig) -> Bool {
        if lhs._securityContext != rhs._securityContext { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsContainerSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsContainerSecurityContext"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "run_as_username"),
        2: .standard(proto: "credential_spec"),
        3: .standard(proto: "host_process"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &runAsUsername)
            case 2: try try decoder.decodeSingularStringField(value: &credentialSpec)
            case 3: try try decoder.decodeSingularBoolField(value: &hostProcess)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !runAsUsername.isEmpty {
            try visitor.visitSingularStringField(value: runAsUsername, fieldNumber: 1)
        }
        if !credentialSpec.isEmpty {
            try visitor.visitSingularStringField(value: credentialSpec, fieldNumber: 2)
        }
        if hostProcess != false {
            try visitor.visitSingularBoolField(value: hostProcess, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_WindowsContainerSecurityContext,
        rhs: Runtime_V1_WindowsContainerSecurityContext
    ) -> Bool {
        if lhs.runAsUsername != rhs.runAsUsername { return false }
        if lhs.credentialSpec != rhs.credentialSpec { return false }
        if lhs.hostProcess != rhs.hostProcess { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsContainerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsContainerConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "resources"),
        2: .standard(proto: "security_context"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_resources)
            case 2: try try decoder.decodeSingularMessageField(value: &_securityContext)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._resources {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._securityContext {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsContainerConfig, rhs: Runtime_V1_WindowsContainerConfig) -> Bool {
        if lhs._resources != rhs._resources { return false }
        if lhs._securityContext != rhs._securityContext { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsContainerResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsContainerResources"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cpu_shares"),
        2: .standard(proto: "cpu_count"),
        3: .standard(proto: "cpu_maximum"),
        4: .standard(proto: "memory_limit_in_bytes"),
        5: .standard(proto: "rootfs_size_in_bytes"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &cpuShares)
            case 2: try try decoder.decodeSingularInt64Field(value: &cpuCount)
            case 3: try try decoder.decodeSingularInt64Field(value: &cpuMaximum)
            case 4: try try decoder.decodeSingularInt64Field(value: &memoryLimitInBytes)
            case 5: try try decoder.decodeSingularInt64Field(value: &rootfsSizeInBytes)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if cpuShares != 0 {
            try visitor.visitSingularInt64Field(value: cpuShares, fieldNumber: 1)
        }
        if cpuCount != 0 {
            try visitor.visitSingularInt64Field(value: cpuCount, fieldNumber: 2)
        }
        if cpuMaximum != 0 {
            try visitor.visitSingularInt64Field(value: cpuMaximum, fieldNumber: 3)
        }
        if memoryLimitInBytes != 0 {
            try visitor.visitSingularInt64Field(value: memoryLimitInBytes, fieldNumber: 4)
        }
        if rootfsSizeInBytes != 0 {
            try visitor.visitSingularInt64Field(value: rootfsSizeInBytes, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsContainerResources, rhs: Runtime_V1_WindowsContainerResources) -> Bool {
        if lhs.cpuShares != rhs.cpuShares { return false }
        if lhs.cpuCount != rhs.cpuCount { return false }
        if lhs.cpuMaximum != rhs.cpuMaximum { return false }
        if lhs.memoryLimitInBytes != rhs.memoryLimitInBytes { return false }
        if lhs.rootfsSizeInBytes != rhs.rootfsSizeInBytes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerMetadata"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "attempt"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularUInt32Field(value: &attempt)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if attempt != 0 {
            try visitor.visitSingularUInt32Field(value: attempt, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerMetadata, rhs: Runtime_V1_ContainerMetadata) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.attempt != rhs.attempt { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Device"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_path"),
        2: .standard(proto: "host_path"),
        3: .same(proto: "permissions"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerPath)
            case 2: try try decoder.decodeSingularStringField(value: &hostPath)
            case 3: try try decoder.decodeSingularStringField(value: &permissions)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerPath.isEmpty {
            try visitor.visitSingularStringField(value: containerPath, fieldNumber: 1)
        }
        if !hostPath.isEmpty {
            try visitor.visitSingularStringField(value: hostPath, fieldNumber: 2)
        }
        if !permissions.isEmpty {
            try visitor.visitSingularStringField(value: permissions, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_Device, rhs: Runtime_V1_Device) -> Bool {
        if lhs.containerPath != rhs.containerPath { return false }
        if lhs.hostPath != rhs.hostPath { return false }
        if lhs.permissions != rhs.permissions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_CDIDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CDIDevice"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_CDIDevice, rhs: Runtime_V1_CDIDevice) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "metadata"),
        2: .same(proto: "image"),
        3: .same(proto: "command"),
        4: .same(proto: "args"),
        5: .standard(proto: "working_dir"),
        6: .same(proto: "envs"),
        7: .same(proto: "mounts"),
        8: .same(proto: "devices"),
        9: .same(proto: "labels"),
        10: .same(proto: "annotations"),
        11: .standard(proto: "log_path"),
        12: .same(proto: "stdin"),
        13: .standard(proto: "stdin_once"),
        14: .same(proto: "tty"),
        15: .same(proto: "linux"),
        16: .same(proto: "windows"),
        17: .standard(proto: "CDI_devices"),
    ]

    fileprivate class _StorageClass {
        var _metadata: Runtime_V1_ContainerMetadata?
        var _image: Runtime_V1_ImageSpec?
        var _command: [String] = []
        var _args: [String] = []
        var _workingDir: String = .init()
        var _envs: [Runtime_V1_KeyValue] = []
        var _mounts: [Runtime_V1_Mount] = []
        var _devices: [Runtime_V1_Device] = []
        var _labels: [String: String] = [:]
        var _annotations: [String: String] = [:]
        var _logPath: String = .init()
        var _stdin: Bool = false
        var _stdinOnce: Bool = false
        var _tty: Bool = false
        var _linux: Runtime_V1_LinuxContainerConfig?
        var _windows: Runtime_V1_WindowsContainerConfig?
        var _cdiDevices: [Runtime_V1_CDIDevice] = []

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _metadata = source._metadata
            _image = source._image
            _command = source._command
            _args = source._args
            _workingDir = source._workingDir
            _envs = source._envs
            _mounts = source._mounts
            _devices = source._devices
            _labels = source._labels
            _annotations = source._annotations
            _logPath = source._logPath
            _stdin = source._stdin
            _stdinOnce = source._stdinOnce
            _tty = source._tty
            _linux = source._linux
            _windows = source._windows
            _cdiDevices = source._cdiDevices
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularMessageField(value: &_storage._metadata)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._image)
                case 3: try try decoder.decodeRepeatedStringField(value: &_storage._command)
                case 4: try try decoder.decodeRepeatedStringField(value: &_storage._args)
                case 5: try try decoder.decodeSingularStringField(value: &_storage._workingDir)
                case 6: try try decoder.decodeRepeatedMessageField(value: &_storage._envs)
                case 7: try try decoder.decodeRepeatedMessageField(value: &_storage._mounts)
                case 8: try try decoder.decodeRepeatedMessageField(value: &_storage._devices)
                case 9: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._labels
                    ) }()
                case 10: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._annotations
                    ) }()
                case 11: try try decoder.decodeSingularStringField(value: &_storage._logPath)
                case 12: try try decoder.decodeSingularBoolField(value: &_storage._stdin)
                case 13: try try decoder.decodeSingularBoolField(value: &_storage._stdinOnce)
                case 14: try try decoder.decodeSingularBoolField(value: &_storage._tty)
                case 15: try try decoder.decodeSingularMessageField(value: &_storage._linux)
                case 16: try try decoder.decodeSingularMessageField(value: &_storage._windows)
                case 17: try try decoder.decodeRepeatedMessageField(value: &_storage._cdiDevices)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._metadata {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._image {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            if !_storage._command.isEmpty {
                try visitor.visitRepeatedStringField(value: _storage._command, fieldNumber: 3)
            }
            if !_storage._args.isEmpty {
                try visitor.visitRepeatedStringField(value: _storage._args, fieldNumber: 4)
            }
            if !_storage._workingDir.isEmpty {
                try visitor.visitSingularStringField(value: _storage._workingDir, fieldNumber: 5)
            }
            if !_storage._envs.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._envs, fieldNumber: 6)
            }
            if !_storage._mounts.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._mounts, fieldNumber: 7)
            }
            if !_storage._devices.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._devices, fieldNumber: 8)
            }
            if !_storage._labels.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._labels,
                    fieldNumber: 9
                )
            }
            if !_storage._annotations.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._annotations,
                    fieldNumber: 10
                )
            }
            if !_storage._logPath.isEmpty {
                try visitor.visitSingularStringField(value: _storage._logPath, fieldNumber: 11)
            }
            if _storage._stdin != false {
                try visitor.visitSingularBoolField(value: _storage._stdin, fieldNumber: 12)
            }
            if _storage._stdinOnce != false {
                try visitor.visitSingularBoolField(value: _storage._stdinOnce, fieldNumber: 13)
            }
            if _storage._tty != false {
                try visitor.visitSingularBoolField(value: _storage._tty, fieldNumber: 14)
            }
            try { if let v = _storage._linux {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            } }()
            try { if let v = _storage._windows {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
            } }()
            if !_storage._cdiDevices.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._cdiDevices, fieldNumber: 17)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerConfig, rhs: Runtime_V1_ContainerConfig) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._metadata != rhs_storage._metadata { return false }
                if _storage._image != rhs_storage._image { return false }
                if _storage._command != rhs_storage._command { return false }
                if _storage._args != rhs_storage._args { return false }
                if _storage._workingDir != rhs_storage._workingDir { return false }
                if _storage._envs != rhs_storage._envs { return false }
                if _storage._mounts != rhs_storage._mounts { return false }
                if _storage._devices != rhs_storage._devices { return false }
                if _storage._labels != rhs_storage._labels { return false }
                if _storage._annotations != rhs_storage._annotations { return false }
                if _storage._logPath != rhs_storage._logPath { return false }
                if _storage._stdin != rhs_storage._stdin { return false }
                if _storage._stdinOnce != rhs_storage._stdinOnce { return false }
                if _storage._tty != rhs_storage._tty { return false }
                if _storage._linux != rhs_storage._linux { return false }
                if _storage._windows != rhs_storage._windows { return false }
                if _storage._cdiDevices != rhs_storage._cdiDevices { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_CreateContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateContainerRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_sandbox_id"),
        2: .same(proto: "config"),
        3: .standard(proto: "sandbox_config"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podSandboxID)
            case 2: try try decoder.decodeSingularMessageField(value: &_config)
            case 3: try try decoder.decodeSingularMessageField(value: &_sandboxConfig)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 1)
        }
        try { if let v = self._config {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._sandboxConfig {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_CreateContainerRequest, rhs: Runtime_V1_CreateContainerRequest) -> Bool {
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs._config != rhs._config { return false }
        if lhs._sandboxConfig != rhs._sandboxConfig { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_CreateContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateContainerResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_CreateContainerResponse, rhs: Runtime_V1_CreateContainerResponse) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_StartContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartContainerRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_StartContainerRequest, rhs: Runtime_V1_StartContainerRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_StartContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartContainerResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_StartContainerResponse, rhs: Runtime_V1_StartContainerResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_StopContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopContainerRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .same(proto: "timeout"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            case 2: try try decoder.decodeSingularInt64Field(value: &timeout)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        if timeout != 0 {
            try visitor.visitSingularInt64Field(value: timeout, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_StopContainerRequest, rhs: Runtime_V1_StopContainerRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_StopContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopContainerResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_StopContainerResponse, rhs: Runtime_V1_StopContainerResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RemoveContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemoveContainerRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RemoveContainerRequest, rhs: Runtime_V1_RemoveContainerRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RemoveContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemoveContainerResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RemoveContainerResponse, rhs: Runtime_V1_RemoveContainerResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerStateValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerStateValue"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "state"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &state)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if state != .containerCreated {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerStateValue, rhs: Runtime_V1_ContainerStateValue) -> Bool {
        if lhs.state != rhs.state { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerFilter"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "state"),
        3: .standard(proto: "pod_sandbox_id"),
        4: .standard(proto: "label_selector"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularMessageField(value: &_state)
            case 3: try try decoder.decodeSingularStringField(value: &podSandboxID)
            case 4: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.labelSelector
                ) }()
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try { if let v = self._state {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 3)
        }
        if !labelSelector.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: labelSelector,
                fieldNumber: 4
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerFilter, rhs: Runtime_V1_ContainerFilter) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs._state != rhs._state { return false }
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.labelSelector != rhs.labelSelector { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListContainersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListContainersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "filter"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_filter)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._filter {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListContainersRequest, rhs: Runtime_V1_ListContainersRequest) -> Bool {
        if lhs._filter != rhs._filter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_Container: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Container"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "pod_sandbox_id"),
        3: .same(proto: "metadata"),
        4: .same(proto: "image"),
        5: .standard(proto: "image_ref"),
        6: .same(proto: "state"),
        7: .standard(proto: "created_at"),
        8: .same(proto: "labels"),
        9: .same(proto: "annotations"),
        10: .standard(proto: "image_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &podSandboxID)
            case 3: try try decoder.decodeSingularMessageField(value: &_metadata)
            case 4: try try decoder.decodeSingularMessageField(value: &_image)
            case 5: try try decoder.decodeSingularStringField(value: &imageRef)
            case 6: try try decoder.decodeSingularEnumField(value: &state)
            case 7: try try decoder.decodeSingularInt64Field(value: &createdAt)
            case 8: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.labels
                ) }()
            case 9: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.annotations
                ) }()
            case 10: try try decoder.decodeSingularStringField(value: &imageID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 2)
        }
        try { if let v = self._metadata {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._image {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if !imageRef.isEmpty {
            try visitor.visitSingularStringField(value: imageRef, fieldNumber: 5)
        }
        if state != .containerCreated {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 6)
        }
        if createdAt != 0 {
            try visitor.visitSingularInt64Field(value: createdAt, fieldNumber: 7)
        }
        if !labels.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: labels,
                fieldNumber: 8
            )
        }
        if !annotations.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: annotations,
                fieldNumber: 9
            )
        }
        if !imageID.isEmpty {
            try visitor.visitSingularStringField(value: imageID, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_Container, rhs: Runtime_V1_Container) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs._metadata != rhs._metadata { return false }
        if lhs._image != rhs._image { return false }
        if lhs.imageRef != rhs.imageRef { return false }
        if lhs.state != rhs.state { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs.labels != rhs.labels { return false }
        if lhs.annotations != rhs.annotations { return false }
        if lhs.imageID != rhs.imageID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListContainersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListContainersResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "containers"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &containers)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containers.isEmpty {
            try visitor.visitRepeatedMessageField(value: containers, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListContainersResponse, rhs: Runtime_V1_ListContainersResponse) -> Bool {
        if lhs.containers != rhs.containers { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerStatusRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .same(proto: "verbose"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            case 2: try try decoder.decodeSingularBoolField(value: &verbose)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        if verbose != false {
            try visitor.visitSingularBoolField(value: verbose, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerStatusRequest, rhs: Runtime_V1_ContainerStatusRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.verbose != rhs.verbose { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerStatus"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .same(proto: "state"),
        4: .standard(proto: "created_at"),
        5: .standard(proto: "started_at"),
        6: .standard(proto: "finished_at"),
        7: .standard(proto: "exit_code"),
        8: .same(proto: "image"),
        9: .standard(proto: "image_ref"),
        10: .same(proto: "reason"),
        11: .same(proto: "message"),
        12: .same(proto: "labels"),
        13: .same(proto: "annotations"),
        14: .same(proto: "mounts"),
        15: .standard(proto: "log_path"),
        16: .same(proto: "resources"),
        17: .standard(proto: "image_id"),
        18: .same(proto: "user"),
    ]

    fileprivate class _StorageClass {
        var _id: String = .init()
        var _metadata: Runtime_V1_ContainerMetadata?
        var _state: Runtime_V1_ContainerState = .containerCreated
        var _createdAt: Int64 = 0
        var _startedAt: Int64 = 0
        var _finishedAt: Int64 = 0
        var _exitCode: Int32 = 0
        var _image: Runtime_V1_ImageSpec?
        var _imageRef: String = .init()
        var _reason: String = .init()
        var _message: String = .init()
        var _labels: [String: String] = [:]
        var _annotations: [String: String] = [:]
        var _mounts: [Runtime_V1_Mount] = []
        var _logPath: String = .init()
        var _resources: Runtime_V1_ContainerResources?
        var _imageID: String = .init()
        var _user: Runtime_V1_ContainerUser?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _id = source._id
            _metadata = source._metadata
            _state = source._state
            _createdAt = source._createdAt
            _startedAt = source._startedAt
            _finishedAt = source._finishedAt
            _exitCode = source._exitCode
            _image = source._image
            _imageRef = source._imageRef
            _reason = source._reason
            _message = source._message
            _labels = source._labels
            _annotations = source._annotations
            _mounts = source._mounts
            _logPath = source._logPath
            _resources = source._resources
            _imageID = source._imageID
            _user = source._user
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularStringField(value: &_storage._id)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._metadata)
                case 3: try try decoder.decodeSingularEnumField(value: &_storage._state)
                case 4: try try decoder.decodeSingularInt64Field(value: &_storage._createdAt)
                case 5: try try decoder.decodeSingularInt64Field(value: &_storage._startedAt)
                case 6: try try decoder.decodeSingularInt64Field(value: &_storage._finishedAt)
                case 7: try try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
                case 8: try try decoder.decodeSingularMessageField(value: &_storage._image)
                case 9: try try decoder.decodeSingularStringField(value: &_storage._imageRef)
                case 10: try try decoder.decodeSingularStringField(value: &_storage._reason)
                case 11: try try decoder.decodeSingularStringField(value: &_storage._message)
                case 12: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._labels
                    ) }()
                case 13: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._annotations
                    ) }()
                case 14: try try decoder.decodeRepeatedMessageField(value: &_storage._mounts)
                case 15: try try decoder.decodeSingularStringField(value: &_storage._logPath)
                case 16: try try decoder.decodeSingularMessageField(value: &_storage._resources)
                case 17: try try decoder.decodeSingularStringField(value: &_storage._imageID)
                case 18: try try decoder.decodeSingularMessageField(value: &_storage._user)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._id.isEmpty {
                try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
            }
            try { if let v = _storage._metadata {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            if _storage._state != .containerCreated {
                try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
            }
            if _storage._createdAt != 0 {
                try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 4)
            }
            if _storage._startedAt != 0 {
                try visitor.visitSingularInt64Field(value: _storage._startedAt, fieldNumber: 5)
            }
            if _storage._finishedAt != 0 {
                try visitor.visitSingularInt64Field(value: _storage._finishedAt, fieldNumber: 6)
            }
            if _storage._exitCode != 0 {
                try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 7)
            }
            try { if let v = _storage._image {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            } }()
            if !_storage._imageRef.isEmpty {
                try visitor.visitSingularStringField(value: _storage._imageRef, fieldNumber: 9)
            }
            if !_storage._reason.isEmpty {
                try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 10)
            }
            if !_storage._message.isEmpty {
                try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 11)
            }
            if !_storage._labels.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._labels,
                    fieldNumber: 12
                )
            }
            if !_storage._annotations.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._annotations,
                    fieldNumber: 13
                )
            }
            if !_storage._mounts.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._mounts, fieldNumber: 14)
            }
            if !_storage._logPath.isEmpty {
                try visitor.visitSingularStringField(value: _storage._logPath, fieldNumber: 15)
            }
            try { if let v = _storage._resources {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
            } }()
            if !_storage._imageID.isEmpty {
                try visitor.visitSingularStringField(value: _storage._imageID, fieldNumber: 17)
            }
            try { if let v = _storage._user {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerStatus, rhs: Runtime_V1_ContainerStatus) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._id != rhs_storage._id { return false }
                if _storage._metadata != rhs_storage._metadata { return false }
                if _storage._state != rhs_storage._state { return false }
                if _storage._createdAt != rhs_storage._createdAt { return false }
                if _storage._startedAt != rhs_storage._startedAt { return false }
                if _storage._finishedAt != rhs_storage._finishedAt { return false }
                if _storage._exitCode != rhs_storage._exitCode { return false }
                if _storage._image != rhs_storage._image { return false }
                if _storage._imageRef != rhs_storage._imageRef { return false }
                if _storage._reason != rhs_storage._reason { return false }
                if _storage._message != rhs_storage._message { return false }
                if _storage._labels != rhs_storage._labels { return false }
                if _storage._annotations != rhs_storage._annotations { return false }
                if _storage._mounts != rhs_storage._mounts { return false }
                if _storage._logPath != rhs_storage._logPath { return false }
                if _storage._resources != rhs_storage._resources { return false }
                if _storage._imageID != rhs_storage._imageID { return false }
                if _storage._user != rhs_storage._user { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerStatusResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .same(proto: "info"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_status)
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.info
                ) }()
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._status {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !info.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: info,
                fieldNumber: 2
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerStatusResponse, rhs: Runtime_V1_ContainerStatusResponse) -> Bool {
        if lhs._status != rhs._status { return false }
        if lhs.info != rhs.info { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerResources"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "linux"),
        2: .same(proto: "windows"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_linux)
            case 2: try try decoder.decodeSingularMessageField(value: &_windows)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._linux {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._windows {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerResources, rhs: Runtime_V1_ContainerResources) -> Bool {
        if lhs._linux != rhs._linux { return false }
        if lhs._windows != rhs._windows { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerUser"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "linux"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_linux)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._linux {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerUser, rhs: Runtime_V1_ContainerUser) -> Bool {
        if lhs._linux != rhs._linux { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_UpdateContainerResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateContainerResourcesRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .same(proto: "linux"),
        3: .same(proto: "windows"),
        4: .same(proto: "annotations"),
    ]

    fileprivate class _StorageClass {
        var _containerID: String = .init()
        var _linux: Runtime_V1_LinuxContainerResources?
        var _windows: Runtime_V1_WindowsContainerResources?
        var _annotations: [String: String] = [:]

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _containerID = source._containerID
            _linux = source._linux
            _windows = source._windows
            _annotations = source._annotations
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularStringField(value: &_storage._containerID)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._linux)
                case 3: try try decoder.decodeSingularMessageField(value: &_storage._windows)
                case 4: try { try decoder.decodeMapField(
                        fieldType: SwiftProtobuf
                            ._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._annotations
                    ) }()
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._containerID.isEmpty {
                try visitor.visitSingularStringField(value: _storage._containerID, fieldNumber: 1)
            }
            try { if let v = _storage._linux {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            try { if let v = _storage._windows {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            if !_storage._annotations.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: _storage._annotations,
                    fieldNumber: 4
                )
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_UpdateContainerResourcesRequest,
        rhs: Runtime_V1_UpdateContainerResourcesRequest
    ) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._containerID != rhs_storage._containerID { return false }
                if _storage._linux != rhs_storage._linux { return false }
                if _storage._windows != rhs_storage._windows { return false }
                if _storage._annotations != rhs_storage._annotations { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_UpdateContainerResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateContainerResourcesResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_UpdateContainerResourcesResponse,
        rhs: Runtime_V1_UpdateContainerResourcesResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ExecSyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ExecSyncRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .same(proto: "cmd"),
        3: .same(proto: "timeout"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            case 2: try try decoder.decodeRepeatedStringField(value: &cmd)
            case 3: try try decoder.decodeSingularInt64Field(value: &timeout)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        if !cmd.isEmpty {
            try visitor.visitRepeatedStringField(value: cmd, fieldNumber: 2)
        }
        if timeout != 0 {
            try visitor.visitSingularInt64Field(value: timeout, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ExecSyncRequest, rhs: Runtime_V1_ExecSyncRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.cmd != rhs.cmd { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ExecSyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ExecSyncResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stdout"),
        2: .same(proto: "stderr"),
        3: .standard(proto: "exit_code"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularBytesField(value: &stdout)
            case 2: try try decoder.decodeSingularBytesField(value: &stderr)
            case 3: try try decoder.decodeSingularInt32Field(value: &exitCode)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !stdout.isEmpty {
            try visitor.visitSingularBytesField(value: stdout, fieldNumber: 1)
        }
        if !stderr.isEmpty {
            try visitor.visitSingularBytesField(value: stderr, fieldNumber: 2)
        }
        if exitCode != 0 {
            try visitor.visitSingularInt32Field(value: exitCode, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ExecSyncResponse, rhs: Runtime_V1_ExecSyncResponse) -> Bool {
        if lhs.stdout != rhs.stdout { return false }
        if lhs.stderr != rhs.stderr { return false }
        if lhs.exitCode != rhs.exitCode { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ExecRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ExecRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .same(proto: "cmd"),
        3: .same(proto: "tty"),
        4: .same(proto: "stdin"),
        5: .same(proto: "stdout"),
        6: .same(proto: "stderr"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            case 2: try try decoder.decodeRepeatedStringField(value: &cmd)
            case 3: try try decoder.decodeSingularBoolField(value: &tty)
            case 4: try try decoder.decodeSingularBoolField(value: &stdin)
            case 5: try try decoder.decodeSingularBoolField(value: &stdout)
            case 6: try try decoder.decodeSingularBoolField(value: &stderr)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        if !cmd.isEmpty {
            try visitor.visitRepeatedStringField(value: cmd, fieldNumber: 2)
        }
        if tty != false {
            try visitor.visitSingularBoolField(value: tty, fieldNumber: 3)
        }
        if stdin != false {
            try visitor.visitSingularBoolField(value: stdin, fieldNumber: 4)
        }
        if stdout != false {
            try visitor.visitSingularBoolField(value: stdout, fieldNumber: 5)
        }
        if stderr != false {
            try visitor.visitSingularBoolField(value: stderr, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ExecRequest, rhs: Runtime_V1_ExecRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.cmd != rhs.cmd { return false }
        if lhs.tty != rhs.tty { return false }
        if lhs.stdin != rhs.stdin { return false }
        if lhs.stdout != rhs.stdout { return false }
        if lhs.stderr != rhs.stderr { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ExecResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ExecResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "url"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &url)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !url.isEmpty {
            try visitor.visitSingularStringField(value: url, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ExecResponse, rhs: Runtime_V1_ExecResponse) -> Bool {
        if lhs.url != rhs.url { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_AttachRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AttachRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .same(proto: "stdin"),
        3: .same(proto: "tty"),
        4: .same(proto: "stdout"),
        5: .same(proto: "stderr"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            case 2: try try decoder.decodeSingularBoolField(value: &stdin)
            case 3: try try decoder.decodeSingularBoolField(value: &tty)
            case 4: try try decoder.decodeSingularBoolField(value: &stdout)
            case 5: try try decoder.decodeSingularBoolField(value: &stderr)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        if stdin != false {
            try visitor.visitSingularBoolField(value: stdin, fieldNumber: 2)
        }
        if tty != false {
            try visitor.visitSingularBoolField(value: tty, fieldNumber: 3)
        }
        if stdout != false {
            try visitor.visitSingularBoolField(value: stdout, fieldNumber: 4)
        }
        if stderr != false {
            try visitor.visitSingularBoolField(value: stderr, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_AttachRequest, rhs: Runtime_V1_AttachRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.stdin != rhs.stdin { return false }
        if lhs.tty != rhs.tty { return false }
        if lhs.stdout != rhs.stdout { return false }
        if lhs.stderr != rhs.stderr { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_AttachResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AttachResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "url"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &url)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !url.isEmpty {
            try visitor.visitSingularStringField(value: url, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_AttachResponse, rhs: Runtime_V1_AttachResponse) -> Bool {
        if lhs.url != rhs.url { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PortForwardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PortForwardRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_sandbox_id"),
        2: .same(proto: "port"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podSandboxID)
            case 2: try try decoder.decodeRepeatedInt32Field(value: &port)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 1)
        }
        if !port.isEmpty {
            try visitor.visitPackedInt32Field(value: port, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PortForwardRequest, rhs: Runtime_V1_PortForwardRequest) -> Bool {
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.port != rhs.port { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PortForwardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PortForwardResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "url"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &url)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !url.isEmpty {
            try visitor.visitSingularStringField(value: url, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PortForwardResponse, rhs: Runtime_V1_PortForwardResponse) -> Bool {
        if lhs.url != rhs.url { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ImageFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImageFilter"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "image"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_image)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._image {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ImageFilter, rhs: Runtime_V1_ImageFilter) -> Bool {
        if lhs._image != rhs._image { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListImagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListImagesRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "filter"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_filter)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._filter {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListImagesRequest, rhs: Runtime_V1_ListImagesRequest) -> Bool {
        if lhs._filter != rhs._filter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Image"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "repo_tags"),
        3: .standard(proto: "repo_digests"),
        4: .same(proto: "size"),
        5: .same(proto: "uid"),
        6: .same(proto: "username"),
        7: .same(proto: "spec"),
        8: .same(proto: "pinned"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeRepeatedStringField(value: &repoTags)
            case 3: try try decoder.decodeRepeatedStringField(value: &repoDigests)
            case 4: try try decoder.decodeSingularUInt64Field(value: &size)
            case 5: try try decoder.decodeSingularMessageField(value: &_uid)
            case 6: try try decoder.decodeSingularStringField(value: &username)
            case 7: try try decoder.decodeSingularMessageField(value: &_spec)
            case 8: try try decoder.decodeSingularBoolField(value: &pinned)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !repoTags.isEmpty {
            try visitor.visitRepeatedStringField(value: repoTags, fieldNumber: 2)
        }
        if !repoDigests.isEmpty {
            try visitor.visitRepeatedStringField(value: repoDigests, fieldNumber: 3)
        }
        if size != 0 {
            try visitor.visitSingularUInt64Field(value: size, fieldNumber: 4)
        }
        try { if let v = self._uid {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        if !username.isEmpty {
            try visitor.visitSingularStringField(value: username, fieldNumber: 6)
        }
        try { if let v = self._spec {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        } }()
        if pinned != false {
            try visitor.visitSingularBoolField(value: pinned, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_Image, rhs: Runtime_V1_Image) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.repoTags != rhs.repoTags { return false }
        if lhs.repoDigests != rhs.repoDigests { return false }
        if lhs.size != rhs.size { return false }
        if lhs._uid != rhs._uid { return false }
        if lhs.username != rhs.username { return false }
        if lhs._spec != rhs._spec { return false }
        if lhs.pinned != rhs.pinned { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListImagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListImagesResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "images"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &images)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !images.isEmpty {
            try visitor.visitRepeatedMessageField(value: images, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListImagesResponse, rhs: Runtime_V1_ListImagesResponse) -> Bool {
        if lhs.images != rhs.images { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ImageStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImageStatusRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "image"),
        2: .same(proto: "verbose"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_image)
            case 2: try try decoder.decodeSingularBoolField(value: &verbose)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._image {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if verbose != false {
            try visitor.visitSingularBoolField(value: verbose, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ImageStatusRequest, rhs: Runtime_V1_ImageStatusRequest) -> Bool {
        if lhs._image != rhs._image { return false }
        if lhs.verbose != rhs.verbose { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ImageStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImageStatusResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "image"),
        2: .same(proto: "info"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_image)
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.info
                ) }()
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._image {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !info.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: info,
                fieldNumber: 2
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ImageStatusResponse, rhs: Runtime_V1_ImageStatusResponse) -> Bool {
        if lhs._image != rhs._image { return false }
        if lhs.info != rhs.info { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_AuthConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AuthConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "username"),
        2: .same(proto: "password"),
        3: .same(proto: "auth"),
        4: .standard(proto: "server_address"),
        5: .standard(proto: "identity_token"),
        6: .standard(proto: "registry_token"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &username)
            case 2: try try decoder.decodeSingularStringField(value: &password)
            case 3: try try decoder.decodeSingularStringField(value: &auth)
            case 4: try try decoder.decodeSingularStringField(value: &serverAddress)
            case 5: try try decoder.decodeSingularStringField(value: &identityToken)
            case 6: try try decoder.decodeSingularStringField(value: &registryToken)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !username.isEmpty {
            try visitor.visitSingularStringField(value: username, fieldNumber: 1)
        }
        if !password.isEmpty {
            try visitor.visitSingularStringField(value: password, fieldNumber: 2)
        }
        if !auth.isEmpty {
            try visitor.visitSingularStringField(value: auth, fieldNumber: 3)
        }
        if !serverAddress.isEmpty {
            try visitor.visitSingularStringField(value: serverAddress, fieldNumber: 4)
        }
        if !identityToken.isEmpty {
            try visitor.visitSingularStringField(value: identityToken, fieldNumber: 5)
        }
        if !registryToken.isEmpty {
            try visitor.visitSingularStringField(value: registryToken, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_AuthConfig, rhs: Runtime_V1_AuthConfig) -> Bool {
        if lhs.username != rhs.username { return false }
        if lhs.password != rhs.password { return false }
        if lhs.auth != rhs.auth { return false }
        if lhs.serverAddress != rhs.serverAddress { return false }
        if lhs.identityToken != rhs.identityToken { return false }
        if lhs.registryToken != rhs.registryToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PullImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PullImageRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "image"),
        2: .same(proto: "auth"),
        3: .standard(proto: "sandbox_config"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_image)
            case 2: try try decoder.decodeSingularMessageField(value: &_auth)
            case 3: try try decoder.decodeSingularMessageField(value: &_sandboxConfig)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._image {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._auth {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._sandboxConfig {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PullImageRequest, rhs: Runtime_V1_PullImageRequest) -> Bool {
        if lhs._image != rhs._image { return false }
        if lhs._auth != rhs._auth { return false }
        if lhs._sandboxConfig != rhs._sandboxConfig { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PullImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PullImageResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "image_ref"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &imageRef)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !imageRef.isEmpty {
            try visitor.visitSingularStringField(value: imageRef, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PullImageResponse, rhs: Runtime_V1_PullImageResponse) -> Bool {
        if lhs.imageRef != rhs.imageRef { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RemoveImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemoveImageRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "image"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_image)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._image {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RemoveImageRequest, rhs: Runtime_V1_RemoveImageRequest) -> Bool {
        if lhs._image != rhs._image { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RemoveImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemoveImageResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RemoveImageResponse, rhs: Runtime_V1_RemoveImageResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_NetworkConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".NetworkConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_cidr"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podCidr)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podCidr.isEmpty {
            try visitor.visitSingularStringField(value: podCidr, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_NetworkConfig, rhs: Runtime_V1_NetworkConfig) -> Bool {
        if lhs.podCidr != rhs.podCidr { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RuntimeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RuntimeConfig"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "network_config"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_networkConfig)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._networkConfig {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RuntimeConfig, rhs: Runtime_V1_RuntimeConfig) -> Bool {
        if lhs._networkConfig != rhs._networkConfig { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_UpdateRuntimeConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateRuntimeConfigRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "runtime_config"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_runtimeConfig)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._runtimeConfig {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_UpdateRuntimeConfigRequest, rhs: Runtime_V1_UpdateRuntimeConfigRequest) -> Bool {
        if lhs._runtimeConfig != rhs._runtimeConfig { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_UpdateRuntimeConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateRuntimeConfigResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_UpdateRuntimeConfigResponse, rhs: Runtime_V1_UpdateRuntimeConfigResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RuntimeCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RuntimeCondition"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "status"),
        3: .same(proto: "reason"),
        4: .same(proto: "message"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &type)
            case 2: try try decoder.decodeSingularBoolField(value: &status)
            case 3: try try decoder.decodeSingularStringField(value: &reason)
            case 4: try try decoder.decodeSingularStringField(value: &message)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if status != false {
            try visitor.visitSingularBoolField(value: status, fieldNumber: 2)
        }
        if !reason.isEmpty {
            try visitor.visitSingularStringField(value: reason, fieldNumber: 3)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RuntimeCondition, rhs: Runtime_V1_RuntimeCondition) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.status != rhs.status { return false }
        if lhs.reason != rhs.reason { return false }
        if lhs.message != rhs.message { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RuntimeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RuntimeStatus"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "conditions"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &conditions)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !conditions.isEmpty {
            try visitor.visitRepeatedMessageField(value: conditions, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RuntimeStatus, rhs: Runtime_V1_RuntimeStatus) -> Bool {
        if lhs.conditions != rhs.conditions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StatusRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "verbose"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularBoolField(value: &verbose)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if verbose != false {
            try visitor.visitSingularBoolField(value: verbose, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_StatusRequest, rhs: Runtime_V1_StatusRequest) -> Bool {
        if lhs.verbose != rhs.verbose { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RuntimeHandlerFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RuntimeHandlerFeatures"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "recursive_read_only_mounts"),
        2: .standard(proto: "user_namespaces"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularBoolField(value: &recursiveReadOnlyMounts)
            case 2: try try decoder.decodeSingularBoolField(value: &userNamespaces)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if recursiveReadOnlyMounts != false {
            try visitor.visitSingularBoolField(value: recursiveReadOnlyMounts, fieldNumber: 1)
        }
        if userNamespaces != false {
            try visitor.visitSingularBoolField(value: userNamespaces, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RuntimeHandlerFeatures, rhs: Runtime_V1_RuntimeHandlerFeatures) -> Bool {
        if lhs.recursiveReadOnlyMounts != rhs.recursiveReadOnlyMounts { return false }
        if lhs.userNamespaces != rhs.userNamespaces { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RuntimeHandler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RuntimeHandler"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "features"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularMessageField(value: &_features)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try { if let v = self._features {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RuntimeHandler, rhs: Runtime_V1_RuntimeHandler) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs._features != rhs._features { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StatusResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .same(proto: "info"),
        3: .standard(proto: "runtime_handlers"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_status)
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.info
                ) }()
            case 3: try try decoder.decodeRepeatedMessageField(value: &runtimeHandlers)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._status {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !info.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: info,
                fieldNumber: 2
            )
        }
        if !runtimeHandlers.isEmpty {
            try visitor.visitRepeatedMessageField(value: runtimeHandlers, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_StatusResponse, rhs: Runtime_V1_StatusResponse) -> Bool {
        if lhs._status != rhs._status { return false }
        if lhs.info != rhs.info { return false }
        if lhs.runtimeHandlers != rhs.runtimeHandlers { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ImageFsInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImageFsInfoRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ImageFsInfoRequest, rhs: Runtime_V1_ImageFsInfoRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_UInt64Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UInt64Value"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "value"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularUInt64Field(value: &value)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if value != 0 {
            try visitor.visitSingularUInt64Field(value: value, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_UInt64Value, rhs: Runtime_V1_UInt64Value) -> Bool {
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_FilesystemIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".FilesystemIdentifier"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "mountpoint"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &mountpoint)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !mountpoint.isEmpty {
            try visitor.visitSingularStringField(value: mountpoint, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_FilesystemIdentifier, rhs: Runtime_V1_FilesystemIdentifier) -> Bool {
        if lhs.mountpoint != rhs.mountpoint { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_FilesystemUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".FilesystemUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "fs_id"),
        3: .standard(proto: "used_bytes"),
        4: .standard(proto: "inodes_used"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_fsID)
            case 3: try try decoder.decodeSingularMessageField(value: &_usedBytes)
            case 4: try try decoder.decodeSingularMessageField(value: &_inodesUsed)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._fsID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._usedBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._inodesUsed {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_FilesystemUsage, rhs: Runtime_V1_FilesystemUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._fsID != rhs._fsID { return false }
        if lhs._usedBytes != rhs._usedBytes { return false }
        if lhs._inodesUsed != rhs._inodesUsed { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsFilesystemUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsFilesystemUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "fs_id"),
        3: .standard(proto: "used_bytes"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_fsID)
            case 3: try try decoder.decodeSingularMessageField(value: &_usedBytes)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._fsID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._usedBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsFilesystemUsage, rhs: Runtime_V1_WindowsFilesystemUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._fsID != rhs._fsID { return false }
        if lhs._usedBytes != rhs._usedBytes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ImageFsInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImageFsInfoResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "image_filesystems"),
        2: .standard(proto: "container_filesystems"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &imageFilesystems)
            case 2: try try decoder.decodeRepeatedMessageField(value: &containerFilesystems)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !imageFilesystems.isEmpty {
            try visitor.visitRepeatedMessageField(value: imageFilesystems, fieldNumber: 1)
        }
        if !containerFilesystems.isEmpty {
            try visitor.visitRepeatedMessageField(value: containerFilesystems, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ImageFsInfoResponse, rhs: Runtime_V1_ImageFsInfoResponse) -> Bool {
        if lhs.imageFilesystems != rhs.imageFilesystems { return false }
        if lhs.containerFilesystems != rhs.containerFilesystems { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerStatsRequest, rhs: Runtime_V1_ContainerStatsRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerStatsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stats"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_stats)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._stats {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerStatsResponse, rhs: Runtime_V1_ContainerStatsResponse) -> Bool {
        if lhs._stats != rhs._stats { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListContainerStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListContainerStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "filter"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_filter)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._filter {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListContainerStatsRequest, rhs: Runtime_V1_ListContainerStatsRequest) -> Bool {
        if lhs._filter != rhs._filter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerStatsFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerStatsFilter"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "pod_sandbox_id"),
        3: .standard(proto: "label_selector"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularStringField(value: &podSandboxID)
            case 3: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.labelSelector
                ) }()
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 2)
        }
        if !labelSelector.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: labelSelector,
                fieldNumber: 3
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerStatsFilter, rhs: Runtime_V1_ContainerStatsFilter) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.labelSelector != rhs.labelSelector { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListContainerStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListContainerStatsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "stats"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &stats)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !stats.isEmpty {
            try visitor.visitRepeatedMessageField(value: stats, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ListContainerStatsResponse, rhs: Runtime_V1_ListContainerStatsResponse) -> Bool {
        if lhs.stats != rhs.stats { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerAttributes"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "metadata"),
        3: .same(proto: "labels"),
        4: .same(proto: "annotations"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &id)
            case 2: try try decoder.decodeSingularMessageField(value: &_metadata)
            case 3: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.labels
                ) }()
            case 4: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>
                        .self,
                    value: &self.annotations
                ) }()
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try { if let v = self._metadata {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !labels.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: labels,
                fieldNumber: 3
            )
        }
        if !annotations.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: annotations,
                fieldNumber: 4
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerAttributes, rhs: Runtime_V1_ContainerAttributes) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs._metadata != rhs._metadata { return false }
        if lhs.labels != rhs.labels { return false }
        if lhs.annotations != rhs.annotations { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerStats"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "attributes"),
        2: .same(proto: "cpu"),
        3: .same(proto: "memory"),
        4: .standard(proto: "writable_layer"),
        5: .same(proto: "swap"),
    ]

    fileprivate class _StorageClass {
        var _attributes: Runtime_V1_ContainerAttributes?
        var _cpu: Runtime_V1_CpuUsage?
        var _memory: Runtime_V1_MemoryUsage?
        var _writableLayer: Runtime_V1_FilesystemUsage?
        var _swap: Runtime_V1_SwapUsage?

        #if swift(>=5.10)
            // This property is used as the initial default value for new instances of the type.
            // The type itself is protecting the reference to its storage via CoW semantics.
            // This will force a copy to be made of this reference when the first mutation occurs;
            // hence, it is safe to mark this as `nonisolated(unsafe)`.
            nonisolated(unsafe) static let defaultInstance = _StorageClass()
        #else
            static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _attributes = source._attributes
            _cpu = source._cpu
            _memory = source._memory
            _writableLayer = source._writableLayer
            _swap = source._swap
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try try decoder.decodeSingularMessageField(value: &_storage._attributes)
                case 2: try try decoder.decodeSingularMessageField(value: &_storage._cpu)
                case 3: try try decoder.decodeSingularMessageField(value: &_storage._memory)
                case 4: try try decoder.decodeSingularMessageField(value: &_storage._writableLayer)
                case 5: try try decoder.decodeSingularMessageField(value: &_storage._swap)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._attributes {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._cpu {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            try { if let v = _storage._memory {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            try { if let v = _storage._writableLayer {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            } }()
            try { if let v = _storage._swap {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerStats, rhs: Runtime_V1_ContainerStats) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._attributes != rhs_storage._attributes { return false }
                if _storage._cpu != rhs_storage._cpu { return false }
                if _storage._memory != rhs_storage._memory { return false }
                if _storage._writableLayer != rhs_storage._writableLayer { return false }
                if _storage._swap != rhs_storage._swap { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsContainerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsContainerStats"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "attributes"),
        2: .same(proto: "cpu"),
        3: .same(proto: "memory"),
        4: .standard(proto: "writable_layer"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_attributes)
            case 2: try try decoder.decodeSingularMessageField(value: &_cpu)
            case 3: try try decoder.decodeSingularMessageField(value: &_memory)
            case 4: try try decoder.decodeSingularMessageField(value: &_writableLayer)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._attributes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._cpu {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._memory {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._writableLayer {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsContainerStats, rhs: Runtime_V1_WindowsContainerStats) -> Bool {
        if lhs._attributes != rhs._attributes { return false }
        if lhs._cpu != rhs._cpu { return false }
        if lhs._memory != rhs._memory { return false }
        if lhs._writableLayer != rhs._writableLayer { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_CpuUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CpuUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "usage_core_nano_seconds"),
        3: .standard(proto: "usage_nano_cores"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_usageCoreNanoSeconds)
            case 3: try try decoder.decodeSingularMessageField(value: &_usageNanoCores)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._usageCoreNanoSeconds {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._usageNanoCores {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_CpuUsage, rhs: Runtime_V1_CpuUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._usageCoreNanoSeconds != rhs._usageCoreNanoSeconds { return false }
        if lhs._usageNanoCores != rhs._usageNanoCores { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsCpuUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsCpuUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "usage_core_nano_seconds"),
        3: .standard(proto: "usage_nano_cores"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_usageCoreNanoSeconds)
            case 3: try try decoder.decodeSingularMessageField(value: &_usageNanoCores)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._usageCoreNanoSeconds {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._usageNanoCores {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsCpuUsage, rhs: Runtime_V1_WindowsCpuUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._usageCoreNanoSeconds != rhs._usageCoreNanoSeconds { return false }
        if lhs._usageNanoCores != rhs._usageNanoCores { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_MemoryUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".MemoryUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "working_set_bytes"),
        3: .standard(proto: "available_bytes"),
        4: .standard(proto: "usage_bytes"),
        5: .standard(proto: "rss_bytes"),
        6: .standard(proto: "page_faults"),
        7: .standard(proto: "major_page_faults"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_workingSetBytes)
            case 3: try try decoder.decodeSingularMessageField(value: &_availableBytes)
            case 4: try try decoder.decodeSingularMessageField(value: &_usageBytes)
            case 5: try try decoder.decodeSingularMessageField(value: &_rssBytes)
            case 6: try try decoder.decodeSingularMessageField(value: &_pageFaults)
            case 7: try try decoder.decodeSingularMessageField(value: &_majorPageFaults)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._workingSetBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._availableBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._usageBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try { if let v = self._rssBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try { if let v = self._pageFaults {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        } }()
        try { if let v = self._majorPageFaults {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_MemoryUsage, rhs: Runtime_V1_MemoryUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._workingSetBytes != rhs._workingSetBytes { return false }
        if lhs._availableBytes != rhs._availableBytes { return false }
        if lhs._usageBytes != rhs._usageBytes { return false }
        if lhs._rssBytes != rhs._rssBytes { return false }
        if lhs._pageFaults != rhs._pageFaults { return false }
        if lhs._majorPageFaults != rhs._majorPageFaults { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_SwapUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SwapUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "swap_available_bytes"),
        3: .standard(proto: "swap_usage_bytes"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_swapAvailableBytes)
            case 3: try try decoder.decodeSingularMessageField(value: &_swapUsageBytes)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._swapAvailableBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._swapUsageBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_SwapUsage, rhs: Runtime_V1_SwapUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._swapAvailableBytes != rhs._swapAvailableBytes { return false }
        if lhs._swapUsageBytes != rhs._swapUsageBytes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_WindowsMemoryUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WindowsMemoryUsage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .standard(proto: "working_set_bytes"),
        3: .standard(proto: "available_bytes"),
        4: .standard(proto: "page_faults"),
        5: .standard(proto: "commit_memory_bytes"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try try decoder.decodeSingularMessageField(value: &_workingSetBytes)
            case 3: try try decoder.decodeSingularMessageField(value: &_availableBytes)
            case 4: try try decoder.decodeSingularMessageField(value: &_pageFaults)
            case 5: try try decoder.decodeSingularMessageField(value: &_commitMemoryBytes)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        try { if let v = self._workingSetBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._availableBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._pageFaults {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try { if let v = self._commitMemoryBytes {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_WindowsMemoryUsage, rhs: Runtime_V1_WindowsMemoryUsage) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._workingSetBytes != rhs._workingSetBytes { return false }
        if lhs._availableBytes != rhs._availableBytes { return false }
        if lhs._pageFaults != rhs._pageFaults { return false }
        if lhs._commitMemoryBytes != rhs._commitMemoryBytes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ReopenContainerLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReopenContainerLogRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ReopenContainerLogRequest, rhs: Runtime_V1_ReopenContainerLogRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ReopenContainerLogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReopenContainerLogResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ReopenContainerLogResponse, rhs: Runtime_V1_ReopenContainerLogResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_CheckpointContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CheckpointContainerRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .same(proto: "location"),
        3: .same(proto: "timeout"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            case 2: try try decoder.decodeSingularStringField(value: &location)
            case 3: try try decoder.decodeSingularInt64Field(value: &timeout)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        if !location.isEmpty {
            try visitor.visitSingularStringField(value: location, fieldNumber: 2)
        }
        if timeout != 0 {
            try visitor.visitSingularInt64Field(value: timeout, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_CheckpointContainerRequest, rhs: Runtime_V1_CheckpointContainerRequest) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.location != rhs.location { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_CheckpointContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CheckpointContainerResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_CheckpointContainerResponse, rhs: Runtime_V1_CheckpointContainerResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_GetEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetEventsRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_GetEventsRequest, rhs: Runtime_V1_GetEventsRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerEventResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .standard(proto: "container_event_type"),
        3: .standard(proto: "created_at"),
        4: .standard(proto: "pod_sandbox_status"),
        5: .standard(proto: "containers_statuses"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            case 2: try try decoder.decodeSingularEnumField(value: &containerEventType)
            case 3: try try decoder.decodeSingularInt64Field(value: &createdAt)
            case 4: try try decoder.decodeSingularMessageField(value: &_podSandboxStatus)
            case 5: try try decoder.decodeRepeatedMessageField(value: &containersStatuses)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        if containerEventType != .containerCreatedEvent {
            try visitor.visitSingularEnumField(value: containerEventType, fieldNumber: 2)
        }
        if createdAt != 0 {
            try visitor.visitSingularInt64Field(value: createdAt, fieldNumber: 3)
        }
        try { if let v = self._podSandboxStatus {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if !containersStatuses.isEmpty {
            try visitor.visitRepeatedMessageField(value: containersStatuses, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerEventResponse, rhs: Runtime_V1_ContainerEventResponse) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.containerEventType != rhs.containerEventType { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs._podSandboxStatus != rhs._podSandboxStatus { return false }
        if lhs.containersStatuses != rhs.containersStatuses { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListMetricDescriptorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListMetricDescriptorsRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_ListMetricDescriptorsRequest,
        rhs: Runtime_V1_ListMetricDescriptorsRequest
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListMetricDescriptorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListMetricDescriptorsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "descriptors"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &descriptors)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !descriptors.isEmpty {
            try visitor.visitRepeatedMessageField(value: descriptors, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_ListMetricDescriptorsResponse,
        rhs: Runtime_V1_ListMetricDescriptorsResponse
    ) -> Bool {
        if lhs.descriptors != rhs.descriptors { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_MetricDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".MetricDescriptor"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "help"),
        3: .standard(proto: "label_keys"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularStringField(value: &help)
            case 3: try try decoder.decodeRepeatedStringField(value: &labelKeys)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !help.isEmpty {
            try visitor.visitSingularStringField(value: help, fieldNumber: 2)
        }
        if !labelKeys.isEmpty {
            try visitor.visitRepeatedStringField(value: labelKeys, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_MetricDescriptor, rhs: Runtime_V1_MetricDescriptor) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.help != rhs.help { return false }
        if lhs.labelKeys != rhs.labelKeys { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListPodSandboxMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListPodSandboxMetricsRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_ListPodSandboxMetricsRequest,
        rhs: Runtime_V1_ListPodSandboxMetricsRequest
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ListPodSandboxMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListPodSandboxMetricsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_metrics"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &podMetrics)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podMetrics.isEmpty {
            try visitor.visitRepeatedMessageField(value: podMetrics, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Runtime_V1_ListPodSandboxMetricsResponse,
        rhs: Runtime_V1_ListPodSandboxMetricsResponse
    ) -> Bool {
        if lhs.podMetrics != rhs.podMetrics { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_PodSandboxMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PodSandboxMetrics"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pod_sandbox_id"),
        2: .same(proto: "metrics"),
        3: .standard(proto: "container_metrics"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &podSandboxID)
            case 2: try try decoder.decodeRepeatedMessageField(value: &metrics)
            case 3: try try decoder.decodeRepeatedMessageField(value: &containerMetrics)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !podSandboxID.isEmpty {
            try visitor.visitSingularStringField(value: podSandboxID, fieldNumber: 1)
        }
        if !metrics.isEmpty {
            try visitor.visitRepeatedMessageField(value: metrics, fieldNumber: 2)
        }
        if !containerMetrics.isEmpty {
            try visitor.visitRepeatedMessageField(value: containerMetrics, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_PodSandboxMetrics, rhs: Runtime_V1_PodSandboxMetrics) -> Bool {
        if lhs.podSandboxID != rhs.podSandboxID { return false }
        if lhs.metrics != rhs.metrics { return false }
        if lhs.containerMetrics != rhs.containerMetrics { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_ContainerMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContainerMetrics"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "container_id"),
        2: .same(proto: "metrics"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &containerID)
            case 2: try try decoder.decodeRepeatedMessageField(value: &metrics)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !containerID.isEmpty {
            try visitor.visitSingularStringField(value: containerID, fieldNumber: 1)
        }
        if !metrics.isEmpty {
            try visitor.visitRepeatedMessageField(value: metrics, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_ContainerMetrics, rhs: Runtime_V1_ContainerMetrics) -> Bool {
        if lhs.containerID != rhs.containerID { return false }
        if lhs.metrics != rhs.metrics { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Metric"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "timestamp"),
        3: .standard(proto: "metric_type"),
        4: .standard(proto: "label_values"),
        5: .same(proto: "value"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularStringField(value: &name)
            case 2: try try decoder.decodeSingularInt64Field(value: &timestamp)
            case 3: try try decoder.decodeSingularEnumField(value: &metricType)
            case 4: try try decoder.decodeRepeatedStringField(value: &labelValues)
            case 5: try try decoder.decodeSingularMessageField(value: &_value)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 2)
        }
        if metricType != .counter {
            try visitor.visitSingularEnumField(value: metricType, fieldNumber: 3)
        }
        if !labelValues.isEmpty {
            try visitor.visitRepeatedStringField(value: labelValues, fieldNumber: 4)
        }
        try { if let v = self._value {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_Metric, rhs: Runtime_V1_Metric) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs.metricType != rhs.metricType { return false }
        if lhs.labelValues != rhs.labelValues { return false }
        if lhs._value != rhs._value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RuntimeConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RuntimeConfigRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RuntimeConfigRequest, rhs: Runtime_V1_RuntimeConfigRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_RuntimeConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RuntimeConfigResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "linux"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_linux)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._linux {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_RuntimeConfigResponse, rhs: Runtime_V1_RuntimeConfigResponse) -> Bool {
        if lhs._linux != rhs._linux { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Runtime_V1_LinuxRuntimeConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LinuxRuntimeConfiguration"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cgroup_driver"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularEnumField(value: &cgroupDriver)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if cgroupDriver != .systemd {
            try visitor.visitSingularEnumField(value: cgroupDriver, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Runtime_V1_LinuxRuntimeConfiguration, rhs: Runtime_V1_LinuxRuntimeConfiguration) -> Bool {
        if lhs.cgroupDriver != rhs.cgroupDriver { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
