// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright 2020 The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

/// To regenerate api.pb.go run `hack/update-codegen.sh protobindings`

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Runtime_V1_Protocol: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tcp // = 0
  case udp // = 1
  case sctp // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .tcp
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tcp
    case 1: self = .udp
    case 2: self = .sctp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tcp: return 0
    case .udp: return 1
    case .sctp: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_Protocol: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_Protocol] = [
    .tcp,
    .udp,
    .sctp,
  ]
}

#endif  // swift(>=4.2)

enum Runtime_V1_MountPropagation: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No mount propagation ("rprivate" in Linux terminology).
  case propagationPrivate // = 0

  /// Mounts get propagated from the host to the container ("rslave" in Linux).
  case propagationHostToContainer // = 1

  /// Mounts get propagated from the host to the container and from the
  /// container to the host ("rshared" in Linux).
  case propagationBidirectional // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .propagationPrivate
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .propagationPrivate
    case 1: self = .propagationHostToContainer
    case 2: self = .propagationBidirectional
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .propagationPrivate: return 0
    case .propagationHostToContainer: return 1
    case .propagationBidirectional: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_MountPropagation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_MountPropagation] = [
    .propagationPrivate,
    .propagationHostToContainer,
    .propagationBidirectional,
  ]
}

#endif  // swift(>=4.2)

/// A NamespaceMode describes the intended namespace configuration for each
/// of the namespaces (Network, PID, IPC) in NamespaceOption. Runtimes should
/// map these modes as appropriate for the technology underlying the runtime.
enum Runtime_V1_NamespaceMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// A POD namespace is common to all containers in a pod.
  /// For example, a container with a PID namespace of POD expects to view
  /// all of the processes in all of the containers in the pod.
  case pod // = 0

  /// A CONTAINER namespace is restricted to a single container.
  /// For example, a container with a PID namespace of CONTAINER expects to
  /// view only the processes in that container.
  case container // = 1

  /// A NODE namespace is the namespace of the Kubernetes node.
  /// For example, a container with a PID namespace of NODE expects to view
  /// all of the processes on the host running the kubelet.
  case node // = 2

  /// TARGET targets the namespace of another container. When this is specified,
  /// a target_id must be specified in NamespaceOption and refer to a container
  /// previously created with NamespaceMode CONTAINER. This containers namespace
  /// will be made to match that of container target_id.
  /// For example, a container with a PID namespace of TARGET expects to view
  /// all of the processes that container target_id can view.
  case target // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .pod
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pod
    case 1: self = .container
    case 2: self = .node
    case 3: self = .target
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pod: return 0
    case .container: return 1
    case .node: return 2
    case .target: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_NamespaceMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_NamespaceMode] = [
    .pod,
    .container,
    .node,
    .target,
  ]
}

#endif  // swift(>=4.2)

/// SupplementalGroupsPolicy defines how supplemental groups 
/// of the first container processes are calculated.
enum Runtime_V1_SupplementalGroupsPolicy: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Merge means that the container's provided SupplementalGroups 
  /// and FsGroup (specified in SecurityContext) will be merged with 
  /// the primary user's groups as defined in the container image
  /// (in /etc/group).
  case merge // = 0

  /// Strict means that the container's provided SupplementalGroups
  /// and FsGroup (specified in SecurityContext) will be used instead of 
  /// any groups defined in the container image.
  case strict // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .merge
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .merge
    case 1: self = .strict
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .merge: return 0
    case .strict: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_SupplementalGroupsPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_SupplementalGroupsPolicy] = [
    .merge,
    .strict,
  ]
}

#endif  // swift(>=4.2)

enum Runtime_V1_PodSandboxState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case sandboxReady // = 0
  case sandboxNotready // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .sandboxReady
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sandboxReady
    case 1: self = .sandboxNotready
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sandboxReady: return 0
    case .sandboxNotready: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_PodSandboxState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_PodSandboxState] = [
    .sandboxReady,
    .sandboxNotready,
  ]
}

#endif  // swift(>=4.2)

enum Runtime_V1_ContainerState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case containerCreated // = 0
  case containerRunning // = 1
  case containerExited // = 2
  case containerUnknown // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .containerCreated
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .containerCreated
    case 1: self = .containerRunning
    case 2: self = .containerExited
    case 3: self = .containerUnknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .containerCreated: return 0
    case .containerRunning: return 1
    case .containerExited: return 2
    case .containerUnknown: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_ContainerState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_ContainerState] = [
    .containerCreated,
    .containerRunning,
    .containerExited,
    .containerUnknown,
  ]
}

#endif  // swift(>=4.2)

enum Runtime_V1_ContainerEventType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Container created
  case containerCreatedEvent // = 0

  /// Container started
  case containerStartedEvent // = 1

  /// Container stopped
  case containerStoppedEvent // = 2

  /// Container deleted
  case containerDeletedEvent // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .containerCreatedEvent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .containerCreatedEvent
    case 1: self = .containerStartedEvent
    case 2: self = .containerStoppedEvent
    case 3: self = .containerDeletedEvent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .containerCreatedEvent: return 0
    case .containerStartedEvent: return 1
    case .containerStoppedEvent: return 2
    case .containerDeletedEvent: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_ContainerEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_ContainerEventType] = [
    .containerCreatedEvent,
    .containerStartedEvent,
    .containerStoppedEvent,
    .containerDeletedEvent,
  ]
}

#endif  // swift(>=4.2)

enum Runtime_V1_MetricType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case counter // = 0
  case gauge // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .counter
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .counter
    case 1: self = .gauge
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .counter: return 0
    case .gauge: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_MetricType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_MetricType] = [
    .counter,
    .gauge,
  ]
}

#endif  // swift(>=4.2)

enum Runtime_V1_CgroupDriver: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case systemd // = 0
  case cgroupfs // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .systemd
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .systemd
    case 1: self = .cgroupfs
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .systemd: return 0
    case .cgroupfs: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Runtime_V1_CgroupDriver: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_CgroupDriver] = [
    .systemd,
    .cgroupfs,
  ]
}

#endif  // swift(>=4.2)

struct Runtime_V1_VersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the kubelet runtime API.
  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the kubelet runtime API.
  var version: String = String()

  /// Name of the container runtime.
  var runtimeName: String = String()

  /// Version of the container runtime. The string must be
  /// semver-compatible.
  var runtimeVersion: String = String()

  /// API version of the container runtime. The string must be
  /// semver-compatible.
  var runtimeApiVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DNSConfig specifies the DNS servers and search domains of a sandbox.
struct Runtime_V1_DNSConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of DNS servers of the cluster.
  var servers: [String] = []

  /// List of DNS search domains of the cluster.
  var searches: [String] = []

  /// List of DNS options. See https://linux.die.net/man/5/resolv.conf
  /// for all available options.
  var options: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PortMapping specifies the port mapping configurations of a sandbox.
struct Runtime_V1_PortMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protocol of the port mapping.
  var `protocol`: Runtime_V1_Protocol = .tcp

  /// Port number within the container. Default: 0 (not specified).
  var containerPort: Int32 = 0

  /// Port number on the host. Default: 0 (not specified).
  var hostPort: Int32 = 0

  /// Host IP.
  var hostIp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Mount specifies a host volume to mount into a container.
struct Runtime_V1_Mount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path of the mount within the container.
  var containerPath: String = String()

  /// Path of the mount on the host. If the hostPath doesn't exist, then runtimes
  /// should report error. If the hostpath is a symbolic link, runtimes should
  /// follow the symlink and mount the real destination to container.
  var hostPath: String = String()

  /// If set, the mount is read-only.
  var readonly: Bool = false

  /// If set, the mount needs SELinux relabeling.
  var selinuxRelabel: Bool = false

  /// Requested propagation mode.
  var propagation: Runtime_V1_MountPropagation = .propagationPrivate

  /// UidMappings specifies the runtime UID mappings for the mount.
  var uidMappings: [Runtime_V1_IDMapping] = []

  /// GidMappings specifies the runtime GID mappings for the mount.
  var gidMappings: [Runtime_V1_IDMapping] = []

  /// If set to true, the mount is made recursive read-only.
  /// In this CRI API, recursive_read_only is a plain true/false boolean, although its equivalent
  /// in the Kubernetes core API is a quaternary that can be nil, "Enabled", "IfPossible", or "Disabled".
  /// kubelet translates that quaternary value in the core API into a boolean in this CRI API.
  /// Remarks:
  /// - nil is just treated as false
  /// - when set to true, readonly must be explicitly set to true, and propagation must be PRIVATE (0).
  /// - (readonly == false && recursive_read_only == false) does not make the mount read-only.
  var recursiveReadOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// IDMapping describes host to container ID mappings for a pod sandbox.
struct Runtime_V1_IDMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HostId is the id on the host.
  var hostID: UInt32 = 0

  /// ContainerId is the id in the container.
  var containerID: UInt32 = 0

  /// Length is the size of the range to map.
  var length: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UserNamespace describes the intended user namespace configuration for a pod sandbox.
struct Runtime_V1_UserNamespace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mode is the NamespaceMode for this UserNamespace.
  /// Note: NamespaceMode for UserNamespace currently supports only POD and NODE, not CONTAINER OR TARGET.
  var mode: Runtime_V1_NamespaceMode = .pod

  /// Uids specifies the UID mappings for the user namespace.
  var uids: [Runtime_V1_IDMapping] = []

  /// Gids specifies the GID mappings for the user namespace.
  var gids: [Runtime_V1_IDMapping] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NamespaceOption provides options for Linux namespaces.
struct Runtime_V1_NamespaceOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network namespace for this container/sandbox.
  /// Note: There is currently no way to set CONTAINER scoped network in the Kubernetes API.
  /// Namespaces currently set by the kubelet: POD, NODE
  var network: Runtime_V1_NamespaceMode = .pod

  /// PID namespace for this container/sandbox.
  /// Note: The CRI default is POD, but the v1.PodSpec default is CONTAINER.
  /// The kubelet's runtime manager will set this to CONTAINER explicitly for v1 pods.
  /// Namespaces currently set by the kubelet: POD, CONTAINER, NODE, TARGET
  var pid: Runtime_V1_NamespaceMode = .pod

  /// IPC namespace for this container/sandbox.
  /// Note: There is currently no way to set CONTAINER scoped IPC in the Kubernetes API.
  /// Namespaces currently set by the kubelet: POD, NODE
  var ipc: Runtime_V1_NamespaceMode = .pod

  /// Target Container ID for NamespaceMode of TARGET. This container must have been
  /// previously created in the same pod. It is not possible to specify different targets
  /// for each namespace.
  var targetID: String = String()

  /// UsernsOptions for this pod sandbox.
  /// The Kubelet picks the user namespace configuration to use for the pod sandbox.  The mappings
  /// are specified as part of the UserNamespace struct.  If the struct is nil, then the POD mode
  /// must be assumed.  This is done for backward compatibility with older Kubelet versions that
  /// do not set a user namespace.
  var usernsOptions: Runtime_V1_UserNamespace {
    get {return _usernsOptions ?? Runtime_V1_UserNamespace()}
    set {_usernsOptions = newValue}
  }
  /// Returns true if `usernsOptions` has been explicitly set.
  var hasUsernsOptions: Bool {return self._usernsOptions != nil}
  /// Clears the value of `usernsOptions`. Subsequent reads from it will return its default value.
  mutating func clearUsernsOptions() {self._usernsOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _usernsOptions: Runtime_V1_UserNamespace? = nil
}

/// Int64Value is the wrapper of int64.
struct Runtime_V1_Int64Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value.
  var value: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LinuxSandboxSecurityContext holds linux security configuration that will be
/// applied to a sandbox. Note that:
/// 1) It does not apply to containers in the pods.
/// 2) It may not be applicable to a PodSandbox which does not contain any running
///    process.
struct Runtime_V1_LinuxSandboxSecurityContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configurations for the sandbox's namespaces.
  /// This will be used only if the PodSandbox uses namespace for isolation.
  var namespaceOptions: Runtime_V1_NamespaceOption {
    get {return _storage._namespaceOptions ?? Runtime_V1_NamespaceOption()}
    set {_uniqueStorage()._namespaceOptions = newValue}
  }
  /// Returns true if `namespaceOptions` has been explicitly set.
  var hasNamespaceOptions: Bool {return _storage._namespaceOptions != nil}
  /// Clears the value of `namespaceOptions`. Subsequent reads from it will return its default value.
  mutating func clearNamespaceOptions() {_uniqueStorage()._namespaceOptions = nil}

  /// Optional SELinux context to be applied.
  var selinuxOptions: Runtime_V1_SELinuxOption {
    get {return _storage._selinuxOptions ?? Runtime_V1_SELinuxOption()}
    set {_uniqueStorage()._selinuxOptions = newValue}
  }
  /// Returns true if `selinuxOptions` has been explicitly set.
  var hasSelinuxOptions: Bool {return _storage._selinuxOptions != nil}
  /// Clears the value of `selinuxOptions`. Subsequent reads from it will return its default value.
  mutating func clearSelinuxOptions() {_uniqueStorage()._selinuxOptions = nil}

  /// UID to run sandbox processes as, when applicable.
  var runAsUser: Runtime_V1_Int64Value {
    get {return _storage._runAsUser ?? Runtime_V1_Int64Value()}
    set {_uniqueStorage()._runAsUser = newValue}
  }
  /// Returns true if `runAsUser` has been explicitly set.
  var hasRunAsUser: Bool {return _storage._runAsUser != nil}
  /// Clears the value of `runAsUser`. Subsequent reads from it will return its default value.
  mutating func clearRunAsUser() {_uniqueStorage()._runAsUser = nil}

  /// GID to run sandbox processes as, when applicable. run_as_group should only
  /// be specified when run_as_user is specified; otherwise, the runtime MUST error.
  var runAsGroup: Runtime_V1_Int64Value {
    get {return _storage._runAsGroup ?? Runtime_V1_Int64Value()}
    set {_uniqueStorage()._runAsGroup = newValue}
  }
  /// Returns true if `runAsGroup` has been explicitly set.
  var hasRunAsGroup: Bool {return _storage._runAsGroup != nil}
  /// Clears the value of `runAsGroup`. Subsequent reads from it will return its default value.
  mutating func clearRunAsGroup() {_uniqueStorage()._runAsGroup = nil}

  /// If set, the root filesystem of the sandbox is read-only.
  var readonlyRootfs: Bool {
    get {return _storage._readonlyRootfs}
    set {_uniqueStorage()._readonlyRootfs = newValue}
  }

  /// List of groups applied to the first process run in each container.
  /// supplemental_groups_policy can control how groups will be calculated.
  var supplementalGroups: [Int64] {
    get {return _storage._supplementalGroups}
    set {_uniqueStorage()._supplementalGroups = newValue}
  }

  /// supplemental_groups_policy defines how supplemental groups of the first 
  /// container processes are calculated.
  /// Valid values are "Merge" and "Strict".
  /// If not specified, "Merge" is used.
  var supplementalGroupsPolicy: Runtime_V1_SupplementalGroupsPolicy {
    get {return _storage._supplementalGroupsPolicy}
    set {_uniqueStorage()._supplementalGroupsPolicy = newValue}
  }

  /// Indicates whether the sandbox will be asked to run a privileged
  /// container. If a privileged container is to be executed within it, this
  /// MUST be true.
  /// This allows a sandbox to take additional security precautions if no
  /// privileged containers are expected to be run.
  var privileged: Bool {
    get {return _storage._privileged}
    set {_uniqueStorage()._privileged = newValue}
  }

  /// Seccomp profile for the sandbox.
  var seccomp: Runtime_V1_SecurityProfile {
    get {return _storage._seccomp ?? Runtime_V1_SecurityProfile()}
    set {_uniqueStorage()._seccomp = newValue}
  }
  /// Returns true if `seccomp` has been explicitly set.
  var hasSeccomp: Bool {return _storage._seccomp != nil}
  /// Clears the value of `seccomp`. Subsequent reads from it will return its default value.
  mutating func clearSeccomp() {_uniqueStorage()._seccomp = nil}

  /// AppArmor profile for the sandbox.
  var apparmor: Runtime_V1_SecurityProfile {
    get {return _storage._apparmor ?? Runtime_V1_SecurityProfile()}
    set {_uniqueStorage()._apparmor = newValue}
  }
  /// Returns true if `apparmor` has been explicitly set.
  var hasApparmor: Bool {return _storage._apparmor != nil}
  /// Clears the value of `apparmor`. Subsequent reads from it will return its default value.
  mutating func clearApparmor() {_uniqueStorage()._apparmor = nil}

  /// Seccomp profile for the sandbox, candidate values are:
  /// * runtime/default: the default profile for the container runtime
  /// * unconfined: unconfined profile, ie, no seccomp sandboxing
  /// * localhost/<full-path-to-profile>: the profile installed on the node.
  ///   <full-path-to-profile> is the full path of the profile.
  /// Default: "", which is identical with unconfined.
  var seccompProfilePath: String {
    get {return _storage._seccompProfilePath}
    set {_uniqueStorage()._seccompProfilePath = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A security profile which can be used for sandboxes and containers.
struct Runtime_V1_SecurityProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicator which `ProfileType` should be applied.
  var profileType: Runtime_V1_SecurityProfile.ProfileType = .runtimeDefault

  /// Indicates that a pre-defined profile on the node should be used.
  /// Must only be set if `ProfileType` is `Localhost`.
  /// For seccomp, it must be an absolute path to the seccomp profile.
  /// For AppArmor, this field is the AppArmor `<profile name>/`
  var localhostRef: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Available profile types.
  enum ProfileType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The container runtime default profile should be used.
    case runtimeDefault // = 0

    /// Disable the feature for the sandbox or the container.
    case unconfined // = 1

    /// A pre-defined profile on the node should be used.
    case localhost // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .runtimeDefault
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .runtimeDefault
      case 1: self = .unconfined
      case 2: self = .localhost
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .runtimeDefault: return 0
      case .unconfined: return 1
      case .localhost: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Runtime_V1_SecurityProfile.ProfileType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Runtime_V1_SecurityProfile.ProfileType] = [
    .runtimeDefault,
    .unconfined,
    .localhost,
  ]
}

#endif  // swift(>=4.2)

/// LinuxPodSandboxConfig holds platform-specific configurations for Linux
/// host platforms and Linux-based containers.
struct Runtime_V1_LinuxPodSandboxConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent cgroup of the PodSandbox.
  /// The cgroupfs style syntax will be used, but the container runtime can
  /// convert it to systemd semantics if needed.
  var cgroupParent: String {
    get {return _storage._cgroupParent}
    set {_uniqueStorage()._cgroupParent = newValue}
  }

  /// LinuxSandboxSecurityContext holds sandbox security attributes.
  var securityContext: Runtime_V1_LinuxSandboxSecurityContext {
    get {return _storage._securityContext ?? Runtime_V1_LinuxSandboxSecurityContext()}
    set {_uniqueStorage()._securityContext = newValue}
  }
  /// Returns true if `securityContext` has been explicitly set.
  var hasSecurityContext: Bool {return _storage._securityContext != nil}
  /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
  mutating func clearSecurityContext() {_uniqueStorage()._securityContext = nil}

  /// Sysctls holds linux sysctls config for the sandbox.
  var sysctls: Dictionary<String,String> {
    get {return _storage._sysctls}
    set {_uniqueStorage()._sysctls = newValue}
  }

  /// Optional overhead represents the overheads associated with this sandbox
  var overhead: Runtime_V1_LinuxContainerResources {
    get {return _storage._overhead ?? Runtime_V1_LinuxContainerResources()}
    set {_uniqueStorage()._overhead = newValue}
  }
  /// Returns true if `overhead` has been explicitly set.
  var hasOverhead: Bool {return _storage._overhead != nil}
  /// Clears the value of `overhead`. Subsequent reads from it will return its default value.
  mutating func clearOverhead() {_uniqueStorage()._overhead = nil}

  /// Optional resources represents the sum of container resources for this sandbox
  var resources: Runtime_V1_LinuxContainerResources {
    get {return _storage._resources ?? Runtime_V1_LinuxContainerResources()}
    set {_uniqueStorage()._resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  var hasResources: Bool {return _storage._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  mutating func clearResources() {_uniqueStorage()._resources = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodSandboxMetadata holds all necessary information for building the sandbox name.
/// The container runtime is encouraged to expose the metadata associated with the
/// PodSandbox in its user interface for better user experience. For example,
/// the runtime can construct a unique PodSandboxName based on the metadata.
struct Runtime_V1_PodSandboxMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Pod name of the sandbox. Same as the pod name in the Pod ObjectMeta.
  var name: String = String()

  /// Pod UID of the sandbox. Same as the pod UID in the Pod ObjectMeta.
  var uid: String = String()

  /// Pod namespace of the sandbox. Same as the pod namespace in the Pod ObjectMeta.
  var namespace: String = String()

  /// Attempt number of creating the sandbox. Default: 0.
  var attempt: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PodSandboxConfig holds all the required and optional fields for creating a
/// sandbox.
struct Runtime_V1_PodSandboxConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata of the sandbox. This information will uniquely identify the
  /// sandbox, and the runtime should leverage this to ensure correct
  /// operation. The runtime may also use this information to improve UX, such
  /// as by constructing a readable name.
  var metadata: Runtime_V1_PodSandboxMetadata {
    get {return _storage._metadata ?? Runtime_V1_PodSandboxMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Hostname of the sandbox. Hostname could only be empty when the pod
  /// network namespace is NODE.
  var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  /// Path to the directory on the host in which container log files are
  /// stored.
  /// By default the log of a container going into the LogDirectory will be
  /// hooked up to STDOUT and STDERR. However, the LogDirectory may contain
  /// binary log files with structured logging data from the individual
  /// containers. For example, the files might be newline separated JSON
  /// structured logs, systemd-journald journal files, gRPC trace files, etc.
  /// E.g.,
  ///     PodSandboxConfig.LogDirectory = `/var/log/pods/<NAMESPACE>_<NAME>_<UID>/`
  ///     ContainerConfig.LogPath = `containerName/Instance#.log`
  var logDirectory: String {
    get {return _storage._logDirectory}
    set {_uniqueStorage()._logDirectory = newValue}
  }

  /// DNS config for the sandbox.
  var dnsConfig: Runtime_V1_DNSConfig {
    get {return _storage._dnsConfig ?? Runtime_V1_DNSConfig()}
    set {_uniqueStorage()._dnsConfig = newValue}
  }
  /// Returns true if `dnsConfig` has been explicitly set.
  var hasDnsConfig: Bool {return _storage._dnsConfig != nil}
  /// Clears the value of `dnsConfig`. Subsequent reads from it will return its default value.
  mutating func clearDnsConfig() {_uniqueStorage()._dnsConfig = nil}

  /// Port mappings for the sandbox.
  var portMappings: [Runtime_V1_PortMapping] {
    get {return _storage._portMappings}
    set {_uniqueStorage()._portMappings = newValue}
  }

  /// Key-value pairs that may be used to scope and select individual resources.
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Unstructured key-value map that may be set by the kubelet to store and
  /// retrieve arbitrary metadata. This will include any annotations set on a
  /// pod through the Kubernetes API.
  ///
  /// Annotations MUST NOT be altered by the runtime; the annotations stored
  /// here MUST be returned in the PodSandboxStatus associated with the pod
  /// this PodSandboxConfig creates.
  ///
  /// In general, in order to preserve a well-defined interface between the
  /// kubelet and the container runtime, annotations SHOULD NOT influence
  /// runtime behaviour.
  ///
  /// Annotations can also be useful for runtime authors to experiment with
  /// new features that are opaque to the Kubernetes APIs (both user-facing
  /// and the CRI). Whenever possible, however, runtime authors SHOULD
  /// consider proposing new typed fields for any new features instead.
  var annotations: Dictionary<String,String> {
    get {return _storage._annotations}
    set {_uniqueStorage()._annotations = newValue}
  }

  /// Optional configurations specific to Linux hosts.
  var linux: Runtime_V1_LinuxPodSandboxConfig {
    get {return _storage._linux ?? Runtime_V1_LinuxPodSandboxConfig()}
    set {_uniqueStorage()._linux = newValue}
  }
  /// Returns true if `linux` has been explicitly set.
  var hasLinux: Bool {return _storage._linux != nil}
  /// Clears the value of `linux`. Subsequent reads from it will return its default value.
  mutating func clearLinux() {_uniqueStorage()._linux = nil}

  /// Optional configurations specific to Windows hosts.
  var windows: Runtime_V1_WindowsPodSandboxConfig {
    get {return _storage._windows ?? Runtime_V1_WindowsPodSandboxConfig()}
    set {_uniqueStorage()._windows = newValue}
  }
  /// Returns true if `windows` has been explicitly set.
  var hasWindows: Bool {return _storage._windows != nil}
  /// Clears the value of `windows`. Subsequent reads from it will return its default value.
  mutating func clearWindows() {_uniqueStorage()._windows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_RunPodSandboxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration for creating a PodSandbox.
  var config: Runtime_V1_PodSandboxConfig {
    get {return _config ?? Runtime_V1_PodSandboxConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  /// Named runtime configuration to use for this PodSandbox.
  /// If the runtime handler is unknown, this request should be rejected.  An
  /// empty string should select the default handler, equivalent to the
  /// behavior before this feature was added.
  /// See https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
  var runtimeHandler: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: Runtime_V1_PodSandboxConfig? = nil
}

struct Runtime_V1_RunPodSandboxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the PodSandbox to run.
  var podSandboxID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_StopPodSandboxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the PodSandbox to stop.
  var podSandboxID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_StopPodSandboxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RemovePodSandboxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the PodSandbox to remove.
  var podSandboxID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RemovePodSandboxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_PodSandboxStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the PodSandbox for which to retrieve status.
  var podSandboxID: String = String()

  /// Verbose indicates whether to return extra information about the pod sandbox.
  var verbose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PodIP represents an ip of a Pod
struct Runtime_V1_PodIP {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// an ip is a string representation of an IPv4 or an IPv6
  var ip: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PodSandboxNetworkStatus is the status of the network for a PodSandbox.
/// Currently ignored for pods sharing the host networking namespace.
struct Runtime_V1_PodSandboxNetworkStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IP address of the PodSandbox.
  var ip: String = String()

  /// list of additional ips (not inclusive of PodSandboxNetworkStatus.Ip) of the PodSandBoxNetworkStatus
  var additionalIps: [Runtime_V1_PodIP] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Namespace contains paths to the namespaces.
struct Runtime_V1_Namespace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace options for Linux namespaces.
  var options: Runtime_V1_NamespaceOption {
    get {return _options ?? Runtime_V1_NamespaceOption()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _options: Runtime_V1_NamespaceOption? = nil
}

/// LinuxSandboxStatus contains status specific to Linux sandboxes.
struct Runtime_V1_LinuxPodSandboxStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Paths to the sandbox's namespaces.
  var namespaces: Runtime_V1_Namespace {
    get {return _namespaces ?? Runtime_V1_Namespace()}
    set {_namespaces = newValue}
  }
  /// Returns true if `namespaces` has been explicitly set.
  var hasNamespaces: Bool {return self._namespaces != nil}
  /// Clears the value of `namespaces`. Subsequent reads from it will return its default value.
  mutating func clearNamespaces() {self._namespaces = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _namespaces: Runtime_V1_Namespace? = nil
}

/// PodSandboxStatus contains the status of the PodSandbox.
struct Runtime_V1_PodSandboxStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the sandbox.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Metadata of the sandbox.
  var metadata: Runtime_V1_PodSandboxMetadata {
    get {return _storage._metadata ?? Runtime_V1_PodSandboxMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// State of the sandbox.
  var state: Runtime_V1_PodSandboxState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Creation timestamp of the sandbox in nanoseconds. Must be > 0.
  var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  /// Network contains network status if network is handled by the runtime.
  var network: Runtime_V1_PodSandboxNetworkStatus {
    get {return _storage._network ?? Runtime_V1_PodSandboxNetworkStatus()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  /// Linux-specific status to a pod sandbox.
  var linux: Runtime_V1_LinuxPodSandboxStatus {
    get {return _storage._linux ?? Runtime_V1_LinuxPodSandboxStatus()}
    set {_uniqueStorage()._linux = newValue}
  }
  /// Returns true if `linux` has been explicitly set.
  var hasLinux: Bool {return _storage._linux != nil}
  /// Clears the value of `linux`. Subsequent reads from it will return its default value.
  mutating func clearLinux() {_uniqueStorage()._linux = nil}

  /// Labels are key-value pairs that may be used to scope and select individual resources.
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Unstructured key-value map holding arbitrary metadata.
  /// Annotations MUST NOT be altered by the runtime; the value of this field
  /// MUST be identical to that of the corresponding PodSandboxConfig used to
  /// instantiate the pod sandbox this status represents.
  var annotations: Dictionary<String,String> {
    get {return _storage._annotations}
    set {_uniqueStorage()._annotations = newValue}
  }

  /// runtime configuration used for this PodSandbox.
  var runtimeHandler: String {
    get {return _storage._runtimeHandler}
    set {_uniqueStorage()._runtimeHandler = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_PodSandboxStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the PodSandbox.
  var status: Runtime_V1_PodSandboxStatus {
    get {return _status ?? Runtime_V1_PodSandboxStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Info is extra information of the PodSandbox. The key could be arbitrary string, and
  /// value should be in json format. The information could include anything useful for
  /// debug, e.g. network namespace for linux container based container runtime.
  /// It should only be returned non-empty when Verbose is true.
  var info: Dictionary<String,String> = [:]

  /// Container statuses
  var containersStatuses: [Runtime_V1_ContainerStatus] = []

  /// Timestamp at which container and pod statuses were recorded
  var timestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: Runtime_V1_PodSandboxStatus? = nil
}

/// PodSandboxStateValue is the wrapper of PodSandboxState.
struct Runtime_V1_PodSandboxStateValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// State of the sandbox.
  var state: Runtime_V1_PodSandboxState = .sandboxReady

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PodSandboxFilter is used to filter a list of PodSandboxes.
/// All those fields are combined with 'AND'
struct Runtime_V1_PodSandboxFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the sandbox.
  var id: String = String()

  /// State of the sandbox.
  var state: Runtime_V1_PodSandboxStateValue {
    get {return _state ?? Runtime_V1_PodSandboxStateValue()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  /// LabelSelector to select matches.
  /// Only api.MatchLabels is supported for now and the requirements
  /// are ANDed. MatchExpressions is not supported yet.
  var labelSelector: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Runtime_V1_PodSandboxStateValue? = nil
}

struct Runtime_V1_ListPodSandboxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PodSandboxFilter to filter a list of PodSandboxes.
  var filter: Runtime_V1_PodSandboxFilter {
    get {return _filter ?? Runtime_V1_PodSandboxFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {self._filter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filter: Runtime_V1_PodSandboxFilter? = nil
}

/// PodSandbox contains minimal information about a sandbox.
struct Runtime_V1_PodSandbox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the PodSandbox.
  var id: String = String()

  /// Metadata of the PodSandbox.
  var metadata: Runtime_V1_PodSandboxMetadata {
    get {return _metadata ?? Runtime_V1_PodSandboxMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// State of the PodSandbox.
  var state: Runtime_V1_PodSandboxState = .sandboxReady

  /// Creation timestamps of the PodSandbox in nanoseconds. Must be > 0.
  var createdAt: Int64 = 0

  /// Labels of the PodSandbox.
  var labels: Dictionary<String,String> = [:]

  /// Unstructured key-value map holding arbitrary metadata.
  /// Annotations MUST NOT be altered by the runtime; the value of this field
  /// MUST be identical to that of the corresponding PodSandboxConfig used to
  /// instantiate this PodSandbox.
  var annotations: Dictionary<String,String> = [:]

  /// runtime configuration used for this PodSandbox.
  var runtimeHandler: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Runtime_V1_PodSandboxMetadata? = nil
}

struct Runtime_V1_ListPodSandboxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of PodSandboxes.
  var items: [Runtime_V1_PodSandbox] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_PodSandboxStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the pod sandbox for which to retrieve stats.
  var podSandboxID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_PodSandboxStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stats: Runtime_V1_PodSandboxStats {
    get {return _stats ?? Runtime_V1_PodSandboxStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  mutating func clearStats() {self._stats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stats: Runtime_V1_PodSandboxStats? = nil
}

/// PodSandboxStatsFilter is used to filter the list of pod sandboxes to retrieve stats for.
/// All those fields are combined with 'AND'.
struct Runtime_V1_PodSandboxStatsFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the pod sandbox.
  var id: String = String()

  /// LabelSelector to select matches.
  /// Only api.MatchLabels is supported for now and the requirements
  /// are ANDed. MatchExpressions is not supported yet.
  var labelSelector: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ListPodSandboxStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter for the list request.
  var filter: Runtime_V1_PodSandboxStatsFilter {
    get {return _filter ?? Runtime_V1_PodSandboxStatsFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {self._filter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filter: Runtime_V1_PodSandboxStatsFilter? = nil
}

struct Runtime_V1_ListPodSandboxStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stats of the pod sandbox.
  var stats: [Runtime_V1_PodSandboxStats] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PodSandboxAttributes provides basic information of the pod sandbox.
struct Runtime_V1_PodSandboxAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the pod sandbox.
  var id: String = String()

  /// Metadata of the pod sandbox.
  var metadata: Runtime_V1_PodSandboxMetadata {
    get {return _metadata ?? Runtime_V1_PodSandboxMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Key-value pairs that may be used to scope and select individual resources.
  var labels: Dictionary<String,String> = [:]

  /// Unstructured key-value map holding arbitrary metadata.
  /// Annotations MUST NOT be altered by the runtime; the value of this field
  /// MUST be identical to that of the corresponding PodSandboxStatus used to
  /// instantiate the PodSandbox this status represents.
  var annotations: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Runtime_V1_PodSandboxMetadata? = nil
}

/// PodSandboxStats provides the resource usage statistics for a pod.
/// The linux or windows field will be populated depending on the platform.
struct Runtime_V1_PodSandboxStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information of the pod.
  var attributes: Runtime_V1_PodSandboxAttributes {
    get {return _attributes ?? Runtime_V1_PodSandboxAttributes()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {self._attributes = nil}

  /// Stats from linux.
  var linux: Runtime_V1_LinuxPodSandboxStats {
    get {return _linux ?? Runtime_V1_LinuxPodSandboxStats()}
    set {_linux = newValue}
  }
  /// Returns true if `linux` has been explicitly set.
  var hasLinux: Bool {return self._linux != nil}
  /// Clears the value of `linux`. Subsequent reads from it will return its default value.
  mutating func clearLinux() {self._linux = nil}

  /// Stats from windows.
  var windows: Runtime_V1_WindowsPodSandboxStats {
    get {return _windows ?? Runtime_V1_WindowsPodSandboxStats()}
    set {_windows = newValue}
  }
  /// Returns true if `windows` has been explicitly set.
  var hasWindows: Bool {return self._windows != nil}
  /// Clears the value of `windows`. Subsequent reads from it will return its default value.
  mutating func clearWindows() {self._windows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attributes: Runtime_V1_PodSandboxAttributes? = nil
  fileprivate var _linux: Runtime_V1_LinuxPodSandboxStats? = nil
  fileprivate var _windows: Runtime_V1_WindowsPodSandboxStats? = nil
}

/// LinuxPodSandboxStats provides the resource usage statistics for a pod sandbox on linux.
struct Runtime_V1_LinuxPodSandboxStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CPU usage gathered for the pod sandbox.
  var cpu: Runtime_V1_CpuUsage {
    get {return _storage._cpu ?? Runtime_V1_CpuUsage()}
    set {_uniqueStorage()._cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  var hasCpu: Bool {return _storage._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  mutating func clearCpu() {_uniqueStorage()._cpu = nil}

  /// Memory usage gathered for the pod sandbox.
  var memory: Runtime_V1_MemoryUsage {
    get {return _storage._memory ?? Runtime_V1_MemoryUsage()}
    set {_uniqueStorage()._memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  var hasMemory: Bool {return _storage._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  mutating func clearMemory() {_uniqueStorage()._memory = nil}

  /// Network usage gathered for the pod sandbox
  var network: Runtime_V1_NetworkUsage {
    get {return _storage._network ?? Runtime_V1_NetworkUsage()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  /// Stats pertaining to processes in the pod sandbox.
  var process: Runtime_V1_ProcessUsage {
    get {return _storage._process ?? Runtime_V1_ProcessUsage()}
    set {_uniqueStorage()._process = newValue}
  }
  /// Returns true if `process` has been explicitly set.
  var hasProcess: Bool {return _storage._process != nil}
  /// Clears the value of `process`. Subsequent reads from it will return its default value.
  mutating func clearProcess() {_uniqueStorage()._process = nil}

  /// Stats of containers in the measured pod sandbox.
  var containers: [Runtime_V1_ContainerStats] {
    get {return _storage._containers}
    set {_uniqueStorage()._containers = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WindowsPodSandboxStats provides the resource usage statistics for a pod sandbox on windows
struct Runtime_V1_WindowsPodSandboxStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CPU usage gathered for the pod sandbox.
  var cpu: Runtime_V1_WindowsCpuUsage {
    get {return _storage._cpu ?? Runtime_V1_WindowsCpuUsage()}
    set {_uniqueStorage()._cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  var hasCpu: Bool {return _storage._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  mutating func clearCpu() {_uniqueStorage()._cpu = nil}

  /// Memory usage gathered for the pod sandbox.
  var memory: Runtime_V1_WindowsMemoryUsage {
    get {return _storage._memory ?? Runtime_V1_WindowsMemoryUsage()}
    set {_uniqueStorage()._memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  var hasMemory: Bool {return _storage._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  mutating func clearMemory() {_uniqueStorage()._memory = nil}

  /// Network usage gathered for the pod sandbox
  var network: Runtime_V1_WindowsNetworkUsage {
    get {return _storage._network ?? Runtime_V1_WindowsNetworkUsage()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  /// Stats pertaining to processes in the pod sandbox.
  var process: Runtime_V1_WindowsProcessUsage {
    get {return _storage._process ?? Runtime_V1_WindowsProcessUsage()}
    set {_uniqueStorage()._process = newValue}
  }
  /// Returns true if `process` has been explicitly set.
  var hasProcess: Bool {return _storage._process != nil}
  /// Clears the value of `process`. Subsequent reads from it will return its default value.
  mutating func clearProcess() {_uniqueStorage()._process = nil}

  /// Stats of containers in the measured pod sandbox.
  var containers: [Runtime_V1_WindowsContainerStats] {
    get {return _storage._containers}
    set {_uniqueStorage()._containers = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NetworkUsage contains data about network resources.
struct Runtime_V1_NetworkUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// Stats for the default network interface.
  var defaultInterface: Runtime_V1_NetworkInterfaceUsage {
    get {return _defaultInterface ?? Runtime_V1_NetworkInterfaceUsage()}
    set {_defaultInterface = newValue}
  }
  /// Returns true if `defaultInterface` has been explicitly set.
  var hasDefaultInterface: Bool {return self._defaultInterface != nil}
  /// Clears the value of `defaultInterface`. Subsequent reads from it will return its default value.
  mutating func clearDefaultInterface() {self._defaultInterface = nil}

  /// Stats for all found network interfaces, excluding the default.
  var interfaces: [Runtime_V1_NetworkInterfaceUsage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _defaultInterface: Runtime_V1_NetworkInterfaceUsage? = nil
}

/// WindowsNetworkUsage contains data about network resources specific to Windows.
struct Runtime_V1_WindowsNetworkUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// Stats for the default network interface.
  var defaultInterface: Runtime_V1_WindowsNetworkInterfaceUsage {
    get {return _defaultInterface ?? Runtime_V1_WindowsNetworkInterfaceUsage()}
    set {_defaultInterface = newValue}
  }
  /// Returns true if `defaultInterface` has been explicitly set.
  var hasDefaultInterface: Bool {return self._defaultInterface != nil}
  /// Clears the value of `defaultInterface`. Subsequent reads from it will return its default value.
  mutating func clearDefaultInterface() {self._defaultInterface = nil}

  /// Stats for all found network interfaces, excluding the default.
  var interfaces: [Runtime_V1_WindowsNetworkInterfaceUsage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _defaultInterface: Runtime_V1_WindowsNetworkInterfaceUsage? = nil
}

/// NetworkInterfaceUsage contains resource value data about a network interface.
struct Runtime_V1_NetworkInterfaceUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the network interface.
  var name: String = String()

  /// Cumulative count of bytes received.
  var rxBytes: Runtime_V1_UInt64Value {
    get {return _rxBytes ?? Runtime_V1_UInt64Value()}
    set {_rxBytes = newValue}
  }
  /// Returns true if `rxBytes` has been explicitly set.
  var hasRxBytes: Bool {return self._rxBytes != nil}
  /// Clears the value of `rxBytes`. Subsequent reads from it will return its default value.
  mutating func clearRxBytes() {self._rxBytes = nil}

  /// Cumulative count of receive errors encountered.
  var rxErrors: Runtime_V1_UInt64Value {
    get {return _rxErrors ?? Runtime_V1_UInt64Value()}
    set {_rxErrors = newValue}
  }
  /// Returns true if `rxErrors` has been explicitly set.
  var hasRxErrors: Bool {return self._rxErrors != nil}
  /// Clears the value of `rxErrors`. Subsequent reads from it will return its default value.
  mutating func clearRxErrors() {self._rxErrors = nil}

  /// Cumulative count of bytes transmitted.
  var txBytes: Runtime_V1_UInt64Value {
    get {return _txBytes ?? Runtime_V1_UInt64Value()}
    set {_txBytes = newValue}
  }
  /// Returns true if `txBytes` has been explicitly set.
  var hasTxBytes: Bool {return self._txBytes != nil}
  /// Clears the value of `txBytes`. Subsequent reads from it will return its default value.
  mutating func clearTxBytes() {self._txBytes = nil}

  /// Cumulative count of transmit errors encountered.
  var txErrors: Runtime_V1_UInt64Value {
    get {return _txErrors ?? Runtime_V1_UInt64Value()}
    set {_txErrors = newValue}
  }
  /// Returns true if `txErrors` has been explicitly set.
  var hasTxErrors: Bool {return self._txErrors != nil}
  /// Clears the value of `txErrors`. Subsequent reads from it will return its default value.
  mutating func clearTxErrors() {self._txErrors = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rxBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _rxErrors: Runtime_V1_UInt64Value? = nil
  fileprivate var _txBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _txErrors: Runtime_V1_UInt64Value? = nil
}

/// WindowsNetworkInterfaceUsage contains resource value data about a network interface specific for Windows.
struct Runtime_V1_WindowsNetworkInterfaceUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the network interface.
  var name: String = String()

  /// Cumulative count of bytes received.
  var rxBytes: Runtime_V1_UInt64Value {
    get {return _rxBytes ?? Runtime_V1_UInt64Value()}
    set {_rxBytes = newValue}
  }
  /// Returns true if `rxBytes` has been explicitly set.
  var hasRxBytes: Bool {return self._rxBytes != nil}
  /// Clears the value of `rxBytes`. Subsequent reads from it will return its default value.
  mutating func clearRxBytes() {self._rxBytes = nil}

  /// Cumulative count of receive errors encountered.
  var rxPacketsDropped: Runtime_V1_UInt64Value {
    get {return _rxPacketsDropped ?? Runtime_V1_UInt64Value()}
    set {_rxPacketsDropped = newValue}
  }
  /// Returns true if `rxPacketsDropped` has been explicitly set.
  var hasRxPacketsDropped: Bool {return self._rxPacketsDropped != nil}
  /// Clears the value of `rxPacketsDropped`. Subsequent reads from it will return its default value.
  mutating func clearRxPacketsDropped() {self._rxPacketsDropped = nil}

  /// Cumulative count of bytes transmitted.
  var txBytes: Runtime_V1_UInt64Value {
    get {return _txBytes ?? Runtime_V1_UInt64Value()}
    set {_txBytes = newValue}
  }
  /// Returns true if `txBytes` has been explicitly set.
  var hasTxBytes: Bool {return self._txBytes != nil}
  /// Clears the value of `txBytes`. Subsequent reads from it will return its default value.
  mutating func clearTxBytes() {self._txBytes = nil}

  /// Cumulative count of transmit errors encountered.
  var txPacketsDropped: Runtime_V1_UInt64Value {
    get {return _txPacketsDropped ?? Runtime_V1_UInt64Value()}
    set {_txPacketsDropped = newValue}
  }
  /// Returns true if `txPacketsDropped` has been explicitly set.
  var hasTxPacketsDropped: Bool {return self._txPacketsDropped != nil}
  /// Clears the value of `txPacketsDropped`. Subsequent reads from it will return its default value.
  mutating func clearTxPacketsDropped() {self._txPacketsDropped = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rxBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _rxPacketsDropped: Runtime_V1_UInt64Value? = nil
  fileprivate var _txBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _txPacketsDropped: Runtime_V1_UInt64Value? = nil
}

/// ProcessUsage are stats pertaining to processes.
struct Runtime_V1_ProcessUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// Number of processes.
  var processCount: Runtime_V1_UInt64Value {
    get {return _processCount ?? Runtime_V1_UInt64Value()}
    set {_processCount = newValue}
  }
  /// Returns true if `processCount` has been explicitly set.
  var hasProcessCount: Bool {return self._processCount != nil}
  /// Clears the value of `processCount`. Subsequent reads from it will return its default value.
  mutating func clearProcessCount() {self._processCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _processCount: Runtime_V1_UInt64Value? = nil
}

/// WindowsProcessUsage are stats pertaining to processes specific to Windows.
struct Runtime_V1_WindowsProcessUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// Number of processes.
  var processCount: Runtime_V1_UInt64Value {
    get {return _processCount ?? Runtime_V1_UInt64Value()}
    set {_processCount = newValue}
  }
  /// Returns true if `processCount` has been explicitly set.
  var hasProcessCount: Bool {return self._processCount != nil}
  /// Clears the value of `processCount`. Subsequent reads from it will return its default value.
  mutating func clearProcessCount() {self._processCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _processCount: Runtime_V1_UInt64Value? = nil
}

/// ImageSpec is an internal representation of an image.
struct Runtime_V1_ImageSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Container's Image field (e.g. imageID or imageDigest).
  var image: String = String()

  /// Unstructured key-value map holding arbitrary metadata.
  /// ImageSpec Annotations can be used to help the runtime target specific
  /// images in multi-arch images.
  var annotations: Dictionary<String,String> = [:]

  /// The container image reference specified by the user (e.g. image[:tag] or digest).
  /// Only set if available within the RPC context.
  var userSpecifiedImage: String = String()

  /// Runtime handler to use for pulling the image.
  /// If the runtime handler is unknown, the request should be rejected.
  /// An empty string would select the default runtime handler.
  var runtimeHandler: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_KeyValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LinuxContainerResources specifies Linux specific configuration for
/// resources.
struct Runtime_V1_LinuxContainerResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CPU CFS (Completely Fair Scheduler) period. Default: 0 (not specified).
  var cpuPeriod: Int64 = 0

  /// CPU CFS (Completely Fair Scheduler) quota. Default: 0 (not specified).
  var cpuQuota: Int64 = 0

  /// CPU shares (relative weight vs. other containers). Default: 0 (not specified).
  var cpuShares: Int64 = 0

  /// Memory limit in bytes. Default: 0 (not specified).
  var memoryLimitInBytes: Int64 = 0

  /// OOMScoreAdj adjusts the oom-killer score. Default: 0 (not specified).
  var oomScoreAdj: Int64 = 0

  /// CpusetCpus constrains the allowed set of logical CPUs. Default: "" (not specified).
  var cpusetCpus: String = String()

  /// CpusetMems constrains the allowed set of memory nodes. Default: "" (not specified).
  var cpusetMems: String = String()

  /// List of HugepageLimits to limit the HugeTLB usage of container per page size. Default: nil (not specified).
  var hugepageLimits: [Runtime_V1_HugepageLimit] = []

  /// Unified resources for cgroup v2. Default: nil (not specified).
  /// Each key/value in the map refers to the cgroup v2.
  /// e.g. "memory.max": "6937202688" or "io.weight": "default 100".
  var unified: Dictionary<String,String> = [:]

  /// Memory swap limit in bytes. Default 0 (not specified).
  var memorySwapLimitInBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// HugepageLimit corresponds to the file`hugetlb.<hugepagesize>.limit_in_byte` in container level cgroup.
/// For example, `PageSize=1GB`, `Limit=1073741824` means setting `1073741824` bytes to hugetlb.1GB.limit_in_bytes.
struct Runtime_V1_HugepageLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value of PageSize has the format <size><unit-prefix>B (2MB, 1GB),
  /// and must match the <hugepagesize> of the corresponding control file found in `hugetlb.<hugepagesize>.limit_in_bytes`.
  /// The values of <unit-prefix> are intended to be parsed using base 1024("1KB" = 1024, "1MB" = 1048576, etc).
  var pageSize: String = String()

  /// limit in bytes of hugepagesize HugeTLB usage.
  var limit: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SELinuxOption are the labels to be applied to the container.
struct Runtime_V1_SELinuxOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var user: String = String()

  var role: String = String()

  var type: String = String()

  var level: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Capability contains the container capabilities to add or drop
/// Dropping a capability will drop it from all sets.
/// If a capability is added to only the add_capabilities list then it gets added to permitted,
/// inheritable, effective and bounding sets, i.e. all sets except the ambient set.
/// If a capability is added to only the add_ambient_capabilities list then it gets added to all sets, i.e permitted
/// inheritable, effective, bounding and ambient sets.
/// If a capability is added to add_capabilities and add_ambient_capabilities lists then it gets added to all sets, i.e.
/// permitted, inheritable, effective, bounding and ambient sets.
struct Runtime_V1_Capability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of capabilities to add.
  var addCapabilities: [String] = []

  /// List of capabilities to drop.
  var dropCapabilities: [String] = []

  /// List of ambient capabilities to add.
  var addAmbientCapabilities: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LinuxContainerSecurityContext holds linux security configuration that will be applied to a container.
struct Runtime_V1_LinuxContainerSecurityContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Capabilities to add or drop.
  var capabilities: Runtime_V1_Capability {
    get {return _storage._capabilities ?? Runtime_V1_Capability()}
    set {_uniqueStorage()._capabilities = newValue}
  }
  /// Returns true if `capabilities` has been explicitly set.
  var hasCapabilities: Bool {return _storage._capabilities != nil}
  /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
  mutating func clearCapabilities() {_uniqueStorage()._capabilities = nil}

  /// If set, run container in privileged mode.
  /// Privileged mode is incompatible with the following options. If
  /// privileged is set, the following features MAY have no effect:
  /// 1. capabilities
  /// 2. selinux_options
  /// 4. seccomp
  /// 5. apparmor
  ///
  /// Privileged mode implies the following specific options are applied:
  /// 1. All capabilities are added.
  /// 2. Sensitive paths, such as kernel module paths within sysfs, are not masked.
  /// 3. Any sysfs and procfs mounts are mounted RW.
  /// 4. AppArmor confinement is not applied.
  /// 5. Seccomp restrictions are not applied.
  /// 6. The device cgroup does not restrict access to any devices.
  /// 7. All devices from the host's /dev are available within the container.
  /// 8. SELinux restrictions are not applied (e.g. label=disabled).
  var privileged: Bool {
    get {return _storage._privileged}
    set {_uniqueStorage()._privileged = newValue}
  }

  /// Configurations for the container's namespaces.
  /// Only used if the container uses namespace for isolation.
  var namespaceOptions: Runtime_V1_NamespaceOption {
    get {return _storage._namespaceOptions ?? Runtime_V1_NamespaceOption()}
    set {_uniqueStorage()._namespaceOptions = newValue}
  }
  /// Returns true if `namespaceOptions` has been explicitly set.
  var hasNamespaceOptions: Bool {return _storage._namespaceOptions != nil}
  /// Clears the value of `namespaceOptions`. Subsequent reads from it will return its default value.
  mutating func clearNamespaceOptions() {_uniqueStorage()._namespaceOptions = nil}

  /// SELinux context to be optionally applied.
  var selinuxOptions: Runtime_V1_SELinuxOption {
    get {return _storage._selinuxOptions ?? Runtime_V1_SELinuxOption()}
    set {_uniqueStorage()._selinuxOptions = newValue}
  }
  /// Returns true if `selinuxOptions` has been explicitly set.
  var hasSelinuxOptions: Bool {return _storage._selinuxOptions != nil}
  /// Clears the value of `selinuxOptions`. Subsequent reads from it will return its default value.
  mutating func clearSelinuxOptions() {_uniqueStorage()._selinuxOptions = nil}

  /// UID to run the container process as. Only one of run_as_user and
  /// run_as_username can be specified at a time.
  var runAsUser: Runtime_V1_Int64Value {
    get {return _storage._runAsUser ?? Runtime_V1_Int64Value()}
    set {_uniqueStorage()._runAsUser = newValue}
  }
  /// Returns true if `runAsUser` has been explicitly set.
  var hasRunAsUser: Bool {return _storage._runAsUser != nil}
  /// Clears the value of `runAsUser`. Subsequent reads from it will return its default value.
  mutating func clearRunAsUser() {_uniqueStorage()._runAsUser = nil}

  /// GID to run the container process as. run_as_group should only be specified
  /// when run_as_user or run_as_username is specified; otherwise, the runtime
  /// MUST error.
  var runAsGroup: Runtime_V1_Int64Value {
    get {return _storage._runAsGroup ?? Runtime_V1_Int64Value()}
    set {_uniqueStorage()._runAsGroup = newValue}
  }
  /// Returns true if `runAsGroup` has been explicitly set.
  var hasRunAsGroup: Bool {return _storage._runAsGroup != nil}
  /// Clears the value of `runAsGroup`. Subsequent reads from it will return its default value.
  mutating func clearRunAsGroup() {_uniqueStorage()._runAsGroup = nil}

  /// User name to run the container process as. If specified, the user MUST
  /// exist in the container image (i.e. in the /etc/passwd inside the image),
  /// and be resolved there by the runtime; otherwise, the runtime MUST error.
  var runAsUsername: String {
    get {return _storage._runAsUsername}
    set {_uniqueStorage()._runAsUsername = newValue}
  }

  /// If set, the root filesystem of the container is read-only.
  var readonlyRootfs: Bool {
    get {return _storage._readonlyRootfs}
    set {_uniqueStorage()._readonlyRootfs = newValue}
  }

  /// List of groups applied to the first process run in each container.
  /// supplemental_groups_policy can control how groups will be calculated.
  var supplementalGroups: [Int64] {
    get {return _storage._supplementalGroups}
    set {_uniqueStorage()._supplementalGroups = newValue}
  }

  /// supplemental_groups_policy defines how supplemental groups of the first 
  /// container processes are calculated.
  /// Valid values are "Merge" and "Strict".
  /// If not specified, "Merge" is used.
  var supplementalGroupsPolicy: Runtime_V1_SupplementalGroupsPolicy {
    get {return _storage._supplementalGroupsPolicy}
    set {_uniqueStorage()._supplementalGroupsPolicy = newValue}
  }

  /// no_new_privs defines if the flag for no_new_privs should be set on the
  /// container.
  var noNewPrivs: Bool {
    get {return _storage._noNewPrivs}
    set {_uniqueStorage()._noNewPrivs = newValue}
  }

  /// masked_paths is a slice of paths that should be masked by the container
  /// runtime, this can be passed directly to the OCI spec.
  var maskedPaths: [String] {
    get {return _storage._maskedPaths}
    set {_uniqueStorage()._maskedPaths = newValue}
  }

  /// readonly_paths is a slice of paths that should be set as readonly by the
  /// container runtime, this can be passed directly to the OCI spec.
  var readonlyPaths: [String] {
    get {return _storage._readonlyPaths}
    set {_uniqueStorage()._readonlyPaths = newValue}
  }

  /// Seccomp profile for the container.
  var seccomp: Runtime_V1_SecurityProfile {
    get {return _storage._seccomp ?? Runtime_V1_SecurityProfile()}
    set {_uniqueStorage()._seccomp = newValue}
  }
  /// Returns true if `seccomp` has been explicitly set.
  var hasSeccomp: Bool {return _storage._seccomp != nil}
  /// Clears the value of `seccomp`. Subsequent reads from it will return its default value.
  mutating func clearSeccomp() {_uniqueStorage()._seccomp = nil}

  /// AppArmor profile for the container.
  var apparmor: Runtime_V1_SecurityProfile {
    get {return _storage._apparmor ?? Runtime_V1_SecurityProfile()}
    set {_uniqueStorage()._apparmor = newValue}
  }
  /// Returns true if `apparmor` has been explicitly set.
  var hasApparmor: Bool {return _storage._apparmor != nil}
  /// Clears the value of `apparmor`. Subsequent reads from it will return its default value.
  mutating func clearApparmor() {_uniqueStorage()._apparmor = nil}

  /// AppArmor profile for the container, candidate values are:
  /// * runtime/default: equivalent to not specifying a profile.
  /// * unconfined: no profiles are loaded
  /// * localhost/<profile_name>: profile loaded on the node
  ///    (localhost) by name. The possible profile names are detailed at
  ///    https://gitlab.com/apparmor/apparmor/-/wikis/AppArmor_Core_Policy_Reference
  var apparmorProfile: String {
    get {return _storage._apparmorProfile}
    set {_uniqueStorage()._apparmorProfile = newValue}
  }

  /// Seccomp profile for the container, candidate values are:
  /// * runtime/default: the default profile for the container runtime
  /// * unconfined: unconfined profile, ie, no seccomp sandboxing
  /// * localhost/<full-path-to-profile>: the profile installed on the node.
  ///   <full-path-to-profile> is the full path of the profile.
  /// Default: "", which is identical with unconfined.
  var seccompProfilePath: String {
    get {return _storage._seccompProfilePath}
    set {_uniqueStorage()._seccompProfilePath = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LinuxContainerConfig contains platform-specific configuration for
/// Linux-based containers.
struct Runtime_V1_LinuxContainerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resources specification for the container.
  var resources: Runtime_V1_LinuxContainerResources {
    get {return _resources ?? Runtime_V1_LinuxContainerResources()}
    set {_resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  var hasResources: Bool {return self._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  mutating func clearResources() {self._resources = nil}

  /// LinuxContainerSecurityContext configuration for the container.
  var securityContext: Runtime_V1_LinuxContainerSecurityContext {
    get {return _securityContext ?? Runtime_V1_LinuxContainerSecurityContext()}
    set {_securityContext = newValue}
  }
  /// Returns true if `securityContext` has been explicitly set.
  var hasSecurityContext: Bool {return self._securityContext != nil}
  /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
  mutating func clearSecurityContext() {self._securityContext = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resources: Runtime_V1_LinuxContainerResources? = nil
  fileprivate var _securityContext: Runtime_V1_LinuxContainerSecurityContext? = nil
}

struct Runtime_V1_LinuxContainerUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uid is the primary uid initially attached to the first process in the container
  var uid: Int64 = 0

  /// gid is the primary gid initially attached to the first process in the container
  var gid: Int64 = 0

  /// supplemental_groups are the supplemental groups initially attached to the first process in the container
  var supplementalGroups: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WindowsNamespaceOption provides options for Windows namespaces.
struct Runtime_V1_WindowsNamespaceOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network namespace for this container/sandbox.
  /// Namespaces currently set by the kubelet: POD, NODE
  var network: Runtime_V1_NamespaceMode = .pod

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WindowsSandboxSecurityContext holds platform-specific configurations that will be
/// applied to a sandbox.
/// These settings will only apply to the sandbox container.
struct Runtime_V1_WindowsSandboxSecurityContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User name to run the container process as. If specified, the user MUST
  /// exist in the container image and be resolved there by the runtime;
  /// otherwise, the runtime MUST return error.
  var runAsUsername: String = String()

  /// The contents of the GMSA credential spec to use to run this container.
  var credentialSpec: String = String()

  /// Indicates whether the container requested to run as a HostProcess container.
  var hostProcess: Bool = false

  /// Configuration for the sandbox's namespaces
  var namespaceOptions: Runtime_V1_WindowsNamespaceOption {
    get {return _namespaceOptions ?? Runtime_V1_WindowsNamespaceOption()}
    set {_namespaceOptions = newValue}
  }
  /// Returns true if `namespaceOptions` has been explicitly set.
  var hasNamespaceOptions: Bool {return self._namespaceOptions != nil}
  /// Clears the value of `namespaceOptions`. Subsequent reads from it will return its default value.
  mutating func clearNamespaceOptions() {self._namespaceOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _namespaceOptions: Runtime_V1_WindowsNamespaceOption? = nil
}

/// WindowsPodSandboxConfig holds platform-specific configurations for Windows
/// host platforms and Windows-based containers.
struct Runtime_V1_WindowsPodSandboxConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// WindowsSandboxSecurityContext holds sandbox security attributes.
  var securityContext: Runtime_V1_WindowsSandboxSecurityContext {
    get {return _securityContext ?? Runtime_V1_WindowsSandboxSecurityContext()}
    set {_securityContext = newValue}
  }
  /// Returns true if `securityContext` has been explicitly set.
  var hasSecurityContext: Bool {return self._securityContext != nil}
  /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
  mutating func clearSecurityContext() {self._securityContext = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _securityContext: Runtime_V1_WindowsSandboxSecurityContext? = nil
}

/// WindowsContainerSecurityContext holds windows security configuration that will be applied to a container.
struct Runtime_V1_WindowsContainerSecurityContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User name to run the container process as. If specified, the user MUST
  /// exist in the container image and be resolved there by the runtime;
  /// otherwise, the runtime MUST return error.
  var runAsUsername: String = String()

  /// The contents of the GMSA credential spec to use to run this container.
  var credentialSpec: String = String()

  /// Indicates whether a container is to be run as a HostProcess container.
  var hostProcess: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WindowsContainerConfig contains platform-specific configuration for
/// Windows-based containers.
struct Runtime_V1_WindowsContainerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resources specification for the container.
  var resources: Runtime_V1_WindowsContainerResources {
    get {return _resources ?? Runtime_V1_WindowsContainerResources()}
    set {_resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  var hasResources: Bool {return self._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  mutating func clearResources() {self._resources = nil}

  /// WindowsContainerSecurityContext configuration for the container.
  var securityContext: Runtime_V1_WindowsContainerSecurityContext {
    get {return _securityContext ?? Runtime_V1_WindowsContainerSecurityContext()}
    set {_securityContext = newValue}
  }
  /// Returns true if `securityContext` has been explicitly set.
  var hasSecurityContext: Bool {return self._securityContext != nil}
  /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
  mutating func clearSecurityContext() {self._securityContext = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resources: Runtime_V1_WindowsContainerResources? = nil
  fileprivate var _securityContext: Runtime_V1_WindowsContainerSecurityContext? = nil
}

/// WindowsContainerResources specifies Windows specific configuration for
/// resources.
struct Runtime_V1_WindowsContainerResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CPU shares (relative weight vs. other containers). Default: 0 (not specified).
  var cpuShares: Int64 = 0

  /// Number of CPUs available to the container. Default: 0 (not specified).
  var cpuCount: Int64 = 0

  /// Specifies the portion of processor cycles that this container can use as a percentage times 100.
  var cpuMaximum: Int64 = 0

  /// Memory limit in bytes. Default: 0 (not specified).
  var memoryLimitInBytes: Int64 = 0

  /// Specifies the size of the rootfs / scratch space in bytes to be configured for this container. Default: 0 (not specified).
  var rootfsSizeInBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ContainerMetadata holds all necessary information for building the container
/// name. The container runtime is encouraged to expose the metadata in its user
/// interface for better user experience. E.g., runtime can construct a unique
/// container name based on the metadata. Note that (name, attempt) is unique
/// within a sandbox for the entire lifetime of the sandbox.
struct Runtime_V1_ContainerMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the container. Same as the container name in the PodSpec.
  var name: String = String()

  /// Attempt number of creating the container. Default: 0.
  var attempt: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Device specifies a host device to mount into a container.
struct Runtime_V1_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path of the device within the container.
  var containerPath: String = String()

  /// Path of the device on the host.
  var hostPath: String = String()

  /// Cgroups permissions of the device, candidates are one or more of
  /// * r - allows container to read from the specified device.
  /// * w - allows container to write to the specified device.
  /// * m - allows container to create device files that do not yet exist.
  var permissions: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CDIDevice specifies a CDI device information.
struct Runtime_V1_CDIDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fully qualified CDI device name
  /// for example: vendor.com/gpu=gpudevice1
  /// see more details in the CDI specification:
  /// https://github.com/container-orchestrated-devices/container-device-interface/blob/main/SPEC.md
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ContainerConfig holds all the required and optional fields for creating a
/// container.
struct Runtime_V1_ContainerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata of the container. This information will uniquely identify the
  /// container, and the runtime should leverage this to ensure correct
  /// operation. The runtime may also use this information to improve UX, such
  /// as by constructing a readable name.
  var metadata: Runtime_V1_ContainerMetadata {
    get {return _storage._metadata ?? Runtime_V1_ContainerMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Image to use.
  var image: Runtime_V1_ImageSpec {
    get {return _storage._image ?? Runtime_V1_ImageSpec()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  /// Command to execute (i.e., entrypoint for docker)
  var command: [String] {
    get {return _storage._command}
    set {_uniqueStorage()._command = newValue}
  }

  /// Args for the Command (i.e., command for docker)
  var args: [String] {
    get {return _storage._args}
    set {_uniqueStorage()._args = newValue}
  }

  /// Current working directory of the command.
  var workingDir: String {
    get {return _storage._workingDir}
    set {_uniqueStorage()._workingDir = newValue}
  }

  /// List of environment variable to set in the container.
  var envs: [Runtime_V1_KeyValue] {
    get {return _storage._envs}
    set {_uniqueStorage()._envs = newValue}
  }

  /// Mounts for the container.
  var mounts: [Runtime_V1_Mount] {
    get {return _storage._mounts}
    set {_uniqueStorage()._mounts = newValue}
  }

  /// Devices for the container.
  var devices: [Runtime_V1_Device] {
    get {return _storage._devices}
    set {_uniqueStorage()._devices = newValue}
  }

  /// Key-value pairs that may be used to scope and select individual resources.
  /// Label keys are of the form:
  ///     label-key ::= prefixed-name | name
  ///     prefixed-name ::= prefix '/' name
  ///     prefix ::= DNS_SUBDOMAIN
  ///     name ::= DNS_LABEL
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Unstructured key-value map that may be used by the kubelet to store and
  /// retrieve arbitrary metadata.
  ///
  /// Annotations MUST NOT be altered by the runtime; the annotations stored
  /// here MUST be returned in the ContainerStatus associated with the container
  /// this ContainerConfig creates.
  ///
  /// In general, in order to preserve a well-defined interface between the
  /// kubelet and the container runtime, annotations SHOULD NOT influence
  /// runtime behaviour.
  var annotations: Dictionary<String,String> {
    get {return _storage._annotations}
    set {_uniqueStorage()._annotations = newValue}
  }

  /// Path relative to PodSandboxConfig.LogDirectory for container to store
  /// the log (STDOUT and STDERR) on the host.
  /// E.g.,
  ///     PodSandboxConfig.LogDirectory = `/var/log/pods/<NAMESPACE>_<NAME>_<UID>/`
  ///     ContainerConfig.LogPath = `containerName/Instance#.log`
  var logPath: String {
    get {return _storage._logPath}
    set {_uniqueStorage()._logPath = newValue}
  }

  /// Variables for interactive containers, these have very specialized
  /// use-cases (e.g. debugging).
  var stdin: Bool {
    get {return _storage._stdin}
    set {_uniqueStorage()._stdin = newValue}
  }

  var stdinOnce: Bool {
    get {return _storage._stdinOnce}
    set {_uniqueStorage()._stdinOnce = newValue}
  }

  var tty: Bool {
    get {return _storage._tty}
    set {_uniqueStorage()._tty = newValue}
  }

  /// Configuration specific to Linux containers.
  var linux: Runtime_V1_LinuxContainerConfig {
    get {return _storage._linux ?? Runtime_V1_LinuxContainerConfig()}
    set {_uniqueStorage()._linux = newValue}
  }
  /// Returns true if `linux` has been explicitly set.
  var hasLinux: Bool {return _storage._linux != nil}
  /// Clears the value of `linux`. Subsequent reads from it will return its default value.
  mutating func clearLinux() {_uniqueStorage()._linux = nil}

  /// Configuration specific to Windows containers.
  var windows: Runtime_V1_WindowsContainerConfig {
    get {return _storage._windows ?? Runtime_V1_WindowsContainerConfig()}
    set {_uniqueStorage()._windows = newValue}
  }
  /// Returns true if `windows` has been explicitly set.
  var hasWindows: Bool {return _storage._windows != nil}
  /// Clears the value of `windows`. Subsequent reads from it will return its default value.
  mutating func clearWindows() {_uniqueStorage()._windows = nil}

  /// CDI devices for the container.
  var cdiDevices: [Runtime_V1_CDIDevice] {
    get {return _storage._cdiDevices}
    set {_uniqueStorage()._cdiDevices = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_CreateContainerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the PodSandbox in which the container should be created.
  var podSandboxID: String = String()

  /// Config of the container.
  var config: Runtime_V1_ContainerConfig {
    get {return _config ?? Runtime_V1_ContainerConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  /// Config of the PodSandbox. This is the same config that was passed
  /// to RunPodSandboxRequest to create the PodSandbox. It is passed again
  /// here just for easy reference. The PodSandboxConfig is immutable and
  /// remains the same throughout the lifetime of the pod.
  var sandboxConfig: Runtime_V1_PodSandboxConfig {
    get {return _sandboxConfig ?? Runtime_V1_PodSandboxConfig()}
    set {_sandboxConfig = newValue}
  }
  /// Returns true if `sandboxConfig` has been explicitly set.
  var hasSandboxConfig: Bool {return self._sandboxConfig != nil}
  /// Clears the value of `sandboxConfig`. Subsequent reads from it will return its default value.
  mutating func clearSandboxConfig() {self._sandboxConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: Runtime_V1_ContainerConfig? = nil
  fileprivate var _sandboxConfig: Runtime_V1_PodSandboxConfig? = nil
}

struct Runtime_V1_CreateContainerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the created container.
  var containerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_StartContainerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container to start.
  var containerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_StartContainerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_StopContainerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container to stop.
  var containerID: String = String()

  /// Timeout in seconds to wait for the container to stop before forcibly
  /// terminating it. Default: 0 (forcibly terminate the container immediately)
  var timeout: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_StopContainerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RemoveContainerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container to remove.
  var containerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RemoveContainerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ContainerStateValue is the wrapper of ContainerState.
struct Runtime_V1_ContainerStateValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// State of the container.
  var state: Runtime_V1_ContainerState = .containerCreated

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ContainerFilter is used to filter containers.
/// All those fields are combined with 'AND'
struct Runtime_V1_ContainerFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container.
  var id: String = String()

  /// State of the container.
  var state: Runtime_V1_ContainerStateValue {
    get {return _state ?? Runtime_V1_ContainerStateValue()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  /// ID of the PodSandbox.
  var podSandboxID: String = String()

  /// LabelSelector to select matches.
  /// Only api.MatchLabels is supported for now and the requirements
  /// are ANDed. MatchExpressions is not supported yet.
  var labelSelector: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Runtime_V1_ContainerStateValue? = nil
}

struct Runtime_V1_ListContainersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filter: Runtime_V1_ContainerFilter {
    get {return _filter ?? Runtime_V1_ContainerFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {self._filter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filter: Runtime_V1_ContainerFilter? = nil
}

/// Container provides the runtime information for a container, such as ID, hash,
/// state of the container.
struct Runtime_V1_Container {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container, used by the container runtime to identify
  /// a container.
  var id: String = String()

  /// ID of the sandbox to which this container belongs.
  var podSandboxID: String = String()

  /// Metadata of the container.
  var metadata: Runtime_V1_ContainerMetadata {
    get {return _metadata ?? Runtime_V1_ContainerMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec of the image.
  var image: Runtime_V1_ImageSpec {
    get {return _image ?? Runtime_V1_ImageSpec()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  /// Digested reference to the image in use.
  var imageRef: String = String()

  /// State of the container.
  var state: Runtime_V1_ContainerState = .containerCreated

  /// Creation time of the container in nanoseconds.
  var createdAt: Int64 = 0

  /// Key-value pairs that may be used to scope and select individual resources.
  var labels: Dictionary<String,String> = [:]

  /// Unstructured key-value map holding arbitrary metadata.
  /// Annotations MUST NOT be altered by the runtime; the value of this field
  /// MUST be identical to that of the corresponding ContainerConfig used to
  /// instantiate this Container.
  var annotations: Dictionary<String,String> = [:]

  /// Reference to the unique identifier of the image, on the node, as
  /// returned in the image service apis.
  ///
  /// Note: The image_ref above has been historically used by container
  /// runtimes to reference images by digest. The image_ref has been also used
  /// in the kubelet image garbage collection, which does not work with
  /// digests at all. To separate and avoid possible misusage, we now
  /// introduce the image_id field, which should always refer to a unique
  /// image identifier on the node.
  var imageID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Runtime_V1_ContainerMetadata? = nil
  fileprivate var _image: Runtime_V1_ImageSpec? = nil
}

struct Runtime_V1_ListContainersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of containers.
  var containers: [Runtime_V1_Container] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ContainerStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container for which to retrieve status.
  var containerID: String = String()

  /// Verbose indicates whether to return extra information about the container.
  var verbose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ContainerStatus represents the status of a container.
struct Runtime_V1_ContainerStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Metadata of the container.
  var metadata: Runtime_V1_ContainerMetadata {
    get {return _storage._metadata ?? Runtime_V1_ContainerMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Status of the container.
  var state: Runtime_V1_ContainerState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Creation time of the container in nanoseconds.
  var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  /// Start time of the container in nanoseconds. Default: 0 (not specified).
  var startedAt: Int64 {
    get {return _storage._startedAt}
    set {_uniqueStorage()._startedAt = newValue}
  }

  /// Finish time of the container in nanoseconds. Default: 0 (not specified).
  var finishedAt: Int64 {
    get {return _storage._finishedAt}
    set {_uniqueStorage()._finishedAt = newValue}
  }

  /// Exit code of the container. Only required when finished_at != 0. Default: 0.
  var exitCode: Int32 {
    get {return _storage._exitCode}
    set {_uniqueStorage()._exitCode = newValue}
  }

  /// Spec of the image.
  var image: Runtime_V1_ImageSpec {
    get {return _storage._image ?? Runtime_V1_ImageSpec()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  /// Digested reference to the image in use.
  var imageRef: String {
    get {return _storage._imageRef}
    set {_uniqueStorage()._imageRef = newValue}
  }

  /// Brief CamelCase string explaining why container is in its current state.
  /// Must be set to "OOMKilled" for containers terminated by cgroup-based Out-of-Memory killer.
  var reason: String {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  /// Human-readable message indicating details about why container is in its
  /// current state.
  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Key-value pairs that may be used to scope and select individual resources.
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Unstructured key-value map holding arbitrary metadata.
  /// Annotations MUST NOT be altered by the runtime; the value of this field
  /// MUST be identical to that of the corresponding ContainerConfig used to
  /// instantiate the Container this status represents.
  var annotations: Dictionary<String,String> {
    get {return _storage._annotations}
    set {_uniqueStorage()._annotations = newValue}
  }

  /// Mounts for the container.
  var mounts: [Runtime_V1_Mount] {
    get {return _storage._mounts}
    set {_uniqueStorage()._mounts = newValue}
  }

  /// Log path of container.
  var logPath: String {
    get {return _storage._logPath}
    set {_uniqueStorage()._logPath = newValue}
  }

  /// Resource limits configuration of the container.
  var resources: Runtime_V1_ContainerResources {
    get {return _storage._resources ?? Runtime_V1_ContainerResources()}
    set {_uniqueStorage()._resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  var hasResources: Bool {return _storage._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  mutating func clearResources() {_uniqueStorage()._resources = nil}

  /// Reference to the unique identifier of the image, on the node, as
  /// returned in the image service apis.
  ///
  /// Note: The image_ref above has been historically used by container
  /// runtimes to reference images by digest. To separate and avoid possible
  /// misusage, we now introduce the image_id field, which should always refer
  /// to a unique image identifier on the node.
  var imageID: String {
    get {return _storage._imageID}
    set {_uniqueStorage()._imageID = newValue}
  }

  /// User identities initially attached to the container
  var user: Runtime_V1_ContainerUser {
    get {return _storage._user ?? Runtime_V1_ContainerUser()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_ContainerStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the container.
  var status: Runtime_V1_ContainerStatus {
    get {return _status ?? Runtime_V1_ContainerStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Info is extra information of the Container. The key could be arbitrary string, and
  /// value should be in json format. The information could include anything useful for
  /// debug, e.g. pid for linux container based container runtime.
  /// It should only be returned non-empty when Verbose is true.
  var info: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: Runtime_V1_ContainerStatus? = nil
}

/// ContainerResources holds resource limits configuration for a container.
struct Runtime_V1_ContainerResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource limits configuration specific to Linux container.
  var linux: Runtime_V1_LinuxContainerResources {
    get {return _linux ?? Runtime_V1_LinuxContainerResources()}
    set {_linux = newValue}
  }
  /// Returns true if `linux` has been explicitly set.
  var hasLinux: Bool {return self._linux != nil}
  /// Clears the value of `linux`. Subsequent reads from it will return its default value.
  mutating func clearLinux() {self._linux = nil}

  /// Resource limits configuration specific to Windows container.
  var windows: Runtime_V1_WindowsContainerResources {
    get {return _windows ?? Runtime_V1_WindowsContainerResources()}
    set {_windows = newValue}
  }
  /// Returns true if `windows` has been explicitly set.
  var hasWindows: Bool {return self._windows != nil}
  /// Clears the value of `windows`. Subsequent reads from it will return its default value.
  mutating func clearWindows() {self._windows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _linux: Runtime_V1_LinuxContainerResources? = nil
  fileprivate var _windows: Runtime_V1_WindowsContainerResources? = nil
}

struct Runtime_V1_ContainerUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User identities initially attached to first process in the Linux container.
  /// Note that the actual running identity can be changed if the process has enough privilege to do so.
  var linux: Runtime_V1_LinuxContainerUser {
    get {return _linux ?? Runtime_V1_LinuxContainerUser()}
    set {_linux = newValue}
  }
  /// Returns true if `linux` has been explicitly set.
  var hasLinux: Bool {return self._linux != nil}
  /// Clears the value of `linux`. Subsequent reads from it will return its default value.
  mutating func clearLinux() {self._linux = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _linux: Runtime_V1_LinuxContainerUser? = nil
}

struct Runtime_V1_UpdateContainerResourcesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container to update.
  var containerID: String {
    get {return _storage._containerID}
    set {_uniqueStorage()._containerID = newValue}
  }

  /// Resource configuration specific to Linux containers.
  var linux: Runtime_V1_LinuxContainerResources {
    get {return _storage._linux ?? Runtime_V1_LinuxContainerResources()}
    set {_uniqueStorage()._linux = newValue}
  }
  /// Returns true if `linux` has been explicitly set.
  var hasLinux: Bool {return _storage._linux != nil}
  /// Clears the value of `linux`. Subsequent reads from it will return its default value.
  mutating func clearLinux() {_uniqueStorage()._linux = nil}

  /// Resource configuration specific to Windows containers.
  var windows: Runtime_V1_WindowsContainerResources {
    get {return _storage._windows ?? Runtime_V1_WindowsContainerResources()}
    set {_uniqueStorage()._windows = newValue}
  }
  /// Returns true if `windows` has been explicitly set.
  var hasWindows: Bool {return _storage._windows != nil}
  /// Clears the value of `windows`. Subsequent reads from it will return its default value.
  mutating func clearWindows() {_uniqueStorage()._windows = nil}

  /// Unstructured key-value map holding arbitrary additional information for
  /// container resources updating. This can be used for specifying experimental
  /// resources to update or other options to use when updating the container.
  var annotations: Dictionary<String,String> {
    get {return _storage._annotations}
    set {_uniqueStorage()._annotations = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Runtime_V1_UpdateContainerResourcesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ExecSyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container.
  var containerID: String = String()

  /// Command to execute.
  var cmd: [String] = []

  /// Timeout in seconds to stop the command. Default: 0 (run forever).
  var timeout: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ExecSyncResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Captured command stdout output.
  /// The runtime should cap the output of this response to 16MB.
  /// If the stdout of the command produces more than 16MB, the remaining output
  /// should be discarded, and the command should proceed with no error.
  /// See CVE-2022-1708 and CVE-2022-31030 for more information.
  var stdout: Data = Data()

  /// Captured command stderr output.
  /// The runtime should cap the output of this response to 16MB.
  /// If the stderr of the command produces more than 16MB, the remaining output
  /// should be discarded, and the command should proceed with no error.
  /// See CVE-2022-1708 and CVE-2022-31030 for more information.
  var stderr: Data = Data()

  /// Exit code the command finished with. Default: 0 (success).
  var exitCode: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ExecRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container in which to execute the command.
  var containerID: String = String()

  /// Command to execute.
  var cmd: [String] = []

  /// Whether to exec the command in a TTY.
  var tty: Bool = false

  /// Whether to stream stdin.
  /// One of `stdin`, `stdout`, and `stderr` MUST be true.
  var stdin: Bool = false

  /// Whether to stream stdout.
  /// One of `stdin`, `stdout`, and `stderr` MUST be true.
  var stdout: Bool = false

  /// Whether to stream stderr.
  /// One of `stdin`, `stdout`, and `stderr` MUST be true.
  /// If `tty` is true, `stderr` MUST be false. Multiplexing is not supported
  /// in this case. The output of stdout and stderr will be combined to a
  /// single stream.
  var stderr: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ExecResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fully qualified URL of the exec streaming server.
  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_AttachRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container to which to attach.
  var containerID: String = String()

  /// Whether to stream stdin.
  /// One of `stdin`, `stdout`, and `stderr` MUST be true.
  var stdin: Bool = false

  /// Whether the process being attached is running in a TTY.
  /// This must match the TTY setting in the ContainerConfig.
  var tty: Bool = false

  /// Whether to stream stdout.
  /// One of `stdin`, `stdout`, and `stderr` MUST be true.
  var stdout: Bool = false

  /// Whether to stream stderr.
  /// One of `stdin`, `stdout`, and `stderr` MUST be true.
  /// If `tty` is true, `stderr` MUST be false. Multiplexing is not supported
  /// in this case. The output of stdout and stderr will be combined to a
  /// single stream.
  var stderr: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_AttachResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fully qualified URL of the attach streaming server.
  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_PortForwardRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container to which to forward the port.
  var podSandboxID: String = String()

  /// Port to forward.
  var port: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_PortForwardResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fully qualified URL of the port-forward streaming server.
  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ImageFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Spec of the image.
  var image: Runtime_V1_ImageSpec {
    get {return _image ?? Runtime_V1_ImageSpec()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _image: Runtime_V1_ImageSpec? = nil
}

struct Runtime_V1_ListImagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter to list images.
  var filter: Runtime_V1_ImageFilter {
    get {return _filter ?? Runtime_V1_ImageFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {self._filter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filter: Runtime_V1_ImageFilter? = nil
}

/// Basic information about a container image.
struct Runtime_V1_Image {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the image.
  var id: String = String()

  /// Other names by which this image is known.
  var repoTags: [String] = []

  /// Digests by which this image is known.
  var repoDigests: [String] = []

  /// Size of the image in bytes. Must be > 0.
  var size: UInt64 = 0

  /// UID that will run the command(s). This is used as a default if no user is
  /// specified when creating the container. UID and the following user name
  /// are mutually exclusive.
  var uid: Runtime_V1_Int64Value {
    get {return _uid ?? Runtime_V1_Int64Value()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// User name that will run the command(s). This is used if UID is not set
  /// and no user is specified when creating container.
  var username: String = String()

  /// ImageSpec for image which includes annotations
  var spec: Runtime_V1_ImageSpec {
    get {return _spec ?? Runtime_V1_ImageSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  /// Recommendation on whether this image should be exempt from garbage collection.
  /// It must only be treated as a recommendation -- the client can still request that the image be deleted,
  /// and the runtime must oblige.
  var pinned: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uid: Runtime_V1_Int64Value? = nil
  fileprivate var _spec: Runtime_V1_ImageSpec? = nil
}

struct Runtime_V1_ListImagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of images.
  var images: [Runtime_V1_Image] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ImageStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Spec of the image.
  var image: Runtime_V1_ImageSpec {
    get {return _image ?? Runtime_V1_ImageSpec()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  /// Verbose indicates whether to return extra information about the image.
  var verbose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _image: Runtime_V1_ImageSpec? = nil
}

struct Runtime_V1_ImageStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the image.
  var image: Runtime_V1_Image {
    get {return _image ?? Runtime_V1_Image()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  /// Info is extra information of the Image. The key could be arbitrary string, and
  /// value should be in json format. The information could include anything useful
  /// for debug, e.g. image config for oci image based container runtime.
  /// It should only be returned non-empty when Verbose is true.
  var info: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _image: Runtime_V1_Image? = nil
}

/// AuthConfig contains authorization information for connecting to a registry.
struct Runtime_V1_AuthConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var password: String = String()

  var auth: String = String()

  var serverAddress: String = String()

  /// IdentityToken is used to authenticate the user and get
  /// an access token for the registry.
  var identityToken: String = String()

  /// RegistryToken is a bearer token to be sent to a registry
  var registryToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_PullImageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Spec of the image.
  var image: Runtime_V1_ImageSpec {
    get {return _image ?? Runtime_V1_ImageSpec()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  /// Authentication configuration for pulling the image.
  var auth: Runtime_V1_AuthConfig {
    get {return _auth ?? Runtime_V1_AuthConfig()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  /// Config of the PodSandbox, which is used to pull image in PodSandbox context.
  var sandboxConfig: Runtime_V1_PodSandboxConfig {
    get {return _sandboxConfig ?? Runtime_V1_PodSandboxConfig()}
    set {_sandboxConfig = newValue}
  }
  /// Returns true if `sandboxConfig` has been explicitly set.
  var hasSandboxConfig: Bool {return self._sandboxConfig != nil}
  /// Clears the value of `sandboxConfig`. Subsequent reads from it will return its default value.
  mutating func clearSandboxConfig() {self._sandboxConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _image: Runtime_V1_ImageSpec? = nil
  fileprivate var _auth: Runtime_V1_AuthConfig? = nil
  fileprivate var _sandboxConfig: Runtime_V1_PodSandboxConfig? = nil
}

struct Runtime_V1_PullImageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to the image in use. For most runtimes, this should be an
  /// image ID or digest.
  var imageRef: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RemoveImageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Spec of the image to remove.
  var image: Runtime_V1_ImageSpec {
    get {return _image ?? Runtime_V1_ImageSpec()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _image: Runtime_V1_ImageSpec? = nil
}

struct Runtime_V1_RemoveImageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_NetworkConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CIDR to use for pod IP addresses. If the CIDR is empty, runtimes
  /// should omit it.
  var podCidr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RuntimeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkConfig: Runtime_V1_NetworkConfig {
    get {return _networkConfig ?? Runtime_V1_NetworkConfig()}
    set {_networkConfig = newValue}
  }
  /// Returns true if `networkConfig` has been explicitly set.
  var hasNetworkConfig: Bool {return self._networkConfig != nil}
  /// Clears the value of `networkConfig`. Subsequent reads from it will return its default value.
  mutating func clearNetworkConfig() {self._networkConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _networkConfig: Runtime_V1_NetworkConfig? = nil
}

struct Runtime_V1_UpdateRuntimeConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var runtimeConfig: Runtime_V1_RuntimeConfig {
    get {return _runtimeConfig ?? Runtime_V1_RuntimeConfig()}
    set {_runtimeConfig = newValue}
  }
  /// Returns true if `runtimeConfig` has been explicitly set.
  var hasRuntimeConfig: Bool {return self._runtimeConfig != nil}
  /// Clears the value of `runtimeConfig`. Subsequent reads from it will return its default value.
  mutating func clearRuntimeConfig() {self._runtimeConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _runtimeConfig: Runtime_V1_RuntimeConfig? = nil
}

struct Runtime_V1_UpdateRuntimeConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RuntimeCondition contains condition information for the runtime.
/// There are 2 kinds of runtime conditions:
/// 1. Required conditions: Conditions are required for kubelet to work
/// properly. If any required condition is unmet, the node will be not ready.
/// The required conditions include:
///   * RuntimeReady: RuntimeReady means the runtime is up and ready to accept
///   basic containers e.g. container only needs host network.
///   * NetworkReady: NetworkReady means the runtime network is up and ready to
///   accept containers which require container network.
/// 2. Optional conditions: Conditions are informative to the user, but kubelet
/// will not rely on. Since condition type is an arbitrary string, all conditions
/// not required are optional. These conditions will be exposed to users to help
/// them understand the status of the system.
struct Runtime_V1_RuntimeCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of runtime condition.
  var type: String = String()

  /// Status of the condition, one of true/false. Default: false.
  var status: Bool = false

  /// Brief CamelCase string containing reason for the condition's last transition.
  var reason: String = String()

  /// Human-readable message indicating details about last transition.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RuntimeStatus is information about the current status of the runtime.
struct Runtime_V1_RuntimeStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of current observed runtime conditions.
  var conditions: [Runtime_V1_RuntimeCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Verbose indicates whether to return extra information about the runtime.
  var verbose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RuntimeHandlerFeatures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// recursive_read_only_mounts is set to true if the runtime handler supports
  /// recursive read-only mounts.
  /// For runc-compatible runtimes, availability of this feature can be detected by checking whether
  /// the Linux kernel version is >= 5.12, and,  `runc features | jq .mountOptions` contains "rro".
  var recursiveReadOnlyMounts: Bool = false

  /// user_namespaces is set to true if the runtime handler supports user namespaces as implemented
  /// in Kubernetes. This means support for both, user namespaces and idmap mounts.
  var userNamespaces: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RuntimeHandler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name must be unique in StatusResponse.
  /// An empty string denotes the default handler.
  var name: String = String()

  /// Supported features.
  var features: Runtime_V1_RuntimeHandlerFeatures {
    get {return _features ?? Runtime_V1_RuntimeHandlerFeatures()}
    set {_features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  var hasFeatures: Bool {return self._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  mutating func clearFeatures() {self._features = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _features: Runtime_V1_RuntimeHandlerFeatures? = nil
}

struct Runtime_V1_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the Runtime.
  var status: Runtime_V1_RuntimeStatus {
    get {return _status ?? Runtime_V1_RuntimeStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Info is extra information of the Runtime. The key could be arbitrary string, and
  /// value should be in json format. The information could include anything useful for
  /// debug, e.g. plugins used by the container runtime.
  /// It should only be returned non-empty when Verbose is true.
  var info: Dictionary<String,String> = [:]

  /// Runtime handlers.
  var runtimeHandlers: [Runtime_V1_RuntimeHandler] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: Runtime_V1_RuntimeStatus? = nil
}

struct Runtime_V1_ImageFsInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UInt64Value is the wrapper of uint64.
struct Runtime_V1_UInt64Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value.
  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// FilesystemIdentifier uniquely identify the filesystem.
struct Runtime_V1_FilesystemIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mountpoint of a filesystem.
  var mountpoint: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// FilesystemUsage provides the filesystem usage information.
struct Runtime_V1_FilesystemUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// The unique identifier of the filesystem.
  var fsID: Runtime_V1_FilesystemIdentifier {
    get {return _fsID ?? Runtime_V1_FilesystemIdentifier()}
    set {_fsID = newValue}
  }
  /// Returns true if `fsID` has been explicitly set.
  var hasFsID: Bool {return self._fsID != nil}
  /// Clears the value of `fsID`. Subsequent reads from it will return its default value.
  mutating func clearFsID() {self._fsID = nil}

  /// UsedBytes represents the bytes used for images on the filesystem.
  /// This may differ from the total bytes used on the filesystem and may not
  /// equal CapacityBytes - AvailableBytes.
  var usedBytes: Runtime_V1_UInt64Value {
    get {return _usedBytes ?? Runtime_V1_UInt64Value()}
    set {_usedBytes = newValue}
  }
  /// Returns true if `usedBytes` has been explicitly set.
  var hasUsedBytes: Bool {return self._usedBytes != nil}
  /// Clears the value of `usedBytes`. Subsequent reads from it will return its default value.
  mutating func clearUsedBytes() {self._usedBytes = nil}

  /// InodesUsed represents the inodes used by the images.
  /// This may not equal InodesCapacity - InodesAvailable because the underlying
  /// filesystem may also be used for purposes other than storing images.
  var inodesUsed: Runtime_V1_UInt64Value {
    get {return _inodesUsed ?? Runtime_V1_UInt64Value()}
    set {_inodesUsed = newValue}
  }
  /// Returns true if `inodesUsed` has been explicitly set.
  var hasInodesUsed: Bool {return self._inodesUsed != nil}
  /// Clears the value of `inodesUsed`. Subsequent reads from it will return its default value.
  mutating func clearInodesUsed() {self._inodesUsed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fsID: Runtime_V1_FilesystemIdentifier? = nil
  fileprivate var _usedBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _inodesUsed: Runtime_V1_UInt64Value? = nil
}

/// WindowsFilesystemUsage provides the filesystem usage information specific to Windows.
struct Runtime_V1_WindowsFilesystemUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// The unique identifier of the filesystem.
  var fsID: Runtime_V1_FilesystemIdentifier {
    get {return _fsID ?? Runtime_V1_FilesystemIdentifier()}
    set {_fsID = newValue}
  }
  /// Returns true if `fsID` has been explicitly set.
  var hasFsID: Bool {return self._fsID != nil}
  /// Clears the value of `fsID`. Subsequent reads from it will return its default value.
  mutating func clearFsID() {self._fsID = nil}

  /// UsedBytes represents the bytes used for images on the filesystem.
  /// This may differ from the total bytes used on the filesystem and may not
  /// equal CapacityBytes - AvailableBytes.
  var usedBytes: Runtime_V1_UInt64Value {
    get {return _usedBytes ?? Runtime_V1_UInt64Value()}
    set {_usedBytes = newValue}
  }
  /// Returns true if `usedBytes` has been explicitly set.
  var hasUsedBytes: Bool {return self._usedBytes != nil}
  /// Clears the value of `usedBytes`. Subsequent reads from it will return its default value.
  mutating func clearUsedBytes() {self._usedBytes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fsID: Runtime_V1_FilesystemIdentifier? = nil
  fileprivate var _usedBytes: Runtime_V1_UInt64Value? = nil
}

struct Runtime_V1_ImageFsInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information of image filesystem(s).
  var imageFilesystems: [Runtime_V1_FilesystemUsage] = []

  /// Information of container filesystem(s).
  /// This is an optional field, may be used for example if container and image
  /// storage are separated.
  /// Default will be to return this as empty.
  var containerFilesystems: [Runtime_V1_FilesystemUsage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ContainerStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container for which to retrieve stats.
  var containerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ContainerStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stats of the container.
  var stats: Runtime_V1_ContainerStats {
    get {return _stats ?? Runtime_V1_ContainerStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  mutating func clearStats() {self._stats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stats: Runtime_V1_ContainerStats? = nil
}

struct Runtime_V1_ListContainerStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter for the list request.
  var filter: Runtime_V1_ContainerStatsFilter {
    get {return _filter ?? Runtime_V1_ContainerStatsFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {self._filter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filter: Runtime_V1_ContainerStatsFilter? = nil
}

/// ContainerStatsFilter is used to filter containers.
/// All those fields are combined with 'AND'
struct Runtime_V1_ContainerStatsFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container.
  var id: String = String()

  /// ID of the PodSandbox.
  var podSandboxID: String = String()

  /// LabelSelector to select matches.
  /// Only api.MatchLabels is supported for now and the requirements
  /// are ANDed. MatchExpressions is not supported yet.
  var labelSelector: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ListContainerStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stats of the container.
  var stats: [Runtime_V1_ContainerStats] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ContainerAttributes provides basic information of the container.
struct Runtime_V1_ContainerAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container.
  var id: String = String()

  /// Metadata of the container.
  var metadata: Runtime_V1_ContainerMetadata {
    get {return _metadata ?? Runtime_V1_ContainerMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Key-value pairs that may be used to scope and select individual resources.
  var labels: Dictionary<String,String> = [:]

  /// Unstructured key-value map holding arbitrary metadata.
  /// Annotations MUST NOT be altered by the runtime; the value of this field
  /// MUST be identical to that of the corresponding ContainerConfig used to
  /// instantiate the Container this status represents.
  var annotations: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Runtime_V1_ContainerMetadata? = nil
}

/// ContainerStats provides the resource usage statistics for a container.
struct Runtime_V1_ContainerStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information of the container.
  var attributes: Runtime_V1_ContainerAttributes {
    get {return _storage._attributes ?? Runtime_V1_ContainerAttributes()}
    set {_uniqueStorage()._attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return _storage._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {_uniqueStorage()._attributes = nil}

  /// CPU usage gathered from the container.
  var cpu: Runtime_V1_CpuUsage {
    get {return _storage._cpu ?? Runtime_V1_CpuUsage()}
    set {_uniqueStorage()._cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  var hasCpu: Bool {return _storage._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  mutating func clearCpu() {_uniqueStorage()._cpu = nil}

  /// Memory usage gathered from the container.
  var memory: Runtime_V1_MemoryUsage {
    get {return _storage._memory ?? Runtime_V1_MemoryUsage()}
    set {_uniqueStorage()._memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  var hasMemory: Bool {return _storage._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  mutating func clearMemory() {_uniqueStorage()._memory = nil}

  /// Usage of the writable layer.
  var writableLayer: Runtime_V1_FilesystemUsage {
    get {return _storage._writableLayer ?? Runtime_V1_FilesystemUsage()}
    set {_uniqueStorage()._writableLayer = newValue}
  }
  /// Returns true if `writableLayer` has been explicitly set.
  var hasWritableLayer: Bool {return _storage._writableLayer != nil}
  /// Clears the value of `writableLayer`. Subsequent reads from it will return its default value.
  mutating func clearWritableLayer() {_uniqueStorage()._writableLayer = nil}

  /// Swap usage gathered from the container.
  var swap: Runtime_V1_SwapUsage {
    get {return _storage._swap ?? Runtime_V1_SwapUsage()}
    set {_uniqueStorage()._swap = newValue}
  }
  /// Returns true if `swap` has been explicitly set.
  var hasSwap: Bool {return _storage._swap != nil}
  /// Clears the value of `swap`. Subsequent reads from it will return its default value.
  mutating func clearSwap() {_uniqueStorage()._swap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WindowsContainerStats provides the resource usage statistics for a container specific for Windows
struct Runtime_V1_WindowsContainerStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information of the container.
  var attributes: Runtime_V1_ContainerAttributes {
    get {return _attributes ?? Runtime_V1_ContainerAttributes()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {self._attributes = nil}

  /// CPU usage gathered from the container.
  var cpu: Runtime_V1_WindowsCpuUsage {
    get {return _cpu ?? Runtime_V1_WindowsCpuUsage()}
    set {_cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  var hasCpu: Bool {return self._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  mutating func clearCpu() {self._cpu = nil}

  /// Memory usage gathered from the container.
  var memory: Runtime_V1_WindowsMemoryUsage {
    get {return _memory ?? Runtime_V1_WindowsMemoryUsage()}
    set {_memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  var hasMemory: Bool {return self._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  mutating func clearMemory() {self._memory = nil}

  /// Usage of the writable layer.
  var writableLayer: Runtime_V1_WindowsFilesystemUsage {
    get {return _writableLayer ?? Runtime_V1_WindowsFilesystemUsage()}
    set {_writableLayer = newValue}
  }
  /// Returns true if `writableLayer` has been explicitly set.
  var hasWritableLayer: Bool {return self._writableLayer != nil}
  /// Clears the value of `writableLayer`. Subsequent reads from it will return its default value.
  mutating func clearWritableLayer() {self._writableLayer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attributes: Runtime_V1_ContainerAttributes? = nil
  fileprivate var _cpu: Runtime_V1_WindowsCpuUsage? = nil
  fileprivate var _memory: Runtime_V1_WindowsMemoryUsage? = nil
  fileprivate var _writableLayer: Runtime_V1_WindowsFilesystemUsage? = nil
}

/// CpuUsage provides the CPU usage information.
struct Runtime_V1_CpuUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// Cumulative CPU usage (sum across all cores) since object creation.
  var usageCoreNanoSeconds: Runtime_V1_UInt64Value {
    get {return _usageCoreNanoSeconds ?? Runtime_V1_UInt64Value()}
    set {_usageCoreNanoSeconds = newValue}
  }
  /// Returns true if `usageCoreNanoSeconds` has been explicitly set.
  var hasUsageCoreNanoSeconds: Bool {return self._usageCoreNanoSeconds != nil}
  /// Clears the value of `usageCoreNanoSeconds`. Subsequent reads from it will return its default value.
  mutating func clearUsageCoreNanoSeconds() {self._usageCoreNanoSeconds = nil}

  /// Total CPU usage (sum of all cores) averaged over the sample window.
  /// The "core" unit can be interpreted as CPU core-nanoseconds per second.
  var usageNanoCores: Runtime_V1_UInt64Value {
    get {return _usageNanoCores ?? Runtime_V1_UInt64Value()}
    set {_usageNanoCores = newValue}
  }
  /// Returns true if `usageNanoCores` has been explicitly set.
  var hasUsageNanoCores: Bool {return self._usageNanoCores != nil}
  /// Clears the value of `usageNanoCores`. Subsequent reads from it will return its default value.
  mutating func clearUsageNanoCores() {self._usageNanoCores = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _usageCoreNanoSeconds: Runtime_V1_UInt64Value? = nil
  fileprivate var _usageNanoCores: Runtime_V1_UInt64Value? = nil
}

/// WindowsCpuUsage provides the CPU usage information specific to Windows
struct Runtime_V1_WindowsCpuUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// Cumulative CPU usage (sum across all cores) since object creation.
  var usageCoreNanoSeconds: Runtime_V1_UInt64Value {
    get {return _usageCoreNanoSeconds ?? Runtime_V1_UInt64Value()}
    set {_usageCoreNanoSeconds = newValue}
  }
  /// Returns true if `usageCoreNanoSeconds` has been explicitly set.
  var hasUsageCoreNanoSeconds: Bool {return self._usageCoreNanoSeconds != nil}
  /// Clears the value of `usageCoreNanoSeconds`. Subsequent reads from it will return its default value.
  mutating func clearUsageCoreNanoSeconds() {self._usageCoreNanoSeconds = nil}

  /// Total CPU usage (sum of all cores) averaged over the sample window.
  /// The "core" unit can be interpreted as CPU core-nanoseconds per second.
  var usageNanoCores: Runtime_V1_UInt64Value {
    get {return _usageNanoCores ?? Runtime_V1_UInt64Value()}
    set {_usageNanoCores = newValue}
  }
  /// Returns true if `usageNanoCores` has been explicitly set.
  var hasUsageNanoCores: Bool {return self._usageNanoCores != nil}
  /// Clears the value of `usageNanoCores`. Subsequent reads from it will return its default value.
  mutating func clearUsageNanoCores() {self._usageNanoCores = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _usageCoreNanoSeconds: Runtime_V1_UInt64Value? = nil
  fileprivate var _usageNanoCores: Runtime_V1_UInt64Value? = nil
}

/// MemoryUsage provides the memory usage information.
struct Runtime_V1_MemoryUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// The amount of working set memory in bytes.
  var workingSetBytes: Runtime_V1_UInt64Value {
    get {return _workingSetBytes ?? Runtime_V1_UInt64Value()}
    set {_workingSetBytes = newValue}
  }
  /// Returns true if `workingSetBytes` has been explicitly set.
  var hasWorkingSetBytes: Bool {return self._workingSetBytes != nil}
  /// Clears the value of `workingSetBytes`. Subsequent reads from it will return its default value.
  mutating func clearWorkingSetBytes() {self._workingSetBytes = nil}

  /// Available memory for use. This is defined as the memory limit - workingSetBytes.
  var availableBytes: Runtime_V1_UInt64Value {
    get {return _availableBytes ?? Runtime_V1_UInt64Value()}
    set {_availableBytes = newValue}
  }
  /// Returns true if `availableBytes` has been explicitly set.
  var hasAvailableBytes: Bool {return self._availableBytes != nil}
  /// Clears the value of `availableBytes`. Subsequent reads from it will return its default value.
  mutating func clearAvailableBytes() {self._availableBytes = nil}

  /// Total memory in use. This includes all memory regardless of when it was accessed.
  var usageBytes: Runtime_V1_UInt64Value {
    get {return _usageBytes ?? Runtime_V1_UInt64Value()}
    set {_usageBytes = newValue}
  }
  /// Returns true if `usageBytes` has been explicitly set.
  var hasUsageBytes: Bool {return self._usageBytes != nil}
  /// Clears the value of `usageBytes`. Subsequent reads from it will return its default value.
  mutating func clearUsageBytes() {self._usageBytes = nil}

  /// The amount of anonymous and swap cache memory (includes transparent hugepages).
  var rssBytes: Runtime_V1_UInt64Value {
    get {return _rssBytes ?? Runtime_V1_UInt64Value()}
    set {_rssBytes = newValue}
  }
  /// Returns true if `rssBytes` has been explicitly set.
  var hasRssBytes: Bool {return self._rssBytes != nil}
  /// Clears the value of `rssBytes`. Subsequent reads from it will return its default value.
  mutating func clearRssBytes() {self._rssBytes = nil}

  /// Cumulative number of minor page faults.
  var pageFaults: Runtime_V1_UInt64Value {
    get {return _pageFaults ?? Runtime_V1_UInt64Value()}
    set {_pageFaults = newValue}
  }
  /// Returns true if `pageFaults` has been explicitly set.
  var hasPageFaults: Bool {return self._pageFaults != nil}
  /// Clears the value of `pageFaults`. Subsequent reads from it will return its default value.
  mutating func clearPageFaults() {self._pageFaults = nil}

  /// Cumulative number of major page faults.
  var majorPageFaults: Runtime_V1_UInt64Value {
    get {return _majorPageFaults ?? Runtime_V1_UInt64Value()}
    set {_majorPageFaults = newValue}
  }
  /// Returns true if `majorPageFaults` has been explicitly set.
  var hasMajorPageFaults: Bool {return self._majorPageFaults != nil}
  /// Clears the value of `majorPageFaults`. Subsequent reads from it will return its default value.
  mutating func clearMajorPageFaults() {self._majorPageFaults = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _workingSetBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _availableBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _usageBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _rssBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _pageFaults: Runtime_V1_UInt64Value? = nil
  fileprivate var _majorPageFaults: Runtime_V1_UInt64Value? = nil
}

struct Runtime_V1_SwapUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// Available swap for use. This is defined as the swap limit - swapUsageBytes.
  var swapAvailableBytes: Runtime_V1_UInt64Value {
    get {return _swapAvailableBytes ?? Runtime_V1_UInt64Value()}
    set {_swapAvailableBytes = newValue}
  }
  /// Returns true if `swapAvailableBytes` has been explicitly set.
  var hasSwapAvailableBytes: Bool {return self._swapAvailableBytes != nil}
  /// Clears the value of `swapAvailableBytes`. Subsequent reads from it will return its default value.
  mutating func clearSwapAvailableBytes() {self._swapAvailableBytes = nil}

  /// Total memory in use. This includes all memory regardless of when it was accessed.
  var swapUsageBytes: Runtime_V1_UInt64Value {
    get {return _swapUsageBytes ?? Runtime_V1_UInt64Value()}
    set {_swapUsageBytes = newValue}
  }
  /// Returns true if `swapUsageBytes` has been explicitly set.
  var hasSwapUsageBytes: Bool {return self._swapUsageBytes != nil}
  /// Clears the value of `swapUsageBytes`. Subsequent reads from it will return its default value.
  mutating func clearSwapUsageBytes() {self._swapUsageBytes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _swapAvailableBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _swapUsageBytes: Runtime_V1_UInt64Value? = nil
}

/// WindowsMemoryUsage provides the memory usage information specific to Windows
struct Runtime_V1_WindowsMemoryUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp in nanoseconds at which the information were collected. Must be > 0.
  var timestamp: Int64 = 0

  /// The amount of working set memory in bytes.
  var workingSetBytes: Runtime_V1_UInt64Value {
    get {return _workingSetBytes ?? Runtime_V1_UInt64Value()}
    set {_workingSetBytes = newValue}
  }
  /// Returns true if `workingSetBytes` has been explicitly set.
  var hasWorkingSetBytes: Bool {return self._workingSetBytes != nil}
  /// Clears the value of `workingSetBytes`. Subsequent reads from it will return its default value.
  mutating func clearWorkingSetBytes() {self._workingSetBytes = nil}

  /// Available memory for use. This is defined as the memory limit - commit_memory_bytes.
  var availableBytes: Runtime_V1_UInt64Value {
    get {return _availableBytes ?? Runtime_V1_UInt64Value()}
    set {_availableBytes = newValue}
  }
  /// Returns true if `availableBytes` has been explicitly set.
  var hasAvailableBytes: Bool {return self._availableBytes != nil}
  /// Clears the value of `availableBytes`. Subsequent reads from it will return its default value.
  mutating func clearAvailableBytes() {self._availableBytes = nil}

  /// Cumulative number of page faults.
  var pageFaults: Runtime_V1_UInt64Value {
    get {return _pageFaults ?? Runtime_V1_UInt64Value()}
    set {_pageFaults = newValue}
  }
  /// Returns true if `pageFaults` has been explicitly set.
  var hasPageFaults: Bool {return self._pageFaults != nil}
  /// Clears the value of `pageFaults`. Subsequent reads from it will return its default value.
  mutating func clearPageFaults() {self._pageFaults = nil}

  /// Total commit memory in use. Commit memory is total of physical and virtual memory in use.
  var commitMemoryBytes: Runtime_V1_UInt64Value {
    get {return _commitMemoryBytes ?? Runtime_V1_UInt64Value()}
    set {_commitMemoryBytes = newValue}
  }
  /// Returns true if `commitMemoryBytes` has been explicitly set.
  var hasCommitMemoryBytes: Bool {return self._commitMemoryBytes != nil}
  /// Clears the value of `commitMemoryBytes`. Subsequent reads from it will return its default value.
  mutating func clearCommitMemoryBytes() {self._commitMemoryBytes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _workingSetBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _availableBytes: Runtime_V1_UInt64Value? = nil
  fileprivate var _pageFaults: Runtime_V1_UInt64Value? = nil
  fileprivate var _commitMemoryBytes: Runtime_V1_UInt64Value? = nil
}

struct Runtime_V1_ReopenContainerLogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container for which to reopen the log.
  var containerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ReopenContainerLogResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_CheckpointContainerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container to be checkpointed.
  var containerID: String = String()

  /// Location of the checkpoint archive used for export
  var location: String = String()

  /// Timeout in seconds for the checkpoint to complete.
  /// Timeout of zero means to use the CRI default.
  /// Timeout > 0 means to use the user specified timeout.
  var timeout: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_CheckpointContainerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_GetEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ContainerEventResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the container
  var containerID: String = String()

  /// Type of the container event
  var containerEventType: Runtime_V1_ContainerEventType = .containerCreatedEvent

  /// Creation timestamp of this event
  var createdAt: Int64 = 0

  /// Sandbox status
  var podSandboxStatus: Runtime_V1_PodSandboxStatus {
    get {return _podSandboxStatus ?? Runtime_V1_PodSandboxStatus()}
    set {_podSandboxStatus = newValue}
  }
  /// Returns true if `podSandboxStatus` has been explicitly set.
  var hasPodSandboxStatus: Bool {return self._podSandboxStatus != nil}
  /// Clears the value of `podSandboxStatus`. Subsequent reads from it will return its default value.
  mutating func clearPodSandboxStatus() {self._podSandboxStatus = nil}

  /// Container statuses
  var containersStatuses: [Runtime_V1_ContainerStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _podSandboxStatus: Runtime_V1_PodSandboxStatus? = nil
}

struct Runtime_V1_ListMetricDescriptorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ListMetricDescriptorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var descriptors: [Runtime_V1_MetricDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_MetricDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name field will be used as a unique identifier of this MetricDescriptor,
  /// and be used in conjunction with the Metric structure to populate the full Metric.
  var name: String = String()

  var help: String = String()

  /// When a metric uses this metric descriptor, it should only define
  /// labels that have previously been declared in label_keys.
  /// It is the responsibility of the runtime to correctly keep sorted the keys and values.
  /// If the two slices have different length, the behavior is undefined.
  var labelKeys: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ListPodSandboxMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ListPodSandboxMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podMetrics: [Runtime_V1_PodSandboxMetrics] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_PodSandboxMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podSandboxID: String = String()

  var metrics: [Runtime_V1_Metric] = []

  var containerMetrics: [Runtime_V1_ContainerMetrics] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_ContainerMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var containerID: String = String()

  var metrics: [Runtime_V1_Metric] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name must match a name previously returned in a MetricDescriptors call,
  /// otherwise, it will be ignored.
  var name: String = String()

  /// Timestamp should be 0 if the metric was gathered live.
  /// If it was cached, the Timestamp should reflect the time it was collected.
  var timestamp: Int64 = 0

  var metricType: Runtime_V1_MetricType = .counter

  /// The corresponding LabelValues to the LabelKeys defined in the MetricDescriptor.
  /// It is the responsibility of the runtime to correctly keep sorted the keys and values.
  /// If the two slices have different length, the behavior is undefined.
  var labelValues: [String] = []

  var value: Runtime_V1_UInt64Value {
    get {return _value ?? Runtime_V1_UInt64Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Runtime_V1_UInt64Value? = nil
}

struct Runtime_V1_RuntimeConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Runtime_V1_RuntimeConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration information for Linux-based runtimes. This field contains
  /// global runtime configuration options that are not specific to runtime
  /// handlers.
  var linux: Runtime_V1_LinuxRuntimeConfiguration {
    get {return _linux ?? Runtime_V1_LinuxRuntimeConfiguration()}
    set {_linux = newValue}
  }
  /// Returns true if `linux` has been explicitly set.
  var hasLinux: Bool {return self._linux != nil}
  /// Clears the value of `linux`. Subsequent reads from it will return its default value.
  mutating func clearLinux() {self._linux = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _linux: Runtime_V1_LinuxRuntimeConfiguration? = nil
}

struct Runtime_V1_LinuxRuntimeConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cgroup driver to use
  /// Note: this field should not change for the lifecycle of the Kubelet,
  /// or while there are running containers.
  /// The Kubelet will not re-request this after startup, and will construct the cgroup
  /// hierarchy assuming it is static.
  /// If the runtime wishes to change this value, it must be accompanied by removal of
  /// all pods, and a restart of the Kubelet. The easiest way to do this is with a full node reboot.
  var cgroupDriver: Runtime_V1_CgroupDriver = .systemd

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Runtime_V1_Protocol: @unchecked Sendable {}
extension Runtime_V1_MountPropagation: @unchecked Sendable {}
extension Runtime_V1_NamespaceMode: @unchecked Sendable {}
extension Runtime_V1_SupplementalGroupsPolicy: @unchecked Sendable {}
extension Runtime_V1_PodSandboxState: @unchecked Sendable {}
extension Runtime_V1_ContainerState: @unchecked Sendable {}
extension Runtime_V1_ContainerEventType: @unchecked Sendable {}
extension Runtime_V1_MetricType: @unchecked Sendable {}
extension Runtime_V1_CgroupDriver: @unchecked Sendable {}
extension Runtime_V1_VersionRequest: @unchecked Sendable {}
extension Runtime_V1_VersionResponse: @unchecked Sendable {}
extension Runtime_V1_DNSConfig: @unchecked Sendable {}
extension Runtime_V1_PortMapping: @unchecked Sendable {}
extension Runtime_V1_Mount: @unchecked Sendable {}
extension Runtime_V1_IDMapping: @unchecked Sendable {}
extension Runtime_V1_UserNamespace: @unchecked Sendable {}
extension Runtime_V1_NamespaceOption: @unchecked Sendable {}
extension Runtime_V1_Int64Value: @unchecked Sendable {}
extension Runtime_V1_LinuxSandboxSecurityContext: @unchecked Sendable {}
extension Runtime_V1_SecurityProfile: @unchecked Sendable {}
extension Runtime_V1_SecurityProfile.ProfileType: @unchecked Sendable {}
extension Runtime_V1_LinuxPodSandboxConfig: @unchecked Sendable {}
extension Runtime_V1_PodSandboxMetadata: @unchecked Sendable {}
extension Runtime_V1_PodSandboxConfig: @unchecked Sendable {}
extension Runtime_V1_RunPodSandboxRequest: @unchecked Sendable {}
extension Runtime_V1_RunPodSandboxResponse: @unchecked Sendable {}
extension Runtime_V1_StopPodSandboxRequest: @unchecked Sendable {}
extension Runtime_V1_StopPodSandboxResponse: @unchecked Sendable {}
extension Runtime_V1_RemovePodSandboxRequest: @unchecked Sendable {}
extension Runtime_V1_RemovePodSandboxResponse: @unchecked Sendable {}
extension Runtime_V1_PodSandboxStatusRequest: @unchecked Sendable {}
extension Runtime_V1_PodIP: @unchecked Sendable {}
extension Runtime_V1_PodSandboxNetworkStatus: @unchecked Sendable {}
extension Runtime_V1_Namespace: @unchecked Sendable {}
extension Runtime_V1_LinuxPodSandboxStatus: @unchecked Sendable {}
extension Runtime_V1_PodSandboxStatus: @unchecked Sendable {}
extension Runtime_V1_PodSandboxStatusResponse: @unchecked Sendable {}
extension Runtime_V1_PodSandboxStateValue: @unchecked Sendable {}
extension Runtime_V1_PodSandboxFilter: @unchecked Sendable {}
extension Runtime_V1_ListPodSandboxRequest: @unchecked Sendable {}
extension Runtime_V1_PodSandbox: @unchecked Sendable {}
extension Runtime_V1_ListPodSandboxResponse: @unchecked Sendable {}
extension Runtime_V1_PodSandboxStatsRequest: @unchecked Sendable {}
extension Runtime_V1_PodSandboxStatsResponse: @unchecked Sendable {}
extension Runtime_V1_PodSandboxStatsFilter: @unchecked Sendable {}
extension Runtime_V1_ListPodSandboxStatsRequest: @unchecked Sendable {}
extension Runtime_V1_ListPodSandboxStatsResponse: @unchecked Sendable {}
extension Runtime_V1_PodSandboxAttributes: @unchecked Sendable {}
extension Runtime_V1_PodSandboxStats: @unchecked Sendable {}
extension Runtime_V1_LinuxPodSandboxStats: @unchecked Sendable {}
extension Runtime_V1_WindowsPodSandboxStats: @unchecked Sendable {}
extension Runtime_V1_NetworkUsage: @unchecked Sendable {}
extension Runtime_V1_WindowsNetworkUsage: @unchecked Sendable {}
extension Runtime_V1_NetworkInterfaceUsage: @unchecked Sendable {}
extension Runtime_V1_WindowsNetworkInterfaceUsage: @unchecked Sendable {}
extension Runtime_V1_ProcessUsage: @unchecked Sendable {}
extension Runtime_V1_WindowsProcessUsage: @unchecked Sendable {}
extension Runtime_V1_ImageSpec: @unchecked Sendable {}
extension Runtime_V1_KeyValue: @unchecked Sendable {}
extension Runtime_V1_LinuxContainerResources: @unchecked Sendable {}
extension Runtime_V1_HugepageLimit: @unchecked Sendable {}
extension Runtime_V1_SELinuxOption: @unchecked Sendable {}
extension Runtime_V1_Capability: @unchecked Sendable {}
extension Runtime_V1_LinuxContainerSecurityContext: @unchecked Sendable {}
extension Runtime_V1_LinuxContainerConfig: @unchecked Sendable {}
extension Runtime_V1_LinuxContainerUser: @unchecked Sendable {}
extension Runtime_V1_WindowsNamespaceOption: @unchecked Sendable {}
extension Runtime_V1_WindowsSandboxSecurityContext: @unchecked Sendable {}
extension Runtime_V1_WindowsPodSandboxConfig: @unchecked Sendable {}
extension Runtime_V1_WindowsContainerSecurityContext: @unchecked Sendable {}
extension Runtime_V1_WindowsContainerConfig: @unchecked Sendable {}
extension Runtime_V1_WindowsContainerResources: @unchecked Sendable {}
extension Runtime_V1_ContainerMetadata: @unchecked Sendable {}
extension Runtime_V1_Device: @unchecked Sendable {}
extension Runtime_V1_CDIDevice: @unchecked Sendable {}
extension Runtime_V1_ContainerConfig: @unchecked Sendable {}
extension Runtime_V1_CreateContainerRequest: @unchecked Sendable {}
extension Runtime_V1_CreateContainerResponse: @unchecked Sendable {}
extension Runtime_V1_StartContainerRequest: @unchecked Sendable {}
extension Runtime_V1_StartContainerResponse: @unchecked Sendable {}
extension Runtime_V1_StopContainerRequest: @unchecked Sendable {}
extension Runtime_V1_StopContainerResponse: @unchecked Sendable {}
extension Runtime_V1_RemoveContainerRequest: @unchecked Sendable {}
extension Runtime_V1_RemoveContainerResponse: @unchecked Sendable {}
extension Runtime_V1_ContainerStateValue: @unchecked Sendable {}
extension Runtime_V1_ContainerFilter: @unchecked Sendable {}
extension Runtime_V1_ListContainersRequest: @unchecked Sendable {}
extension Runtime_V1_Container: @unchecked Sendable {}
extension Runtime_V1_ListContainersResponse: @unchecked Sendable {}
extension Runtime_V1_ContainerStatusRequest: @unchecked Sendable {}
extension Runtime_V1_ContainerStatus: @unchecked Sendable {}
extension Runtime_V1_ContainerStatusResponse: @unchecked Sendable {}
extension Runtime_V1_ContainerResources: @unchecked Sendable {}
extension Runtime_V1_ContainerUser: @unchecked Sendable {}
extension Runtime_V1_UpdateContainerResourcesRequest: @unchecked Sendable {}
extension Runtime_V1_UpdateContainerResourcesResponse: @unchecked Sendable {}
extension Runtime_V1_ExecSyncRequest: @unchecked Sendable {}
extension Runtime_V1_ExecSyncResponse: @unchecked Sendable {}
extension Runtime_V1_ExecRequest: @unchecked Sendable {}
extension Runtime_V1_ExecResponse: @unchecked Sendable {}
extension Runtime_V1_AttachRequest: @unchecked Sendable {}
extension Runtime_V1_AttachResponse: @unchecked Sendable {}
extension Runtime_V1_PortForwardRequest: @unchecked Sendable {}
extension Runtime_V1_PortForwardResponse: @unchecked Sendable {}
extension Runtime_V1_ImageFilter: @unchecked Sendable {}
extension Runtime_V1_ListImagesRequest: @unchecked Sendable {}
extension Runtime_V1_Image: @unchecked Sendable {}
extension Runtime_V1_ListImagesResponse: @unchecked Sendable {}
extension Runtime_V1_ImageStatusRequest: @unchecked Sendable {}
extension Runtime_V1_ImageStatusResponse: @unchecked Sendable {}
extension Runtime_V1_AuthConfig: @unchecked Sendable {}
extension Runtime_V1_PullImageRequest: @unchecked Sendable {}
extension Runtime_V1_PullImageResponse: @unchecked Sendable {}
extension Runtime_V1_RemoveImageRequest: @unchecked Sendable {}
extension Runtime_V1_RemoveImageResponse: @unchecked Sendable {}
extension Runtime_V1_NetworkConfig: @unchecked Sendable {}
extension Runtime_V1_RuntimeConfig: @unchecked Sendable {}
extension Runtime_V1_UpdateRuntimeConfigRequest: @unchecked Sendable {}
extension Runtime_V1_UpdateRuntimeConfigResponse: @unchecked Sendable {}
extension Runtime_V1_RuntimeCondition: @unchecked Sendable {}
extension Runtime_V1_RuntimeStatus: @unchecked Sendable {}
extension Runtime_V1_StatusRequest: @unchecked Sendable {}
extension Runtime_V1_RuntimeHandlerFeatures: @unchecked Sendable {}
extension Runtime_V1_RuntimeHandler: @unchecked Sendable {}
extension Runtime_V1_StatusResponse: @unchecked Sendable {}
extension Runtime_V1_ImageFsInfoRequest: @unchecked Sendable {}
extension Runtime_V1_UInt64Value: @unchecked Sendable {}
extension Runtime_V1_FilesystemIdentifier: @unchecked Sendable {}
extension Runtime_V1_FilesystemUsage: @unchecked Sendable {}
extension Runtime_V1_WindowsFilesystemUsage: @unchecked Sendable {}
extension Runtime_V1_ImageFsInfoResponse: @unchecked Sendable {}
extension Runtime_V1_ContainerStatsRequest: @unchecked Sendable {}
extension Runtime_V1_ContainerStatsResponse: @unchecked Sendable {}
extension Runtime_V1_ListContainerStatsRequest: @unchecked Sendable {}
extension Runtime_V1_ContainerStatsFilter: @unchecked Sendable {}
extension Runtime_V1_ListContainerStatsResponse: @unchecked Sendable {}
extension Runtime_V1_ContainerAttributes: @unchecked Sendable {}
extension Runtime_V1_ContainerStats: @unchecked Sendable {}
extension Runtime_V1_WindowsContainerStats: @unchecked Sendable {}
extension Runtime_V1_CpuUsage: @unchecked Sendable {}
extension Runtime_V1_WindowsCpuUsage: @unchecked Sendable {}
extension Runtime_V1_MemoryUsage: @unchecked Sendable {}
extension Runtime_V1_SwapUsage: @unchecked Sendable {}
extension Runtime_V1_WindowsMemoryUsage: @unchecked Sendable {}
extension Runtime_V1_ReopenContainerLogRequest: @unchecked Sendable {}
extension Runtime_V1_ReopenContainerLogResponse: @unchecked Sendable {}
extension Runtime_V1_CheckpointContainerRequest: @unchecked Sendable {}
extension Runtime_V1_CheckpointContainerResponse: @unchecked Sendable {}
extension Runtime_V1_GetEventsRequest: @unchecked Sendable {}
extension Runtime_V1_ContainerEventResponse: @unchecked Sendable {}
extension Runtime_V1_ListMetricDescriptorsRequest: @unchecked Sendable {}
extension Runtime_V1_ListMetricDescriptorsResponse: @unchecked Sendable {}
extension Runtime_V1_MetricDescriptor: @unchecked Sendable {}
extension Runtime_V1_ListPodSandboxMetricsRequest: @unchecked Sendable {}
extension Runtime_V1_ListPodSandboxMetricsResponse: @unchecked Sendable {}
extension Runtime_V1_PodSandboxMetrics: @unchecked Sendable {}
extension Runtime_V1_ContainerMetrics: @unchecked Sendable {}
extension Runtime_V1_Metric: @unchecked Sendable {}
extension Runtime_V1_RuntimeConfigRequest: @unchecked Sendable {}
extension Runtime_V1_RuntimeConfigResponse: @unchecked Sendable {}
extension Runtime_V1_LinuxRuntimeConfiguration: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "runtime.v1"

extension Runtime_V1_Protocol: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TCP"),
    1: .same(proto: "UDP"),
    2: .same(proto: "SCTP"),
  ]
}

extension Runtime_V1_MountPropagation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPAGATION_PRIVATE"),
    1: .same(proto: "PROPAGATION_HOST_TO_CONTAINER"),
    2: .same(proto: "PROPAGATION_BIDIRECTIONAL"),
  ]
}

extension Runtime_V1_NamespaceMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POD"),
    1: .same(proto: "CONTAINER"),
    2: .same(proto: "NODE"),
    3: .same(proto: "TARGET"),
  ]
}

extension Runtime_V1_SupplementalGroupsPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Merge"),
    1: .same(proto: "Strict"),
  ]
}

extension Runtime_V1_PodSandboxState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SANDBOX_READY"),
    1: .same(proto: "SANDBOX_NOTREADY"),
  ]
}

extension Runtime_V1_ContainerState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTAINER_CREATED"),
    1: .same(proto: "CONTAINER_RUNNING"),
    2: .same(proto: "CONTAINER_EXITED"),
    3: .same(proto: "CONTAINER_UNKNOWN"),
  ]
}

extension Runtime_V1_ContainerEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTAINER_CREATED_EVENT"),
    1: .same(proto: "CONTAINER_STARTED_EVENT"),
    2: .same(proto: "CONTAINER_STOPPED_EVENT"),
    3: .same(proto: "CONTAINER_DELETED_EVENT"),
  ]
}

extension Runtime_V1_MetricType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COUNTER"),
    1: .same(proto: "GAUGE"),
  ]
}

extension Runtime_V1_CgroupDriver: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYSTEMD"),
    1: .same(proto: "CGROUPFS"),
  ]
}

extension Runtime_V1_VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VersionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_VersionRequest, rhs: Runtime_V1_VersionRequest) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "runtime_name"),
    3: .standard(proto: "runtime_version"),
    4: .standard(proto: "runtime_api_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runtimeName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runtimeVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.runtimeApiVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.runtimeName.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeName, fieldNumber: 2)
    }
    if !self.runtimeVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeVersion, fieldNumber: 3)
    }
    if !self.runtimeApiVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeApiVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_VersionResponse, rhs: Runtime_V1_VersionResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.runtimeName != rhs.runtimeName {return false}
    if lhs.runtimeVersion != rhs.runtimeVersion {return false}
    if lhs.runtimeApiVersion != rhs.runtimeApiVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_DNSConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DNSConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "servers"),
    2: .same(proto: "searches"),
    3: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.servers) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.searches) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.servers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.servers, fieldNumber: 1)
    }
    if !self.searches.isEmpty {
      try visitor.visitRepeatedStringField(value: self.searches, fieldNumber: 2)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedStringField(value: self.options, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_DNSConfig, rhs: Runtime_V1_DNSConfig) -> Bool {
    if lhs.servers != rhs.servers {return false}
    if lhs.searches != rhs.searches {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PortMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protocol"),
    2: .standard(proto: "container_port"),
    3: .standard(proto: "host_port"),
    4: .standard(proto: "host_ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`protocol`) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.containerPort) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.hostPort) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hostIp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`protocol` != .tcp {
      try visitor.visitSingularEnumField(value: self.`protocol`, fieldNumber: 1)
    }
    if self.containerPort != 0 {
      try visitor.visitSingularInt32Field(value: self.containerPort, fieldNumber: 2)
    }
    if self.hostPort != 0 {
      try visitor.visitSingularInt32Field(value: self.hostPort, fieldNumber: 3)
    }
    if !self.hostIp.isEmpty {
      try visitor.visitSingularStringField(value: self.hostIp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PortMapping, rhs: Runtime_V1_PortMapping) -> Bool {
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.containerPort != rhs.containerPort {return false}
    if lhs.hostPort != rhs.hostPort {return false}
    if lhs.hostIp != rhs.hostIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_Mount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Mount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_path"),
    2: .standard(proto: "host_path"),
    3: .same(proto: "readonly"),
    4: .standard(proto: "selinux_relabel"),
    5: .same(proto: "propagation"),
    6: .same(proto: "uidMappings"),
    7: .same(proto: "gidMappings"),
    8: .standard(proto: "recursive_read_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hostPath) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.readonly) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.selinuxRelabel) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.propagation) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.uidMappings) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.gidMappings) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.recursiveReadOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerPath.isEmpty {
      try visitor.visitSingularStringField(value: self.containerPath, fieldNumber: 1)
    }
    if !self.hostPath.isEmpty {
      try visitor.visitSingularStringField(value: self.hostPath, fieldNumber: 2)
    }
    if self.readonly != false {
      try visitor.visitSingularBoolField(value: self.readonly, fieldNumber: 3)
    }
    if self.selinuxRelabel != false {
      try visitor.visitSingularBoolField(value: self.selinuxRelabel, fieldNumber: 4)
    }
    if self.propagation != .propagationPrivate {
      try visitor.visitSingularEnumField(value: self.propagation, fieldNumber: 5)
    }
    if !self.uidMappings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uidMappings, fieldNumber: 6)
    }
    if !self.gidMappings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gidMappings, fieldNumber: 7)
    }
    if self.recursiveReadOnly != false {
      try visitor.visitSingularBoolField(value: self.recursiveReadOnly, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_Mount, rhs: Runtime_V1_Mount) -> Bool {
    if lhs.containerPath != rhs.containerPath {return false}
    if lhs.hostPath != rhs.hostPath {return false}
    if lhs.readonly != rhs.readonly {return false}
    if lhs.selinuxRelabel != rhs.selinuxRelabel {return false}
    if lhs.propagation != rhs.propagation {return false}
    if lhs.uidMappings != rhs.uidMappings {return false}
    if lhs.gidMappings != rhs.gidMappings {return false}
    if lhs.recursiveReadOnly != rhs.recursiveReadOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_IDMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IDMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "host_id"),
    2: .standard(proto: "container_id"),
    3: .same(proto: "length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.hostID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.containerID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hostID != 0 {
      try visitor.visitSingularUInt32Field(value: self.hostID, fieldNumber: 1)
    }
    if self.containerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.containerID, fieldNumber: 2)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_IDMapping, rhs: Runtime_V1_IDMapping) -> Bool {
    if lhs.hostID != rhs.hostID {return false}
    if lhs.containerID != rhs.containerID {return false}
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_UserNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserNamespace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "uids"),
    3: .same(proto: "gids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uids) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.gids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .pod {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if !self.uids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uids, fieldNumber: 2)
    }
    if !self.gids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_UserNamespace, rhs: Runtime_V1_UserNamespace) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.uids != rhs.uids {return false}
    if lhs.gids != rhs.gids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_NamespaceOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamespaceOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
    2: .same(proto: "pid"),
    3: .same(proto: "ipc"),
    4: .standard(proto: "target_id"),
    5: .standard(proto: "userns_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.network) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.pid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.ipc) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._usernsOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.network != .pod {
      try visitor.visitSingularEnumField(value: self.network, fieldNumber: 1)
    }
    if self.pid != .pod {
      try visitor.visitSingularEnumField(value: self.pid, fieldNumber: 2)
    }
    if self.ipc != .pod {
      try visitor.visitSingularEnumField(value: self.ipc, fieldNumber: 3)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 4)
    }
    try { if let v = self._usernsOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_NamespaceOption, rhs: Runtime_V1_NamespaceOption) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.ipc != rhs.ipc {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs._usernsOptions != rhs._usernsOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_Int64Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Int64Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_Int64Value, rhs: Runtime_V1_Int64Value) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_LinuxSandboxSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxSandboxSecurityContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "namespace_options"),
    2: .standard(proto: "selinux_options"),
    3: .standard(proto: "run_as_user"),
    8: .standard(proto: "run_as_group"),
    4: .standard(proto: "readonly_rootfs"),
    5: .standard(proto: "supplemental_groups"),
    11: .standard(proto: "supplemental_groups_policy"),
    6: .same(proto: "privileged"),
    9: .same(proto: "seccomp"),
    10: .same(proto: "apparmor"),
    7: .standard(proto: "seccomp_profile_path"),
  ]

  fileprivate class _StorageClass {
    var _namespaceOptions: Runtime_V1_NamespaceOption? = nil
    var _selinuxOptions: Runtime_V1_SELinuxOption? = nil
    var _runAsUser: Runtime_V1_Int64Value? = nil
    var _runAsGroup: Runtime_V1_Int64Value? = nil
    var _readonlyRootfs: Bool = false
    var _supplementalGroups: [Int64] = []
    var _supplementalGroupsPolicy: Runtime_V1_SupplementalGroupsPolicy = .merge
    var _privileged: Bool = false
    var _seccomp: Runtime_V1_SecurityProfile? = nil
    var _apparmor: Runtime_V1_SecurityProfile? = nil
    var _seccompProfilePath: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _namespaceOptions = source._namespaceOptions
      _selinuxOptions = source._selinuxOptions
      _runAsUser = source._runAsUser
      _runAsGroup = source._runAsGroup
      _readonlyRootfs = source._readonlyRootfs
      _supplementalGroups = source._supplementalGroups
      _supplementalGroupsPolicy = source._supplementalGroupsPolicy
      _privileged = source._privileged
      _seccomp = source._seccomp
      _apparmor = source._apparmor
      _seccompProfilePath = source._seccompProfilePath
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._namespaceOptions) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._selinuxOptions) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._runAsUser) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._readonlyRootfs) }()
        case 5: try { try decoder.decodeRepeatedInt64Field(value: &_storage._supplementalGroups) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._privileged) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._seccompProfilePath) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._runAsGroup) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._seccomp) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._apparmor) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._supplementalGroupsPolicy) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._namespaceOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._selinuxOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._runAsUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._readonlyRootfs != false {
        try visitor.visitSingularBoolField(value: _storage._readonlyRootfs, fieldNumber: 4)
      }
      if !_storage._supplementalGroups.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._supplementalGroups, fieldNumber: 5)
      }
      if _storage._privileged != false {
        try visitor.visitSingularBoolField(value: _storage._privileged, fieldNumber: 6)
      }
      if !_storage._seccompProfilePath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._seccompProfilePath, fieldNumber: 7)
      }
      try { if let v = _storage._runAsGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._seccomp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._apparmor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._supplementalGroupsPolicy != .merge {
        try visitor.visitSingularEnumField(value: _storage._supplementalGroupsPolicy, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxSandboxSecurityContext, rhs: Runtime_V1_LinuxSandboxSecurityContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespaceOptions != rhs_storage._namespaceOptions {return false}
        if _storage._selinuxOptions != rhs_storage._selinuxOptions {return false}
        if _storage._runAsUser != rhs_storage._runAsUser {return false}
        if _storage._runAsGroup != rhs_storage._runAsGroup {return false}
        if _storage._readonlyRootfs != rhs_storage._readonlyRootfs {return false}
        if _storage._supplementalGroups != rhs_storage._supplementalGroups {return false}
        if _storage._supplementalGroupsPolicy != rhs_storage._supplementalGroupsPolicy {return false}
        if _storage._privileged != rhs_storage._privileged {return false}
        if _storage._seccomp != rhs_storage._seccomp {return false}
        if _storage._apparmor != rhs_storage._apparmor {return false}
        if _storage._seccompProfilePath != rhs_storage._seccompProfilePath {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_SecurityProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecurityProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "profile_type"),
    2: .standard(proto: "localhost_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.profileType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.localhostRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.profileType != .runtimeDefault {
      try visitor.visitSingularEnumField(value: self.profileType, fieldNumber: 1)
    }
    if !self.localhostRef.isEmpty {
      try visitor.visitSingularStringField(value: self.localhostRef, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_SecurityProfile, rhs: Runtime_V1_SecurityProfile) -> Bool {
    if lhs.profileType != rhs.profileType {return false}
    if lhs.localhostRef != rhs.localhostRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_SecurityProfile.ProfileType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RuntimeDefault"),
    1: .same(proto: "Unconfined"),
    2: .same(proto: "Localhost"),
  ]
}

extension Runtime_V1_LinuxPodSandboxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxPodSandboxConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cgroup_parent"),
    2: .standard(proto: "security_context"),
    3: .same(proto: "sysctls"),
    4: .same(proto: "overhead"),
    5: .same(proto: "resources"),
  ]

  fileprivate class _StorageClass {
    var _cgroupParent: String = String()
    var _securityContext: Runtime_V1_LinuxSandboxSecurityContext? = nil
    var _sysctls: Dictionary<String,String> = [:]
    var _overhead: Runtime_V1_LinuxContainerResources? = nil
    var _resources: Runtime_V1_LinuxContainerResources? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _cgroupParent = source._cgroupParent
      _securityContext = source._securityContext
      _sysctls = source._sysctls
      _overhead = source._overhead
      _resources = source._resources
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._cgroupParent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._securityContext) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._sysctls) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._overhead) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._resources) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._cgroupParent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cgroupParent, fieldNumber: 1)
      }
      try { if let v = _storage._securityContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._sysctls.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._sysctls, fieldNumber: 3)
      }
      try { if let v = _storage._overhead {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._resources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxPodSandboxConfig, rhs: Runtime_V1_LinuxPodSandboxConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cgroupParent != rhs_storage._cgroupParent {return false}
        if _storage._securityContext != rhs_storage._securityContext {return false}
        if _storage._sysctls != rhs_storage._sysctls {return false}
        if _storage._overhead != rhs_storage._overhead {return false}
        if _storage._resources != rhs_storage._resources {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "uid"),
    3: .same(proto: "namespace"),
    4: .same(proto: "attempt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.attempt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 2)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 3)
    }
    if self.attempt != 0 {
      try visitor.visitSingularUInt32Field(value: self.attempt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxMetadata, rhs: Runtime_V1_PodSandboxMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "hostname"),
    3: .standard(proto: "log_directory"),
    4: .standard(proto: "dns_config"),
    5: .standard(proto: "port_mappings"),
    6: .same(proto: "labels"),
    7: .same(proto: "annotations"),
    8: .same(proto: "linux"),
    9: .same(proto: "windows"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Runtime_V1_PodSandboxMetadata? = nil
    var _hostname: String = String()
    var _logDirectory: String = String()
    var _dnsConfig: Runtime_V1_DNSConfig? = nil
    var _portMappings: [Runtime_V1_PortMapping] = []
    var _labels: Dictionary<String,String> = [:]
    var _annotations: Dictionary<String,String> = [:]
    var _linux: Runtime_V1_LinuxPodSandboxConfig? = nil
    var _windows: Runtime_V1_WindowsPodSandboxConfig? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _hostname = source._hostname
      _logDirectory = source._logDirectory
      _dnsConfig = source._dnsConfig
      _portMappings = source._portMappings
      _labels = source._labels
      _annotations = source._annotations
      _linux = source._linux
      _windows = source._windows
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._logDirectory) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._dnsConfig) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._portMappings) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._annotations) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._linux) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._windows) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 2)
      }
      if !_storage._logDirectory.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logDirectory, fieldNumber: 3)
      }
      try { if let v = _storage._dnsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._portMappings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._portMappings, fieldNumber: 5)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 6)
      }
      if !_storage._annotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._annotations, fieldNumber: 7)
      }
      try { if let v = _storage._linux {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._windows {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxConfig, rhs: Runtime_V1_PodSandboxConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._logDirectory != rhs_storage._logDirectory {return false}
        if _storage._dnsConfig != rhs_storage._dnsConfig {return false}
        if _storage._portMappings != rhs_storage._portMappings {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._annotations != rhs_storage._annotations {return false}
        if _storage._linux != rhs_storage._linux {return false}
        if _storage._windows != rhs_storage._windows {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RunPodSandboxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunPodSandboxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .standard(proto: "runtime_handler"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runtimeHandler) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.runtimeHandler.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeHandler, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RunPodSandboxRequest, rhs: Runtime_V1_RunPodSandboxRequest) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.runtimeHandler != rhs.runtimeHandler {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RunPodSandboxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunPodSandboxResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_sandbox_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RunPodSandboxResponse, rhs: Runtime_V1_RunPodSandboxResponse) -> Bool {
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_StopPodSandboxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopPodSandboxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_sandbox_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_StopPodSandboxRequest, rhs: Runtime_V1_StopPodSandboxRequest) -> Bool {
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_StopPodSandboxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopPodSandboxResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_StopPodSandboxResponse, rhs: Runtime_V1_StopPodSandboxResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RemovePodSandboxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemovePodSandboxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_sandbox_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RemovePodSandboxRequest, rhs: Runtime_V1_RemovePodSandboxRequest) -> Bool {
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RemovePodSandboxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemovePodSandboxResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RemovePodSandboxResponse, rhs: Runtime_V1_RemovePodSandboxResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_sandbox_id"),
    2: .same(proto: "verbose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.verbose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 1)
    }
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxStatusRequest, rhs: Runtime_V1_PodSandboxStatusRequest) -> Bool {
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.verbose != rhs.verbose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodIP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodIP"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodIP, rhs: Runtime_V1_PodIP) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxNetworkStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxNetworkStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .standard(proto: "additional_ips"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.additionalIps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    if !self.additionalIps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.additionalIps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxNetworkStatus, rhs: Runtime_V1_PodSandboxNetworkStatus) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.additionalIps != rhs.additionalIps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_Namespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Namespace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_Namespace, rhs: Runtime_V1_Namespace) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_LinuxPodSandboxStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxPodSandboxStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._namespaces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._namespaces {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxPodSandboxStatus, rhs: Runtime_V1_LinuxPodSandboxStatus) -> Bool {
    if lhs._namespaces != rhs._namespaces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
    3: .same(proto: "state"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "network"),
    6: .same(proto: "linux"),
    7: .same(proto: "labels"),
    8: .same(proto: "annotations"),
    9: .standard(proto: "runtime_handler"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _metadata: Runtime_V1_PodSandboxMetadata? = nil
    var _state: Runtime_V1_PodSandboxState = .sandboxReady
    var _createdAt: Int64 = 0
    var _network: Runtime_V1_PodSandboxNetworkStatus? = nil
    var _linux: Runtime_V1_LinuxPodSandboxStatus? = nil
    var _labels: Dictionary<String,String> = [:]
    var _annotations: Dictionary<String,String> = [:]
    var _runtimeHandler: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _metadata = source._metadata
      _state = source._state
      _createdAt = source._createdAt
      _network = source._network
      _linux = source._linux
      _labels = source._labels
      _annotations = source._annotations
      _runtimeHandler = source._runtimeHandler
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._network) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._linux) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._annotations) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._runtimeHandler) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._state != .sandboxReady {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 4)
      }
      try { if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._linux {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 7)
      }
      if !_storage._annotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._annotations, fieldNumber: 8)
      }
      if !_storage._runtimeHandler.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runtimeHandler, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxStatus, rhs: Runtime_V1_PodSandboxStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._linux != rhs_storage._linux {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._annotations != rhs_storage._annotations {return false}
        if _storage._runtimeHandler != rhs_storage._runtimeHandler {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "info"),
    3: .standard(proto: "containers_statuses"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.info) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.containersStatuses) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.info, fieldNumber: 2)
    }
    if !self.containersStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.containersStatuses, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxStatusResponse, rhs: Runtime_V1_PodSandboxStatusResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.info != rhs.info {return false}
    if lhs.containersStatuses != rhs.containersStatuses {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxStateValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxStateValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .sandboxReady {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxStateValue, rhs: Runtime_V1_PodSandboxStateValue) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "state"),
    3: .standard(proto: "label_selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labelSelector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.labelSelector.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labelSelector, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxFilter, rhs: Runtime_V1_PodSandboxFilter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._state != rhs._state {return false}
    if lhs.labelSelector != rhs.labelSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListPodSandboxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPodSandboxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListPodSandboxRequest, rhs: Runtime_V1_ListPodSandboxRequest) -> Bool {
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandbox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandbox"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
    3: .same(proto: "state"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "labels"),
    6: .same(proto: "annotations"),
    7: .standard(proto: "runtime_handler"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.createdAt) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.annotations) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.runtimeHandler) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.state != .sandboxReady {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAt, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    if !self.annotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.annotations, fieldNumber: 6)
    }
    if !self.runtimeHandler.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeHandler, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandbox, rhs: Runtime_V1_PodSandbox) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.state != rhs.state {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.runtimeHandler != rhs.runtimeHandler {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListPodSandboxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPodSandboxResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListPodSandboxResponse, rhs: Runtime_V1_ListPodSandboxResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxStatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_sandbox_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxStatsRequest, rhs: Runtime_V1_PodSandboxStatsRequest) -> Bool {
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxStatsResponse, rhs: Runtime_V1_PodSandboxStatsResponse) -> Bool {
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxStatsFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxStatsFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "label_selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labelSelector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.labelSelector.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labelSelector, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxStatsFilter, rhs: Runtime_V1_PodSandboxStatsFilter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.labelSelector != rhs.labelSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListPodSandboxStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPodSandboxStatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListPodSandboxStatsRequest, rhs: Runtime_V1_ListPodSandboxStatsRequest) -> Bool {
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListPodSandboxStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPodSandboxStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListPodSandboxStatsResponse, rhs: Runtime_V1_ListPodSandboxStatsResponse) -> Bool {
    if lhs.stats != rhs.stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
    3: .same(proto: "labels"),
    4: .same(proto: "annotations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.annotations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    if !self.annotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.annotations, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxAttributes, rhs: Runtime_V1_PodSandboxAttributes) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributes"),
    2: .same(proto: "linux"),
    3: .same(proto: "windows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._linux) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._windows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._linux {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._windows {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxStats, rhs: Runtime_V1_PodSandboxStats) -> Bool {
    if lhs._attributes != rhs._attributes {return false}
    if lhs._linux != rhs._linux {return false}
    if lhs._windows != rhs._windows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_LinuxPodSandboxStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxPodSandboxStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cpu"),
    2: .same(proto: "memory"),
    3: .same(proto: "network"),
    4: .same(proto: "process"),
    5: .same(proto: "containers"),
  ]

  fileprivate class _StorageClass {
    var _cpu: Runtime_V1_CpuUsage? = nil
    var _memory: Runtime_V1_MemoryUsage? = nil
    var _network: Runtime_V1_NetworkUsage? = nil
    var _process: Runtime_V1_ProcessUsage? = nil
    var _containers: [Runtime_V1_ContainerStats] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _cpu = source._cpu
      _memory = source._memory
      _network = source._network
      _process = source._process
      _containers = source._containers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._cpu) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._memory) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._network) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._process) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._containers) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._cpu {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._memory {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._process {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._containers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._containers, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxPodSandboxStats, rhs: Runtime_V1_LinuxPodSandboxStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._process != rhs_storage._process {return false}
        if _storage._containers != rhs_storage._containers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsPodSandboxStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsPodSandboxStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cpu"),
    2: .same(proto: "memory"),
    3: .same(proto: "network"),
    4: .same(proto: "process"),
    5: .same(proto: "containers"),
  ]

  fileprivate class _StorageClass {
    var _cpu: Runtime_V1_WindowsCpuUsage? = nil
    var _memory: Runtime_V1_WindowsMemoryUsage? = nil
    var _network: Runtime_V1_WindowsNetworkUsage? = nil
    var _process: Runtime_V1_WindowsProcessUsage? = nil
    var _containers: [Runtime_V1_WindowsContainerStats] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _cpu = source._cpu
      _memory = source._memory
      _network = source._network
      _process = source._process
      _containers = source._containers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._cpu) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._memory) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._network) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._process) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._containers) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._cpu {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._memory {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._process {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._containers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._containers, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsPodSandboxStats, rhs: Runtime_V1_WindowsPodSandboxStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._process != rhs_storage._process {return false}
        if _storage._containers != rhs_storage._containers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_NetworkUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "default_interface"),
    3: .same(proto: "interfaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._defaultInterface) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.interfaces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._defaultInterface {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.interfaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interfaces, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_NetworkUsage, rhs: Runtime_V1_NetworkUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._defaultInterface != rhs._defaultInterface {return false}
    if lhs.interfaces != rhs.interfaces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsNetworkUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsNetworkUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "default_interface"),
    3: .same(proto: "interfaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._defaultInterface) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.interfaces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._defaultInterface {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.interfaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interfaces, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsNetworkUsage, rhs: Runtime_V1_WindowsNetworkUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._defaultInterface != rhs._defaultInterface {return false}
    if lhs.interfaces != rhs.interfaces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_NetworkInterfaceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInterfaceUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "rx_bytes"),
    3: .standard(proto: "rx_errors"),
    4: .standard(proto: "tx_bytes"),
    5: .standard(proto: "tx_errors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rxBytes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rxErrors) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._txBytes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._txErrors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._rxBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rxErrors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._txBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._txErrors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_NetworkInterfaceUsage, rhs: Runtime_V1_NetworkInterfaceUsage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._rxBytes != rhs._rxBytes {return false}
    if lhs._rxErrors != rhs._rxErrors {return false}
    if lhs._txBytes != rhs._txBytes {return false}
    if lhs._txErrors != rhs._txErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsNetworkInterfaceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsNetworkInterfaceUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "rx_bytes"),
    3: .standard(proto: "rx_packets_dropped"),
    4: .standard(proto: "tx_bytes"),
    5: .standard(proto: "tx_packets_dropped"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rxBytes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rxPacketsDropped) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._txBytes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._txPacketsDropped) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._rxBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rxPacketsDropped {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._txBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._txPacketsDropped {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsNetworkInterfaceUsage, rhs: Runtime_V1_WindowsNetworkInterfaceUsage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._rxBytes != rhs._rxBytes {return false}
    if lhs._rxPacketsDropped != rhs._rxPacketsDropped {return false}
    if lhs._txBytes != rhs._txBytes {return false}
    if lhs._txPacketsDropped != rhs._txPacketsDropped {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ProcessUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "process_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._processCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._processCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ProcessUsage, rhs: Runtime_V1_ProcessUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._processCount != rhs._processCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsProcessUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsProcessUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "process_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._processCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._processCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsProcessUsage, rhs: Runtime_V1_WindowsProcessUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._processCount != rhs._processCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ImageSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "annotations"),
    18: .standard(proto: "user_specified_image"),
    19: .standard(proto: "runtime_handler"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.image) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.annotations) }()
      case 18: try { try decoder.decodeSingularStringField(value: &self.userSpecifiedImage) }()
      case 19: try { try decoder.decodeSingularStringField(value: &self.runtimeHandler) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 1)
    }
    if !self.annotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.annotations, fieldNumber: 2)
    }
    if !self.userSpecifiedImage.isEmpty {
      try visitor.visitSingularStringField(value: self.userSpecifiedImage, fieldNumber: 18)
    }
    if !self.runtimeHandler.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeHandler, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ImageSpec, rhs: Runtime_V1_ImageSpec) -> Bool {
    if lhs.image != rhs.image {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.userSpecifiedImage != rhs.userSpecifiedImage {return false}
    if lhs.runtimeHandler != rhs.runtimeHandler {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_KeyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_KeyValue, rhs: Runtime_V1_KeyValue) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_LinuxContainerResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxContainerResources"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpu_period"),
    2: .standard(proto: "cpu_quota"),
    3: .standard(proto: "cpu_shares"),
    4: .standard(proto: "memory_limit_in_bytes"),
    5: .standard(proto: "oom_score_adj"),
    6: .standard(proto: "cpuset_cpus"),
    7: .standard(proto: "cpuset_mems"),
    8: .standard(proto: "hugepage_limits"),
    9: .same(proto: "unified"),
    10: .standard(proto: "memory_swap_limit_in_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.cpuPeriod) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.cpuQuota) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.cpuShares) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.memoryLimitInBytes) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.oomScoreAdj) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.cpusetCpus) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.cpusetMems) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.hugepageLimits) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.unified) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.memorySwapLimitInBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuPeriod != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuPeriod, fieldNumber: 1)
    }
    if self.cpuQuota != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuQuota, fieldNumber: 2)
    }
    if self.cpuShares != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuShares, fieldNumber: 3)
    }
    if self.memoryLimitInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.memoryLimitInBytes, fieldNumber: 4)
    }
    if self.oomScoreAdj != 0 {
      try visitor.visitSingularInt64Field(value: self.oomScoreAdj, fieldNumber: 5)
    }
    if !self.cpusetCpus.isEmpty {
      try visitor.visitSingularStringField(value: self.cpusetCpus, fieldNumber: 6)
    }
    if !self.cpusetMems.isEmpty {
      try visitor.visitSingularStringField(value: self.cpusetMems, fieldNumber: 7)
    }
    if !self.hugepageLimits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hugepageLimits, fieldNumber: 8)
    }
    if !self.unified.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.unified, fieldNumber: 9)
    }
    if self.memorySwapLimitInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.memorySwapLimitInBytes, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxContainerResources, rhs: Runtime_V1_LinuxContainerResources) -> Bool {
    if lhs.cpuPeriod != rhs.cpuPeriod {return false}
    if lhs.cpuQuota != rhs.cpuQuota {return false}
    if lhs.cpuShares != rhs.cpuShares {return false}
    if lhs.memoryLimitInBytes != rhs.memoryLimitInBytes {return false}
    if lhs.oomScoreAdj != rhs.oomScoreAdj {return false}
    if lhs.cpusetCpus != rhs.cpusetCpus {return false}
    if lhs.cpusetMems != rhs.cpusetMems {return false}
    if lhs.hugepageLimits != rhs.hugepageLimits {return false}
    if lhs.unified != rhs.unified {return false}
    if lhs.memorySwapLimitInBytes != rhs.memorySwapLimitInBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_HugepageLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HugepageLimit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageSize.isEmpty {
      try visitor.visitSingularStringField(value: self.pageSize, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_HugepageLimit, rhs: Runtime_V1_HugepageLimit) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_SELinuxOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SELinuxOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "role"),
    3: .same(proto: "type"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if !self.level.isEmpty {
      try visitor.visitSingularStringField(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_SELinuxOption, rhs: Runtime_V1_SELinuxOption) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.role != rhs.role {return false}
    if lhs.type != rhs.type {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_Capability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capability"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "add_capabilities"),
    2: .standard(proto: "drop_capabilities"),
    3: .standard(proto: "add_ambient_capabilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addCapabilities) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.dropCapabilities) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addAmbientCapabilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addCapabilities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addCapabilities, fieldNumber: 1)
    }
    if !self.dropCapabilities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dropCapabilities, fieldNumber: 2)
    }
    if !self.addAmbientCapabilities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addAmbientCapabilities, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_Capability, rhs: Runtime_V1_Capability) -> Bool {
    if lhs.addCapabilities != rhs.addCapabilities {return false}
    if lhs.dropCapabilities != rhs.dropCapabilities {return false}
    if lhs.addAmbientCapabilities != rhs.addAmbientCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_LinuxContainerSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxContainerSecurityContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capabilities"),
    2: .same(proto: "privileged"),
    3: .standard(proto: "namespace_options"),
    4: .standard(proto: "selinux_options"),
    5: .standard(proto: "run_as_user"),
    12: .standard(proto: "run_as_group"),
    6: .standard(proto: "run_as_username"),
    7: .standard(proto: "readonly_rootfs"),
    8: .standard(proto: "supplemental_groups"),
    17: .standard(proto: "supplemental_groups_policy"),
    11: .standard(proto: "no_new_privs"),
    13: .standard(proto: "masked_paths"),
    14: .standard(proto: "readonly_paths"),
    15: .same(proto: "seccomp"),
    16: .same(proto: "apparmor"),
    9: .standard(proto: "apparmor_profile"),
    10: .standard(proto: "seccomp_profile_path"),
  ]

  fileprivate class _StorageClass {
    var _capabilities: Runtime_V1_Capability? = nil
    var _privileged: Bool = false
    var _namespaceOptions: Runtime_V1_NamespaceOption? = nil
    var _selinuxOptions: Runtime_V1_SELinuxOption? = nil
    var _runAsUser: Runtime_V1_Int64Value? = nil
    var _runAsGroup: Runtime_V1_Int64Value? = nil
    var _runAsUsername: String = String()
    var _readonlyRootfs: Bool = false
    var _supplementalGroups: [Int64] = []
    var _supplementalGroupsPolicy: Runtime_V1_SupplementalGroupsPolicy = .merge
    var _noNewPrivs: Bool = false
    var _maskedPaths: [String] = []
    var _readonlyPaths: [String] = []
    var _seccomp: Runtime_V1_SecurityProfile? = nil
    var _apparmor: Runtime_V1_SecurityProfile? = nil
    var _apparmorProfile: String = String()
    var _seccompProfilePath: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _capabilities = source._capabilities
      _privileged = source._privileged
      _namespaceOptions = source._namespaceOptions
      _selinuxOptions = source._selinuxOptions
      _runAsUser = source._runAsUser
      _runAsGroup = source._runAsGroup
      _runAsUsername = source._runAsUsername
      _readonlyRootfs = source._readonlyRootfs
      _supplementalGroups = source._supplementalGroups
      _supplementalGroupsPolicy = source._supplementalGroupsPolicy
      _noNewPrivs = source._noNewPrivs
      _maskedPaths = source._maskedPaths
      _readonlyPaths = source._readonlyPaths
      _seccomp = source._seccomp
      _apparmor = source._apparmor
      _apparmorProfile = source._apparmorProfile
      _seccompProfilePath = source._seccompProfilePath
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._capabilities) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._privileged) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._namespaceOptions) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._selinuxOptions) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._runAsUser) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._runAsUsername) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._readonlyRootfs) }()
        case 8: try { try decoder.decodeRepeatedInt64Field(value: &_storage._supplementalGroups) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._apparmorProfile) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._seccompProfilePath) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._noNewPrivs) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._runAsGroup) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._maskedPaths) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._readonlyPaths) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._seccomp) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._apparmor) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._supplementalGroupsPolicy) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._capabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._privileged != false {
        try visitor.visitSingularBoolField(value: _storage._privileged, fieldNumber: 2)
      }
      try { if let v = _storage._namespaceOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._selinuxOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._runAsUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._runAsUsername.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runAsUsername, fieldNumber: 6)
      }
      if _storage._readonlyRootfs != false {
        try visitor.visitSingularBoolField(value: _storage._readonlyRootfs, fieldNumber: 7)
      }
      if !_storage._supplementalGroups.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._supplementalGroups, fieldNumber: 8)
      }
      if !_storage._apparmorProfile.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apparmorProfile, fieldNumber: 9)
      }
      if !_storage._seccompProfilePath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._seccompProfilePath, fieldNumber: 10)
      }
      if _storage._noNewPrivs != false {
        try visitor.visitSingularBoolField(value: _storage._noNewPrivs, fieldNumber: 11)
      }
      try { if let v = _storage._runAsGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._maskedPaths.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._maskedPaths, fieldNumber: 13)
      }
      if !_storage._readonlyPaths.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._readonlyPaths, fieldNumber: 14)
      }
      try { if let v = _storage._seccomp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._apparmor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._supplementalGroupsPolicy != .merge {
        try visitor.visitSingularEnumField(value: _storage._supplementalGroupsPolicy, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxContainerSecurityContext, rhs: Runtime_V1_LinuxContainerSecurityContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._privileged != rhs_storage._privileged {return false}
        if _storage._namespaceOptions != rhs_storage._namespaceOptions {return false}
        if _storage._selinuxOptions != rhs_storage._selinuxOptions {return false}
        if _storage._runAsUser != rhs_storage._runAsUser {return false}
        if _storage._runAsGroup != rhs_storage._runAsGroup {return false}
        if _storage._runAsUsername != rhs_storage._runAsUsername {return false}
        if _storage._readonlyRootfs != rhs_storage._readonlyRootfs {return false}
        if _storage._supplementalGroups != rhs_storage._supplementalGroups {return false}
        if _storage._supplementalGroupsPolicy != rhs_storage._supplementalGroupsPolicy {return false}
        if _storage._noNewPrivs != rhs_storage._noNewPrivs {return false}
        if _storage._maskedPaths != rhs_storage._maskedPaths {return false}
        if _storage._readonlyPaths != rhs_storage._readonlyPaths {return false}
        if _storage._seccomp != rhs_storage._seccomp {return false}
        if _storage._apparmor != rhs_storage._apparmor {return false}
        if _storage._apparmorProfile != rhs_storage._apparmorProfile {return false}
        if _storage._seccompProfilePath != rhs_storage._seccompProfilePath {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_LinuxContainerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxContainerConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resources"),
    2: .standard(proto: "security_context"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resources) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._securityContext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resources {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._securityContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxContainerConfig, rhs: Runtime_V1_LinuxContainerConfig) -> Bool {
    if lhs._resources != rhs._resources {return false}
    if lhs._securityContext != rhs._securityContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_LinuxContainerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxContainerUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "gid"),
    3: .standard(proto: "supplemental_groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.gid) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.supplementalGroups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if self.gid != 0 {
      try visitor.visitSingularInt64Field(value: self.gid, fieldNumber: 2)
    }
    if !self.supplementalGroups.isEmpty {
      try visitor.visitPackedInt64Field(value: self.supplementalGroups, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxContainerUser, rhs: Runtime_V1_LinuxContainerUser) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.supplementalGroups != rhs.supplementalGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsNamespaceOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsNamespaceOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.network) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.network != .pod {
      try visitor.visitSingularEnumField(value: self.network, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsNamespaceOption, rhs: Runtime_V1_WindowsNamespaceOption) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsSandboxSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsSandboxSecurityContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "run_as_username"),
    2: .standard(proto: "credential_spec"),
    3: .standard(proto: "host_process"),
    4: .standard(proto: "namespace_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runAsUsername) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.credentialSpec) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hostProcess) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._namespaceOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.runAsUsername.isEmpty {
      try visitor.visitSingularStringField(value: self.runAsUsername, fieldNumber: 1)
    }
    if !self.credentialSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialSpec, fieldNumber: 2)
    }
    if self.hostProcess != false {
      try visitor.visitSingularBoolField(value: self.hostProcess, fieldNumber: 3)
    }
    try { if let v = self._namespaceOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsSandboxSecurityContext, rhs: Runtime_V1_WindowsSandboxSecurityContext) -> Bool {
    if lhs.runAsUsername != rhs.runAsUsername {return false}
    if lhs.credentialSpec != rhs.credentialSpec {return false}
    if lhs.hostProcess != rhs.hostProcess {return false}
    if lhs._namespaceOptions != rhs._namespaceOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsPodSandboxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsPodSandboxConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "security_context"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._securityContext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._securityContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsPodSandboxConfig, rhs: Runtime_V1_WindowsPodSandboxConfig) -> Bool {
    if lhs._securityContext != rhs._securityContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsContainerSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsContainerSecurityContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "run_as_username"),
    2: .standard(proto: "credential_spec"),
    3: .standard(proto: "host_process"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runAsUsername) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.credentialSpec) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hostProcess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runAsUsername.isEmpty {
      try visitor.visitSingularStringField(value: self.runAsUsername, fieldNumber: 1)
    }
    if !self.credentialSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialSpec, fieldNumber: 2)
    }
    if self.hostProcess != false {
      try visitor.visitSingularBoolField(value: self.hostProcess, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsContainerSecurityContext, rhs: Runtime_V1_WindowsContainerSecurityContext) -> Bool {
    if lhs.runAsUsername != rhs.runAsUsername {return false}
    if lhs.credentialSpec != rhs.credentialSpec {return false}
    if lhs.hostProcess != rhs.hostProcess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsContainerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsContainerConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resources"),
    2: .standard(proto: "security_context"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resources) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._securityContext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resources {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._securityContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsContainerConfig, rhs: Runtime_V1_WindowsContainerConfig) -> Bool {
    if lhs._resources != rhs._resources {return false}
    if lhs._securityContext != rhs._securityContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsContainerResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsContainerResources"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpu_shares"),
    2: .standard(proto: "cpu_count"),
    3: .standard(proto: "cpu_maximum"),
    4: .standard(proto: "memory_limit_in_bytes"),
    5: .standard(proto: "rootfs_size_in_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.cpuShares) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.cpuCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.cpuMaximum) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.memoryLimitInBytes) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.rootfsSizeInBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuShares != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuShares, fieldNumber: 1)
    }
    if self.cpuCount != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuCount, fieldNumber: 2)
    }
    if self.cpuMaximum != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuMaximum, fieldNumber: 3)
    }
    if self.memoryLimitInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.memoryLimitInBytes, fieldNumber: 4)
    }
    if self.rootfsSizeInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.rootfsSizeInBytes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsContainerResources, rhs: Runtime_V1_WindowsContainerResources) -> Bool {
    if lhs.cpuShares != rhs.cpuShares {return false}
    if lhs.cpuCount != rhs.cpuCount {return false}
    if lhs.cpuMaximum != rhs.cpuMaximum {return false}
    if lhs.memoryLimitInBytes != rhs.memoryLimitInBytes {return false}
    if lhs.rootfsSizeInBytes != rhs.rootfsSizeInBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "attempt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.attempt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.attempt != 0 {
      try visitor.visitSingularUInt32Field(value: self.attempt, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerMetadata, rhs: Runtime_V1_ContainerMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_path"),
    2: .standard(proto: "host_path"),
    3: .same(proto: "permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hostPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.permissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerPath.isEmpty {
      try visitor.visitSingularStringField(value: self.containerPath, fieldNumber: 1)
    }
    if !self.hostPath.isEmpty {
      try visitor.visitSingularStringField(value: self.hostPath, fieldNumber: 2)
    }
    if !self.permissions.isEmpty {
      try visitor.visitSingularStringField(value: self.permissions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_Device, rhs: Runtime_V1_Device) -> Bool {
    if lhs.containerPath != rhs.containerPath {return false}
    if lhs.hostPath != rhs.hostPath {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_CDIDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CDIDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_CDIDevice, rhs: Runtime_V1_CDIDevice) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "image"),
    3: .same(proto: "command"),
    4: .same(proto: "args"),
    5: .standard(proto: "working_dir"),
    6: .same(proto: "envs"),
    7: .same(proto: "mounts"),
    8: .same(proto: "devices"),
    9: .same(proto: "labels"),
    10: .same(proto: "annotations"),
    11: .standard(proto: "log_path"),
    12: .same(proto: "stdin"),
    13: .standard(proto: "stdin_once"),
    14: .same(proto: "tty"),
    15: .same(proto: "linux"),
    16: .same(proto: "windows"),
    17: .standard(proto: "CDI_devices"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Runtime_V1_ContainerMetadata? = nil
    var _image: Runtime_V1_ImageSpec? = nil
    var _command: [String] = []
    var _args: [String] = []
    var _workingDir: String = String()
    var _envs: [Runtime_V1_KeyValue] = []
    var _mounts: [Runtime_V1_Mount] = []
    var _devices: [Runtime_V1_Device] = []
    var _labels: Dictionary<String,String> = [:]
    var _annotations: Dictionary<String,String> = [:]
    var _logPath: String = String()
    var _stdin: Bool = false
    var _stdinOnce: Bool = false
    var _tty: Bool = false
    var _linux: Runtime_V1_LinuxContainerConfig? = nil
    var _windows: Runtime_V1_WindowsContainerConfig? = nil
    var _cdiDevices: [Runtime_V1_CDIDevice] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _image = source._image
      _command = source._command
      _args = source._args
      _workingDir = source._workingDir
      _envs = source._envs
      _mounts = source._mounts
      _devices = source._devices
      _labels = source._labels
      _annotations = source._annotations
      _logPath = source._logPath
      _stdin = source._stdin
      _stdinOnce = source._stdinOnce
      _tty = source._tty
      _linux = source._linux
      _windows = source._windows
      _cdiDevices = source._cdiDevices
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._command) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._args) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._workingDir) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._envs) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._mounts) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._devices) }()
        case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._annotations) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._logPath) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._stdin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._stdinOnce) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._tty) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._linux) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._windows) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._cdiDevices) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._command.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._command, fieldNumber: 3)
      }
      if !_storage._args.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._args, fieldNumber: 4)
      }
      if !_storage._workingDir.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workingDir, fieldNumber: 5)
      }
      if !_storage._envs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._envs, fieldNumber: 6)
      }
      if !_storage._mounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mounts, fieldNumber: 7)
      }
      if !_storage._devices.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._devices, fieldNumber: 8)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 9)
      }
      if !_storage._annotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._annotations, fieldNumber: 10)
      }
      if !_storage._logPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logPath, fieldNumber: 11)
      }
      if _storage._stdin != false {
        try visitor.visitSingularBoolField(value: _storage._stdin, fieldNumber: 12)
      }
      if _storage._stdinOnce != false {
        try visitor.visitSingularBoolField(value: _storage._stdinOnce, fieldNumber: 13)
      }
      if _storage._tty != false {
        try visitor.visitSingularBoolField(value: _storage._tty, fieldNumber: 14)
      }
      try { if let v = _storage._linux {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._windows {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._cdiDevices.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cdiDevices, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerConfig, rhs: Runtime_V1_ContainerConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._args != rhs_storage._args {return false}
        if _storage._workingDir != rhs_storage._workingDir {return false}
        if _storage._envs != rhs_storage._envs {return false}
        if _storage._mounts != rhs_storage._mounts {return false}
        if _storage._devices != rhs_storage._devices {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._annotations != rhs_storage._annotations {return false}
        if _storage._logPath != rhs_storage._logPath {return false}
        if _storage._stdin != rhs_storage._stdin {return false}
        if _storage._stdinOnce != rhs_storage._stdinOnce {return false}
        if _storage._tty != rhs_storage._tty {return false}
        if _storage._linux != rhs_storage._linux {return false}
        if _storage._windows != rhs_storage._windows {return false}
        if _storage._cdiDevices != rhs_storage._cdiDevices {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_CreateContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateContainerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_sandbox_id"),
    2: .same(proto: "config"),
    3: .standard(proto: "sandbox_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sandboxConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 1)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sandboxConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_CreateContainerRequest, rhs: Runtime_V1_CreateContainerRequest) -> Bool {
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs._config != rhs._config {return false}
    if lhs._sandboxConfig != rhs._sandboxConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_CreateContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateContainerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_CreateContainerResponse, rhs: Runtime_V1_CreateContainerResponse) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_StartContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartContainerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_StartContainerRequest, rhs: Runtime_V1_StartContainerRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_StartContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartContainerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_StartContainerResponse, rhs: Runtime_V1_StartContainerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_StopContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopContainerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt64Field(value: self.timeout, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_StopContainerRequest, rhs: Runtime_V1_StopContainerRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_StopContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopContainerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_StopContainerResponse, rhs: Runtime_V1_StopContainerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RemoveContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveContainerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RemoveContainerRequest, rhs: Runtime_V1_RemoveContainerRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RemoveContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveContainerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RemoveContainerResponse, rhs: Runtime_V1_RemoveContainerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerStateValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStateValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .containerCreated {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerStateValue, rhs: Runtime_V1_ContainerStateValue) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "state"),
    3: .standard(proto: "pod_sandbox_id"),
    4: .standard(proto: "label_selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labelSelector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 3)
    }
    if !self.labelSelector.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labelSelector, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerFilter, rhs: Runtime_V1_ContainerFilter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._state != rhs._state {return false}
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.labelSelector != rhs.labelSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListContainersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListContainersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListContainersRequest, rhs: Runtime_V1_ListContainersRequest) -> Bool {
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_Container: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Container"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pod_sandbox_id"),
    3: .same(proto: "metadata"),
    4: .same(proto: "image"),
    5: .standard(proto: "image_ref"),
    6: .same(proto: "state"),
    7: .standard(proto: "created_at"),
    8: .same(proto: "labels"),
    9: .same(proto: "annotations"),
    10: .standard(proto: "image_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageRef) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.createdAt) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.annotations) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 2)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.imageRef.isEmpty {
      try visitor.visitSingularStringField(value: self.imageRef, fieldNumber: 5)
    }
    if self.state != .containerCreated {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAt, fieldNumber: 7)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 8)
    }
    if !self.annotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.annotations, fieldNumber: 9)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_Container, rhs: Runtime_V1_Container) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._image != rhs._image {return false}
    if lhs.imageRef != rhs.imageRef {return false}
    if lhs.state != rhs.state {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListContainersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListContainersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "containers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.containers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.containers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListContainersResponse, rhs: Runtime_V1_ListContainersResponse) -> Bool {
    if lhs.containers != rhs.containers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .same(proto: "verbose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.verbose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerStatusRequest, rhs: Runtime_V1_ContainerStatusRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.verbose != rhs.verbose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
    3: .same(proto: "state"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "started_at"),
    6: .standard(proto: "finished_at"),
    7: .standard(proto: "exit_code"),
    8: .same(proto: "image"),
    9: .standard(proto: "image_ref"),
    10: .same(proto: "reason"),
    11: .same(proto: "message"),
    12: .same(proto: "labels"),
    13: .same(proto: "annotations"),
    14: .same(proto: "mounts"),
    15: .standard(proto: "log_path"),
    16: .same(proto: "resources"),
    17: .standard(proto: "image_id"),
    18: .same(proto: "user"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _metadata: Runtime_V1_ContainerMetadata? = nil
    var _state: Runtime_V1_ContainerState = .containerCreated
    var _createdAt: Int64 = 0
    var _startedAt: Int64 = 0
    var _finishedAt: Int64 = 0
    var _exitCode: Int32 = 0
    var _image: Runtime_V1_ImageSpec? = nil
    var _imageRef: String = String()
    var _reason: String = String()
    var _message: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _annotations: Dictionary<String,String> = [:]
    var _mounts: [Runtime_V1_Mount] = []
    var _logPath: String = String()
    var _resources: Runtime_V1_ContainerResources? = nil
    var _imageID: String = String()
    var _user: Runtime_V1_ContainerUser? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _metadata = source._metadata
      _state = source._state
      _createdAt = source._createdAt
      _startedAt = source._startedAt
      _finishedAt = source._finishedAt
      _exitCode = source._exitCode
      _image = source._image
      _imageRef = source._imageRef
      _reason = source._reason
      _message = source._message
      _labels = source._labels
      _annotations = source._annotations
      _mounts = source._mounts
      _logPath = source._logPath
      _resources = source._resources
      _imageID = source._imageID
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._startedAt) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._finishedAt) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._exitCode) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._imageRef) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._reason) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._annotations) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._mounts) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._logPath) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._resources) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._imageID) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._state != .containerCreated {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 4)
      }
      if _storage._startedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._startedAt, fieldNumber: 5)
      }
      if _storage._finishedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._finishedAt, fieldNumber: 6)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 7)
      }
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._imageRef.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imageRef, fieldNumber: 9)
      }
      if !_storage._reason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 10)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 11)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 12)
      }
      if !_storage._annotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._annotations, fieldNumber: 13)
      }
      if !_storage._mounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mounts, fieldNumber: 14)
      }
      if !_storage._logPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logPath, fieldNumber: 15)
      }
      try { if let v = _storage._resources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._imageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imageID, fieldNumber: 17)
      }
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerStatus, rhs: Runtime_V1_ContainerStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._startedAt != rhs_storage._startedAt {return false}
        if _storage._finishedAt != rhs_storage._finishedAt {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._imageRef != rhs_storage._imageRef {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._annotations != rhs_storage._annotations {return false}
        if _storage._mounts != rhs_storage._mounts {return false}
        if _storage._logPath != rhs_storage._logPath {return false}
        if _storage._resources != rhs_storage._resources {return false}
        if _storage._imageID != rhs_storage._imageID {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.info, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerStatusResponse, rhs: Runtime_V1_ContainerStatusResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerResources"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "linux"),
    2: .same(proto: "windows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._linux) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._windows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._linux {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._windows {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerResources, rhs: Runtime_V1_ContainerResources) -> Bool {
    if lhs._linux != rhs._linux {return false}
    if lhs._windows != rhs._windows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "linux"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._linux) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._linux {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerUser, rhs: Runtime_V1_ContainerUser) -> Bool {
    if lhs._linux != rhs._linux {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_UpdateContainerResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateContainerResourcesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .same(proto: "linux"),
    3: .same(proto: "windows"),
    4: .same(proto: "annotations"),
  ]

  fileprivate class _StorageClass {
    var _containerID: String = String()
    var _linux: Runtime_V1_LinuxContainerResources? = nil
    var _windows: Runtime_V1_WindowsContainerResources? = nil
    var _annotations: Dictionary<String,String> = [:]

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _containerID = source._containerID
      _linux = source._linux
      _windows = source._windows
      _annotations = source._annotations
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._containerID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._linux) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._windows) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._annotations) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._containerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._containerID, fieldNumber: 1)
      }
      try { if let v = _storage._linux {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._windows {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._annotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._annotations, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_UpdateContainerResourcesRequest, rhs: Runtime_V1_UpdateContainerResourcesRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._containerID != rhs_storage._containerID {return false}
        if _storage._linux != rhs_storage._linux {return false}
        if _storage._windows != rhs_storage._windows {return false}
        if _storage._annotations != rhs_storage._annotations {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_UpdateContainerResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateContainerResourcesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_UpdateContainerResourcesResponse, rhs: Runtime_V1_UpdateContainerResourcesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ExecSyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecSyncRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .same(proto: "cmd"),
    3: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.cmd) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    if !self.cmd.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cmd, fieldNumber: 2)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt64Field(value: self.timeout, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ExecSyncRequest, rhs: Runtime_V1_ExecSyncRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.cmd != rhs.cmd {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ExecSyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecSyncResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdout"),
    2: .same(proto: "stderr"),
    3: .standard(proto: "exit_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.stdout) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.stderr) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stdout.isEmpty {
      try visitor.visitSingularBytesField(value: self.stdout, fieldNumber: 1)
    }
    if !self.stderr.isEmpty {
      try visitor.visitSingularBytesField(value: self.stderr, fieldNumber: 2)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ExecSyncResponse, rhs: Runtime_V1_ExecSyncResponse) -> Bool {
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ExecRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .same(proto: "cmd"),
    3: .same(proto: "tty"),
    4: .same(proto: "stdin"),
    5: .same(proto: "stdout"),
    6: .same(proto: "stderr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.cmd) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tty) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.stdin) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.stdout) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.stderr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    if !self.cmd.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cmd, fieldNumber: 2)
    }
    if self.tty != false {
      try visitor.visitSingularBoolField(value: self.tty, fieldNumber: 3)
    }
    if self.stdin != false {
      try visitor.visitSingularBoolField(value: self.stdin, fieldNumber: 4)
    }
    if self.stdout != false {
      try visitor.visitSingularBoolField(value: self.stdout, fieldNumber: 5)
    }
    if self.stderr != false {
      try visitor.visitSingularBoolField(value: self.stderr, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ExecRequest, rhs: Runtime_V1_ExecRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.cmd != rhs.cmd {return false}
    if lhs.tty != rhs.tty {return false}
    if lhs.stdin != rhs.stdin {return false}
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ExecResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ExecResponse, rhs: Runtime_V1_ExecResponse) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_AttachRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .same(proto: "stdin"),
    3: .same(proto: "tty"),
    4: .same(proto: "stdout"),
    5: .same(proto: "stderr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.stdin) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tty) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.stdout) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.stderr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    if self.stdin != false {
      try visitor.visitSingularBoolField(value: self.stdin, fieldNumber: 2)
    }
    if self.tty != false {
      try visitor.visitSingularBoolField(value: self.tty, fieldNumber: 3)
    }
    if self.stdout != false {
      try visitor.visitSingularBoolField(value: self.stdout, fieldNumber: 4)
    }
    if self.stderr != false {
      try visitor.visitSingularBoolField(value: self.stderr, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_AttachRequest, rhs: Runtime_V1_AttachRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.stdin != rhs.stdin {return false}
    if lhs.tty != rhs.tty {return false}
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_AttachResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_AttachResponse, rhs: Runtime_V1_AttachResponse) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PortForwardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortForwardRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_sandbox_id"),
    2: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 1)
    }
    if !self.port.isEmpty {
      try visitor.visitPackedInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PortForwardRequest, rhs: Runtime_V1_PortForwardRequest) -> Bool {
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PortForwardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortForwardResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PortForwardResponse, rhs: Runtime_V1_PortForwardResponse) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ImageFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ImageFilter, rhs: Runtime_V1_ImageFilter) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListImagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListImagesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListImagesRequest, rhs: Runtime_V1_ListImagesRequest) -> Bool {
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Image"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "repo_tags"),
    3: .standard(proto: "repo_digests"),
    4: .same(proto: "size"),
    5: .same(proto: "uid"),
    6: .same(proto: "username"),
    7: .same(proto: "spec"),
    8: .same(proto: "pinned"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.repoTags) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.repoDigests) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._uid) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.pinned) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.repoTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.repoTags, fieldNumber: 2)
    }
    if !self.repoDigests.isEmpty {
      try visitor.visitRepeatedStringField(value: self.repoDigests, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 4)
    }
    try { if let v = self._uid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 6)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.pinned != false {
      try visitor.visitSingularBoolField(value: self.pinned, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_Image, rhs: Runtime_V1_Image) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.repoTags != rhs.repoTags {return false}
    if lhs.repoDigests != rhs.repoDigests {return false}
    if lhs.size != rhs.size {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs.username != rhs.username {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.pinned != rhs.pinned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListImagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListImagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "images"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListImagesResponse, rhs: Runtime_V1_ListImagesResponse) -> Bool {
    if lhs.images != rhs.images {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ImageStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "verbose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.verbose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ImageStatusRequest, rhs: Runtime_V1_ImageStatusRequest) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.verbose != rhs.verbose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ImageStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.info, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ImageStatusResponse, rhs: Runtime_V1_ImageStatusResponse) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_AuthConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .same(proto: "auth"),
    4: .standard(proto: "server_address"),
    5: .standard(proto: "identity_token"),
    6: .standard(proto: "registry_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.auth) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serverAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identityToken) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.registryToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.auth.isEmpty {
      try visitor.visitSingularStringField(value: self.auth, fieldNumber: 3)
    }
    if !self.serverAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.serverAddress, fieldNumber: 4)
    }
    if !self.identityToken.isEmpty {
      try visitor.visitSingularStringField(value: self.identityToken, fieldNumber: 5)
    }
    if !self.registryToken.isEmpty {
      try visitor.visitSingularStringField(value: self.registryToken, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_AuthConfig, rhs: Runtime_V1_AuthConfig) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.auth != rhs.auth {return false}
    if lhs.serverAddress != rhs.serverAddress {return false}
    if lhs.identityToken != rhs.identityToken {return false}
    if lhs.registryToken != rhs.registryToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PullImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PullImageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "auth"),
    3: .standard(proto: "sandbox_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sandboxConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sandboxConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PullImageRequest, rhs: Runtime_V1_PullImageRequest) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs._sandboxConfig != rhs._sandboxConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PullImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PullImageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imageRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageRef.isEmpty {
      try visitor.visitSingularStringField(value: self.imageRef, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PullImageResponse, rhs: Runtime_V1_PullImageResponse) -> Bool {
    if lhs.imageRef != rhs.imageRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RemoveImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveImageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RemoveImageRequest, rhs: Runtime_V1_RemoveImageRequest) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RemoveImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveImageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RemoveImageResponse, rhs: Runtime_V1_RemoveImageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_NetworkConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_cidr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podCidr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podCidr.isEmpty {
      try visitor.visitSingularStringField(value: self.podCidr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_NetworkConfig, rhs: Runtime_V1_NetworkConfig) -> Bool {
    if lhs.podCidr != rhs.podCidr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RuntimeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "network_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._networkConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._networkConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RuntimeConfig, rhs: Runtime_V1_RuntimeConfig) -> Bool {
    if lhs._networkConfig != rhs._networkConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_UpdateRuntimeConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateRuntimeConfigRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "runtime_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._runtimeConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._runtimeConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_UpdateRuntimeConfigRequest, rhs: Runtime_V1_UpdateRuntimeConfigRequest) -> Bool {
    if lhs._runtimeConfig != rhs._runtimeConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_UpdateRuntimeConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateRuntimeConfigResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_UpdateRuntimeConfigResponse, rhs: Runtime_V1_UpdateRuntimeConfigResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RuntimeCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "reason"),
    4: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RuntimeCondition, rhs: Runtime_V1_RuntimeCondition) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.status != rhs.status {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RuntimeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RuntimeStatus, rhs: Runtime_V1_RuntimeStatus) -> Bool {
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verbose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.verbose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_StatusRequest, rhs: Runtime_V1_StatusRequest) -> Bool {
    if lhs.verbose != rhs.verbose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RuntimeHandlerFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeHandlerFeatures"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recursive_read_only_mounts"),
    2: .standard(proto: "user_namespaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.recursiveReadOnlyMounts) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.userNamespaces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.recursiveReadOnlyMounts != false {
      try visitor.visitSingularBoolField(value: self.recursiveReadOnlyMounts, fieldNumber: 1)
    }
    if self.userNamespaces != false {
      try visitor.visitSingularBoolField(value: self.userNamespaces, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RuntimeHandlerFeatures, rhs: Runtime_V1_RuntimeHandlerFeatures) -> Bool {
    if lhs.recursiveReadOnlyMounts != rhs.recursiveReadOnlyMounts {return false}
    if lhs.userNamespaces != rhs.userNamespaces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RuntimeHandler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeHandler"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._features) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._features {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RuntimeHandler, rhs: Runtime_V1_RuntimeHandler) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._features != rhs._features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "info"),
    3: .standard(proto: "runtime_handlers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.info) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.runtimeHandlers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.info, fieldNumber: 2)
    }
    if !self.runtimeHandlers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runtimeHandlers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_StatusResponse, rhs: Runtime_V1_StatusResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.info != rhs.info {return false}
    if lhs.runtimeHandlers != rhs.runtimeHandlers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ImageFsInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageFsInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ImageFsInfoRequest, rhs: Runtime_V1_ImageFsInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_UInt64Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UInt64Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_UInt64Value, rhs: Runtime_V1_UInt64Value) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_FilesystemIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilesystemIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mountpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mountpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mountpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.mountpoint, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_FilesystemIdentifier, rhs: Runtime_V1_FilesystemIdentifier) -> Bool {
    if lhs.mountpoint != rhs.mountpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_FilesystemUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilesystemUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "fs_id"),
    3: .standard(proto: "used_bytes"),
    4: .standard(proto: "inodes_used"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fsID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usedBytes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._inodesUsed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._fsID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._usedBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._inodesUsed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_FilesystemUsage, rhs: Runtime_V1_FilesystemUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._fsID != rhs._fsID {return false}
    if lhs._usedBytes != rhs._usedBytes {return false}
    if lhs._inodesUsed != rhs._inodesUsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsFilesystemUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsFilesystemUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "fs_id"),
    3: .standard(proto: "used_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fsID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usedBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._fsID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._usedBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsFilesystemUsage, rhs: Runtime_V1_WindowsFilesystemUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._fsID != rhs._fsID {return false}
    if lhs._usedBytes != rhs._usedBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ImageFsInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageFsInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_filesystems"),
    2: .standard(proto: "container_filesystems"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.imageFilesystems) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.containerFilesystems) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageFilesystems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.imageFilesystems, fieldNumber: 1)
    }
    if !self.containerFilesystems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.containerFilesystems, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ImageFsInfoResponse, rhs: Runtime_V1_ImageFsInfoResponse) -> Bool {
    if lhs.imageFilesystems != rhs.imageFilesystems {return false}
    if lhs.containerFilesystems != rhs.containerFilesystems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerStatsRequest, rhs: Runtime_V1_ContainerStatsRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerStatsResponse, rhs: Runtime_V1_ContainerStatsResponse) -> Bool {
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListContainerStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListContainerStatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListContainerStatsRequest, rhs: Runtime_V1_ListContainerStatsRequest) -> Bool {
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerStatsFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStatsFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pod_sandbox_id"),
    3: .standard(proto: "label_selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labelSelector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 2)
    }
    if !self.labelSelector.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labelSelector, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerStatsFilter, rhs: Runtime_V1_ContainerStatsFilter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.labelSelector != rhs.labelSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListContainerStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListContainerStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListContainerStatsResponse, rhs: Runtime_V1_ListContainerStatsResponse) -> Bool {
    if lhs.stats != rhs.stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
    3: .same(proto: "labels"),
    4: .same(proto: "annotations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.annotations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    if !self.annotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.annotations, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerAttributes, rhs: Runtime_V1_ContainerAttributes) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributes"),
    2: .same(proto: "cpu"),
    3: .same(proto: "memory"),
    4: .standard(proto: "writable_layer"),
    5: .same(proto: "swap"),
  ]

  fileprivate class _StorageClass {
    var _attributes: Runtime_V1_ContainerAttributes? = nil
    var _cpu: Runtime_V1_CpuUsage? = nil
    var _memory: Runtime_V1_MemoryUsage? = nil
    var _writableLayer: Runtime_V1_FilesystemUsage? = nil
    var _swap: Runtime_V1_SwapUsage? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _attributes = source._attributes
      _cpu = source._cpu
      _memory = source._memory
      _writableLayer = source._writableLayer
      _swap = source._swap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._attributes) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cpu) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._memory) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._writableLayer) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._swap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._attributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._cpu {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memory {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._writableLayer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._swap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerStats, rhs: Runtime_V1_ContainerStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._writableLayer != rhs_storage._writableLayer {return false}
        if _storage._swap != rhs_storage._swap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsContainerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsContainerStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributes"),
    2: .same(proto: "cpu"),
    3: .same(proto: "memory"),
    4: .standard(proto: "writable_layer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cpu) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memory) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._writableLayer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cpu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._writableLayer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsContainerStats, rhs: Runtime_V1_WindowsContainerStats) -> Bool {
    if lhs._attributes != rhs._attributes {return false}
    if lhs._cpu != rhs._cpu {return false}
    if lhs._memory != rhs._memory {return false}
    if lhs._writableLayer != rhs._writableLayer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_CpuUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CpuUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "usage_core_nano_seconds"),
    3: .standard(proto: "usage_nano_cores"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._usageCoreNanoSeconds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usageNanoCores) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._usageCoreNanoSeconds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._usageNanoCores {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_CpuUsage, rhs: Runtime_V1_CpuUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._usageCoreNanoSeconds != rhs._usageCoreNanoSeconds {return false}
    if lhs._usageNanoCores != rhs._usageNanoCores {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsCpuUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsCpuUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "usage_core_nano_seconds"),
    3: .standard(proto: "usage_nano_cores"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._usageCoreNanoSeconds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usageNanoCores) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._usageCoreNanoSeconds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._usageNanoCores {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsCpuUsage, rhs: Runtime_V1_WindowsCpuUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._usageCoreNanoSeconds != rhs._usageCoreNanoSeconds {return false}
    if lhs._usageNanoCores != rhs._usageNanoCores {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_MemoryUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemoryUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "working_set_bytes"),
    3: .standard(proto: "available_bytes"),
    4: .standard(proto: "usage_bytes"),
    5: .standard(proto: "rss_bytes"),
    6: .standard(proto: "page_faults"),
    7: .standard(proto: "major_page_faults"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workingSetBytes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._availableBytes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._usageBytes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._rssBytes) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._pageFaults) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._majorPageFaults) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._workingSetBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._availableBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._usageBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._rssBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._pageFaults {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._majorPageFaults {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_MemoryUsage, rhs: Runtime_V1_MemoryUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._workingSetBytes != rhs._workingSetBytes {return false}
    if lhs._availableBytes != rhs._availableBytes {return false}
    if lhs._usageBytes != rhs._usageBytes {return false}
    if lhs._rssBytes != rhs._rssBytes {return false}
    if lhs._pageFaults != rhs._pageFaults {return false}
    if lhs._majorPageFaults != rhs._majorPageFaults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_SwapUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "swap_available_bytes"),
    3: .standard(proto: "swap_usage_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._swapAvailableBytes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._swapUsageBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._swapAvailableBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._swapUsageBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_SwapUsage, rhs: Runtime_V1_SwapUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._swapAvailableBytes != rhs._swapAvailableBytes {return false}
    if lhs._swapUsageBytes != rhs._swapUsageBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_WindowsMemoryUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsMemoryUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "working_set_bytes"),
    3: .standard(proto: "available_bytes"),
    4: .standard(proto: "page_faults"),
    5: .standard(proto: "commit_memory_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workingSetBytes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._availableBytes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pageFaults) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._commitMemoryBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if let v = self._workingSetBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._availableBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pageFaults {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._commitMemoryBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_WindowsMemoryUsage, rhs: Runtime_V1_WindowsMemoryUsage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._workingSetBytes != rhs._workingSetBytes {return false}
    if lhs._availableBytes != rhs._availableBytes {return false}
    if lhs._pageFaults != rhs._pageFaults {return false}
    if lhs._commitMemoryBytes != rhs._commitMemoryBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ReopenContainerLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReopenContainerLogRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ReopenContainerLogRequest, rhs: Runtime_V1_ReopenContainerLogRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ReopenContainerLogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReopenContainerLogResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ReopenContainerLogResponse, rhs: Runtime_V1_ReopenContainerLogResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_CheckpointContainerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckpointContainerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .same(proto: "location"),
    3: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 2)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt64Field(value: self.timeout, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_CheckpointContainerRequest, rhs: Runtime_V1_CheckpointContainerRequest) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.location != rhs.location {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_CheckpointContainerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckpointContainerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_CheckpointContainerResponse, rhs: Runtime_V1_CheckpointContainerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_GetEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetEventsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_GetEventsRequest, rhs: Runtime_V1_GetEventsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerEventResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .standard(proto: "container_event_type"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "pod_sandbox_status"),
    5: .standard(proto: "containers_statuses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.containerEventType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._podSandboxStatus) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.containersStatuses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    if self.containerEventType != .containerCreatedEvent {
      try visitor.visitSingularEnumField(value: self.containerEventType, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    try { if let v = self._podSandboxStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.containersStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.containersStatuses, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerEventResponse, rhs: Runtime_V1_ContainerEventResponse) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.containerEventType != rhs.containerEventType {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._podSandboxStatus != rhs._podSandboxStatus {return false}
    if lhs.containersStatuses != rhs.containersStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListMetricDescriptorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMetricDescriptorsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListMetricDescriptorsRequest, rhs: Runtime_V1_ListMetricDescriptorsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListMetricDescriptorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMetricDescriptorsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "descriptors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.descriptors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListMetricDescriptorsResponse, rhs: Runtime_V1_ListMetricDescriptorsResponse) -> Bool {
    if lhs.descriptors != rhs.descriptors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_MetricDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetricDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "help"),
    3: .standard(proto: "label_keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.help) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.labelKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.help.isEmpty {
      try visitor.visitSingularStringField(value: self.help, fieldNumber: 2)
    }
    if !self.labelKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.labelKeys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_MetricDescriptor, rhs: Runtime_V1_MetricDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.help != rhs.help {return false}
    if lhs.labelKeys != rhs.labelKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListPodSandboxMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPodSandboxMetricsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListPodSandboxMetricsRequest, rhs: Runtime_V1_ListPodSandboxMetricsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ListPodSandboxMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPodSandboxMetricsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.podMetrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.podMetrics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ListPodSandboxMetricsResponse, rhs: Runtime_V1_ListPodSandboxMetricsResponse) -> Bool {
    if lhs.podMetrics != rhs.podMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_PodSandboxMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSandboxMetrics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_sandbox_id"),
    2: .same(proto: "metrics"),
    3: .standard(proto: "container_metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podSandboxID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metrics) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.containerMetrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podSandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.podSandboxID, fieldNumber: 1)
    }
    if !self.metrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metrics, fieldNumber: 2)
    }
    if !self.containerMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.containerMetrics, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_PodSandboxMetrics, rhs: Runtime_V1_PodSandboxMetrics) -> Bool {
    if lhs.podSandboxID != rhs.podSandboxID {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.containerMetrics != rhs.containerMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_ContainerMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerMetrics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_id"),
    2: .same(proto: "metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 1)
    }
    if !self.metrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_ContainerMetrics, rhs: Runtime_V1_ContainerMetrics) -> Bool {
    if lhs.containerID != rhs.containerID {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Metric"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "timestamp"),
    3: .standard(proto: "metric_type"),
    4: .standard(proto: "label_values"),
    5: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.metricType) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.labelValues) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.metricType != .counter {
      try visitor.visitSingularEnumField(value: self.metricType, fieldNumber: 3)
    }
    if !self.labelValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.labelValues, fieldNumber: 4)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_Metric, rhs: Runtime_V1_Metric) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.metricType != rhs.metricType {return false}
    if lhs.labelValues != rhs.labelValues {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RuntimeConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeConfigRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RuntimeConfigRequest, rhs: Runtime_V1_RuntimeConfigRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_RuntimeConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeConfigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "linux"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._linux) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._linux {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_RuntimeConfigResponse, rhs: Runtime_V1_RuntimeConfigResponse) -> Bool {
    if lhs._linux != rhs._linux {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Runtime_V1_LinuxRuntimeConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinuxRuntimeConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cgroup_driver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.cgroupDriver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cgroupDriver != .systemd {
      try visitor.visitSingularEnumField(value: self.cgroupDriver, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Runtime_V1_LinuxRuntimeConfiguration, rhs: Runtime_V1_LinuxRuntimeConfiguration) -> Bool {
    if lhs.cgroupDriver != rhs.cgroupDriver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
